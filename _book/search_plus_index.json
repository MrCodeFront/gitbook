{"./":{"url":"./","title":"前言","keywords":"","body":"前言 欢迎阅读 CodeFront 笔记 我们的口号是：日积月累，提升自我！ 作者正在内卷中... Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-03-30 13:26:32 "},"android/Android学习.html":{"url":"android/Android学习.html","title":"Android学习","keywords":"","body":"Android 学习 词汇 AVD（安卓虚拟设备） 应用组件(共4种) 1.Activity 2.服务 3.广播接收器 4.内容提供程序 https://developer.android.google.cn/guide/components/fundamentals Activity 是与用户交互的入口点。它表示拥有界面的单个屏幕. 服务 是一个通用入口点，用于因各种原因使应用在后台保持运行状态。它是一种在后台运行的组件，用于执行长时间运行的操作或为远程进程执行作业。服务不提供界面。 借助广播接收器组件，系统能够在常规用户流之外向应用传递事件，从而允许应用响应系统范围内的广播通知。 内容提供程序 管理一组共享的应用数据，您可以将这些数据存储在文件系统、SQLite 数据库、网络中或者您的应用可访问的任何其他持久化存储位置。 在 Android 系统启动应用组件之前，系统必须通过读取应用的清单文件 (AndroidManifest.xml) 确认组件存在。您的应用必须在此文件中声明其所有组件，该文件必须位于应用项目目录的根目录中。 Android API https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element#ApiLevels 什么是API级别 API 级别是对 Android 平台版本提供的框架 API 修订版进行唯一标识的整数值。 Android 平台提供一种框架 API，应用可利用它与底层 Android 系统进行交互。该框架 API 由以下部分组成： 一组核心软件包和类 一组用于声明清单文件的 XML 元素和属性 一组用于声明和访问资源的 XML 元素和属性 一组 Intent 一组应用可请求的权限，以及系统中包括的权限强制执行 Android 平台的每个后续版本均可包括其提供的 Android 应用框架 API 的更新。 框架 API 更新的设计用途是使新 API 与早期版本的 API 保持兼容。换言之，大多数 API 更改都是新增更改，并且会引入新功能或替代功能。在 API 的某些部分得到升级时，系统会弃用经替换的旧版部分，但不会将其移除，以便其仍可供现有应用使用。在极少数情况下，系统可能会修改或移除 API 的某些部分，但通常只有在为确保 API 稳健性以及应用或系统安全性时，才需要进行此类更改。所有其他来自早期修订版的 API 部分都将继续保留，不做任何修改。 Android 平台提供的框架 API 使用称为“API 级别”的整数标识符指定。每个 Android 平台版本恰好支持一个 API 级别，但隐含对所有早期 API 级别（低至 API 级别 1）的支持。Android 平台初始版本提供的是 API 级别 1，后续版本的 API 级别则依次增加。 Android Studio 与 逍遥模拟器 连接 查看Microvirt\\MEmu\\MemuHyperv VMs\\MEmu目录下MEmu.memu的端口号。cmd 到逍遥模拟器Microvirt\\MEmu目录下，运行:adb.exe connect 127.0.0.1 看见 connected to 127.0.0.1:21503 表示连接成功 官方demo讲解: https://www.it610.com/article/1297923636153360384.htm Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2021-11-18 15:08:38 "},"android/打包.html":{"url":"android/打包.html","title":"打包","keywords":"","body":"Android 打包 自定义apk名称 路径：app/build.gradle android { android.applicationVariants.all { variant -> variant.outputs.all { //在这里修改apk文件名 outputFileName = \"01-cutting-supermarket-v${new String(variant.versionName).replace('.','')}.apk\" } } } 修改版本号 路径：app/build.gradle versionName 路径：app/build/generated/source/buildConfig/debug/io/ionic/starter/BuildConfig.java VERSION_NAME Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-03-30 13:26:32 "},"angular/Overlay遮罩.html":{"url":"angular/Overlay遮罩.html","title":"Overlay遮罩","keywords":"","body":"Overlay 遮罩 参考： https://zhuanlan.zhihu.com/p/146943731 github：https://github.com/angular/components/tree/7cd78ffc59c1975012b4a7913f147cedc9c97ae0/src/cdk/overlay OverlayContainer OverlayContainer 在 body 元素的最后创建了一个元素，用于包裹全部的浮层元素。之后我们会称该元素为 container element。 该元素会在 getContainerElement 方法第一次被调用的时候创建（惰性实例化）。 注意这个服务是全局的。 Overlay Overlay 是一个服务，通过它的 create 方法可以创建一个新的浮层，这个过程中主要做了以下几件事： 创建一个 host element 和一个 pane element，然后将 pane element 作为 PortalOutlet 的挂载点，而这里 PortalOutlet 的类型就是我在之前一篇文章中讲过的 DomPortalOutlet，它将会被用来挂在组件内容。 创建一个 OverlayConfig 对象，OverlayConfig 的构造方法仅仅是把 plain object 上面的非 undefined 属性转移到新创建的 OverlayConfig 对象上。 创建一个 OverlayRef 并返回，值得注意的是第一步中创建的 PortalOutlet 会被传递给 OverlayRef 的构造方法。 OverlayRef 类非常重要，它负责了浮层机制的绝大部分逻辑，并且是暴露给组件开发者操纵浮层的接口对象。 OverlayRef OverlayRef 的构造方法确定了该浮层的 scroll strategy 和 position strategy，这部分我们之后来谈。 组件开发者在新创建的浮层上添加组件时，应该调用 OverlayRef 的 attach 方法，参数应该是一个 Portal 对象。这个方法做了如下几件事情： 将 Portal attach 到 DomPortalOutlet 上，这一步会动态创建组件开发者定义的内容 启用 position strategy 通过 _updateStackingOrder 方法更新 host element 在 container element 中的位置，最新创建的浮层应该在 DOM 树的最上方 通过 _updateElementSize 方法更新 pane element 元素的样式 启用 scroll strategy 在 Angular zone 稳定之后（一般是组件 DOM 已经创建）调整浮层的位置 打开浮层的鼠标事件支持 根据配置创建 backdrop（之后再讲） 根据配置修改 pane element 的 CSS 类 派发 attach 事件 将自己注册到 KeyboardDispatcher 中（之后再讲） OverlayRef 类还有以下几个重要的方法： detach，卸载当前浮层添加的组件。 dispose，销毁当前浮层。 PositionStrategy attach 方法的第二步是启用 position strategy，这里我们先来讲解比较简单的 GlobalPositionStrategy，也是 BottomSheet 组件所使用的。 position strategy 就是定位策略，提供了一组定位浮层内元素的方法。 GlobalPositionStrategy 实现了 PositionStrategy 接口，用户也可以通过实现该接口自定义一个 position strategy。 attach 方法在浮层启用 position strategy 时被调用。对于 GlobalPositionStrategy 而言，主要是对 host element 增加了 cdk-global-overlay-wrapper CSS 类。 .cdk-global-overlay-wrapper { display: flex; position: absolute; z-index: 1000; pointer-events: none; top: 0; left: 0; height: 100%; width: 100%; } apply 方法在需要调整浮层元素位置时被调用。该方法通过修改 host element 和 pane element 的样式来控制浮层元素的位置。 还有如下方法比较重要： dispose，在 position strategy 被销毁（比如跟随浮层被销毁，或者浮层切换了 position strategy）的时候做回复操作。 其他方法都是暴露出来修改定位的，这里就不 cover 了。 辅助机制 Backdrop 有些浮层需要有一个后置的全屏图层，来凸显浮层内容，同时作为 MouseEvent 的 target，支持“点击浮层外关闭”这样的功能。 Backdrop 由 _attachBackdrop 方法所创建，实质上是创建了这样一个元素 并把它插入到 host element 之前，保持图层叠加的顺序。 同时在浮层上绑定了一个 click 事件的 handler，通过此 handle 派发 _backdropClick 事件。 KeyboardDispatcher KeyboardDispatcher 负责将键盘事件分派给最近打开的浮层。 之前讲到浮层 attach 的时候会调用 KeyboardDispatcher 的 add 方法，该方法会将调用此方法的 overlay 注册在 _attachedOverlays 数组的最后，且会第一个 overlay 注册的时候在 document 上绑定 keydown 事件的 handler，而该 handler 会从数组尾部开始逆序查找监听了 keydown 事件的 overlay，并对它派发 keydown 事件。 KeyboardDispatcher 使得最近一个打开的 overlay 才能监听键盘事件，一种常见的使用场景就是支持按 esc 键时有序地关闭 overlay。 ScrollStrategy scroll strategy 确定了在浮层展开时，原文档应当如何滚动。任意的 scroll strategy 都需要实现 ScrollStrategy 接口。 我们以 CDK 提供的 CloseScrollStrategy 为例，这种 strategy 会在页面内容滚动时关闭浮层。 在 OverlayRef 初始化时会调用 attach 方法，而 Overlay 的 attach 方法会调用 enable 方法，这个方法会监听全局滚动事件，并根据滚动范围和设置的门限调用 _detach 方法，最终是调用 OverlayRef 的 detach 方法卸载浮层内容。 例子 下面以 BottomSheet 组件为例，看一下 overlay 是如何使用的。 用户用 open 方法创建一个新的 BottomSheet 组件，这个方法会通过 _createOverlay 创建一个新的浮层，该方法的全部代码如下： /** * Creates a new overlay and places it in the correct location. * @param config The user-specified bottom sheet config. */ private _createOverlay(config: MatBottomSheetConfig): OverlayRef { const overlayConfig = new OverlayConfig({ direction: config.direction, hasBackdrop: config.hasBackdrop, disposeOnNavigation: config.closeOnNavigation, maxWidth: '100%', scrollStrategy: config.scrollStrategy || this._overlay.scrollStrategies.block(), positionStrategy: this._overlay.position().global().centerHorizontally().bottom('0') }); if (config.backdropClass) { overlayConfig.backdropClass = config.backdropClass; } return this._overlay.create(overlayConfig); } 可以看到默认使用的是 BlockScrollStrategy 和 GlobalPositionStrategy。 实际上是通过工厂类 OverlayPositionBuilder 和 ScrollStrategyOptions 创建的。 个人觉得这不是个好设计，会导致没用到的 Strategy 没法被 tree shake 掉。 然后 _attachContainer 方法就会将 BottomSheep 组件内容 attach 到 portal 上了。 const containerRef: ComponentRef = overlayRef.attach( containerPortal ) Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-04-18 11:17:03 "},"angular/工作区.html":{"url":"angular/工作区.html","title":"工作区","keywords":"","body":"工作区（多项目、多库） 参考 https://zhuanlan.zhihu.com/p/54075580 https://zhuanlan.zhihu.com/p/157205769 创建一个不包含初始化应用的 Angular 工作区 不包含 projects 配置项的 Angular 配置文件 单独ng build 或者 ng serve不会生效 ng new 工作区名 --createApplication=false 创建库项目 ng generate library 库名 --prefix=库前缀 创建应用 ng generate application 应用名 构建 ng build 应用名|库名 运行 ng serve 应用名|库名 测试 ng test 应用名|库名 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-03-30 13:26:32 "},"angular/常用命令.html":{"url":"angular/常用命令.html","title":"常用命令","keywords":"","body":"版本升级 ng update @angular/cli @angular/core --allow-dirty --force Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2021-12-14 09:47:02 "},"angular/开发问题.html":{"url":"angular/开发问题.html","title":"开发问题","keywords":"","body":"nz-zorro table 数据无法更新（使用深拷贝） 问题原因是，NG-ZORRO从 7.0 版本开始，NG-ZORRO 组件默认在 OnPush 模式下工作，OnPush 意味着只有在输入发生变化时才运行组件的变化检测，并且当输入发生变化时，它们的整个对象实例必须发生变化。如果对象实例引用不变，则不会运行变化检测。对象实例的引用没有发生变化，于是从 Angular 的视角看来，也就没有什么需要报告的变化了。如上所述，在使用 Table 组件时，如果对源数据数组进行 array.push/splice 操作，这并不会更改对象实例的引用，所以页面并不会发生更新。 // push concat 可用 this.tableList.push(res.data); this.tableList = [...this.tableList]; // 添加这行代码 // 使用 lodash 的 cloneDeep npm install lodash @types/lodash import * as _ from 'lodash'; this.tableList = _.cloneDeep(this.tableList); // html 中使用原始数据进行渲染 // 指定服务器端渲染(shiy) [nzFrontPagination]='false' Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2021-12-14 11:22:45 "},"angular/自定义指令.html":{"url":"angular/自定义指令.html","title":"自定义指令","keywords":"","body":"自定义指令传参 通过 @Input() 进行传参 模板： private 私有属性 = 值; @Input() set 属性名称(值) { this.私有属性 = 值; } 示例： import { Directive, HostListener, Input } from '@angular/core'; @Directive({ selector: '[inputNumber]', }) export class InputNumberDirective { constructor() { } @HostListener('input', ['$event.target']) inputChange(event) { let str = ''; if (this.dotNum > 0) { str = `\\\\d*(\\\\.{0,1}\\\\d{0,${this.dotNum}})?`; } else { str = `\\\\d*`; } const reg = new RegExp(str); event.value = !isNaN(value) ? value.match(reg) ? value.match(reg)[0] : '' : ''; } private dotNum = 2; // 小数位 @Input() set inputNumber(obj: { dotNum?: number }) { this.dotNum = !isNaN(obj.dotNum) && obj.dotNum >= 0 ? obj.dotNum : 2; } } Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-04-01 10:28:49 "},"angular/路由复用及自定义钩子方法.html":{"url":"angular/路由复用及自定义钩子方法.html","title":"路由复用及自定义钩子方法","keywords":"","body":"路由复用 实现 %accordion%ts%accordion% import { Component, OnInit } from '@angular/core'; import { ActivatedRoute, NavigationEnd, Router } from '@angular/router'; import { NzContextMenuService, NzDropdownMenuComponent } from 'ng-zorro-antd/dropdown'; import { Subscription } from 'rxjs'; import { filter, map } from 'rxjs/operators'; import { SettingService, TAB } from '../../services/setting.service'; import { CloseType } from './reuse-tab.interfaces'; import { ReuseTabService } from './reuse-tab.service'; @Component({ selector: 'reuse-tab', templateUrl: './reuse-tab.component.html', styleUrls: ['./reuse-tab.component.scss'] }) export class ReuseTabComponent implements OnInit { subscript: Subscription; constructor( public router: Router, public activatedRoute: ActivatedRoute, public settingService: SettingService, public reuseTabService: ReuseTabService, public nzContextMenuService: NzContextMenuService ) { this.subscript = this.router.events.pipe( filter(event => event instanceof NavigationEnd), map(() => this.activatedRoute), map(route => { while (route.firstChild) { route = route.firstChild; } return route; }), filter(route => route.outlet === 'primary') ).subscribe((res: any) => { const obj: TAB = { title: res.data.value.title, module: res.data.value.module, routerLink: res._routerState.snapshot.url.split('?')[0], queryParams: res.queryParams.value, disabled: false, close: true, delrouterurl: res._routerState.snapshot.url.replace(/\\//g, '_') + '_' + (res.routeConfig.loadChildren || res.routeConfig.component.toString().split('(')[0].split(' ')[1]) }; if (obj.routerLink === '/dashboard/home') { obj.disabled = true; obj.close = false; } if (obj.routerLink.endsWith('working/ww')) { obj.title = '成品加工单'; } else if (obj.routerLink.endsWith('working/pur')) { obj.title = '成品采购单'; } else if (obj.routerLink.endsWith('working/wp')) { obj.title = '工艺加工单'; } else if (obj.routerLink.endsWith('working/ww/detail')) { obj.title = '成品加工单详情'; } else if (obj.routerLink.endsWith('working/pur/detail')) { obj.title = '成品采购单详情'; } else if (obj.routerLink.endsWith('working/wp/detail')) { obj.title = '工艺加工单详情'; } //判断是否存在相同路由，如果不存在新增，如果存在则修改 if (this.settingService.tabList.every((item: any) => item.routerLink !== obj.routerLink)) { //判断标题是否重复; //obj['no'] = 1; //obj['newTitle'] = res.data.value.title; // if (this.settingService.tabList.some((item: any) => item.title === `${res.data.value.title}`)) { // const maxNo = Math.max(...this.settingService.tabList.filter((item: any) => item.title === `${res.data.value.title}`).map((item: any) => (item.no))); // obj['no'] = maxNo + 1; // obj['newTitle'] = `${obj.title}(${obj['no']})`; // } // 新增tab并跳转 this.settingService.setTab(obj); this.reuseTabService.selectedIndex = this.settingService.tabList.length; } else { //存在，改变路由参数和看板 模块标题 this.settingService.tabList.forEach((item: any, index: number) => { if (item.routerLink == obj.routerLink) { this.settingService.tabList[index].queryParams = obj.queryParams; this.reuseTabService.selectedIndex = index; } }); } }); } ngOnInit(): void { } toPage(item: { routerLink: string, queryParams: object }) { this.router.navigate([item.routerLink], { queryParams: item.queryParams }); } /** 菜单操作 */ doneMenu(e: any, type: CloseType) { switch (type) { case 'clear': this.reuseTabService.clear(); break; case 'close': this.reuseTabService.close(); break; case 'closeOther': this.reuseTabService.closeOther(); break; case 'closeRight': this.reuseTabService.closeRight(); break; } } /** 关闭当前标签 */ close(e: Event, item: object, index: number) { e.stopPropagation(); this.reuseTabService.reuseItem = { ...item, index } this.reuseTabService.close(); } /** 创建菜单 */ contextMenu($event: MouseEvent, menu: NzDropdownMenuComponent): void { this.nzContextMenuService.close(); if (!this.reuseTabService.reuseItem.disabled) { this.nzContextMenuService.create($event, menu); } } ngOnDestroy(): void { this.subscript.unsubscribe(); } } %/accordion% %accordion%html%accordion% 关闭 关闭右侧标签页 2)\">关闭其他标签页 1)\">关闭所有标签页 %/accordion% %accordion%scss%accordion% .main-tabset-card { border: 0; ::ng-deep .ant-tabs-tab { background: rgba(250, 250, 250, .5); .icon-close { font-size: 14px; padding: 2px; margin: 0 0 0 12px; &:hover { color: rgba(0, 0, 0, 0.85); background: rgba(0, 0, 0, .15); border-radius: 100%; } } &:hover { color: rgba(0, 0, 0, 0.85); background-color: #ffffff; span, i { color: rgba(0, 0, 0, 0.85); } } &.ant-tabs-tab-active { color: #ffffff; background-color: rgb(0, 183, 150); span, i { color: #ffffff; } .icon-close { font-size: 14px; padding: 2px; margin: 0 0 0 12px; color: #ffffff; &:hover { background: rgba(0, 0, 0, .15); border-radius: 100%; } } } } ::ng-deep .ant-tabs-nav { margin: 0; } } .context-menu { position: relative; top: 0; left: 0; width: 100%; height: 100%; } %/accordion% %accordion%directive%accordion% import { Directive, Input } from '@angular/core'; import { NzContextMenuService, NzDropdownMenuComponent } from 'ng-zorro-antd/dropdown'; import { ReuseTabService } from './reuse-tab.service'; @Directive({ selector: '[reuse-tab-context-menu]', exportAs: 'reuseTabContextMenu', host: { '(nzContextmenu)': '_onContextMenu($event)' } }) export class ReuseTabContextDirective { private reuseItem = null; @Input('reuse-tab-context-menu') set obj(obj: { item: any, index: number }) { this.reuseItem = { ...obj.item, index: obj.index }; }; constructor( public nzContextMenuService: NzContextMenuService, public reuseTabService: ReuseTabService ) { } _onContextMenu(event: MouseEvent, menu: NzDropdownMenuComponent): void { this.reuseTabService.reuseItem = this.reuseItem; event.preventDefault(); event.stopPropagation(); } } %/accordion% %accordion%interface%accordion% export type CloseType = 'clear' | 'close' | 'closeOther' | 'closeRight' | 'custom' | 'refresh' | null; export type ReuseHookTypes = 'onReuseInit' | 'onReuseDestroy'; export type ReuseHookOnReuseInitType = 'init' | 'reflash'; export interface ReuseComponentHandle { componentRef: ReuseComponentRef; } export interface ReuseComponentRef { instance: ReuseComponentInstance; } export interface ReuseComponentInstance { onReuseInit: (type: ReuseHookOnReuseInitType) => void; onReuseDestroy: () => void; } %/accordion% %accordion%service%accordion% import { Injectable, Injector } from '@angular/core'; import { ActivatedRouteSnapshot } from '@angular/router'; import { NzSafeAny } from 'ng-zorro-antd/core/types'; import { timer } from 'rxjs'; import { CommonService } from '../../services/common.service'; import { SettingService } from '../../services/setting.service'; import { ReuseComponentHandle, ReuseComponentRef, ReuseHookOnReuseInitType, ReuseHookTypes } from './reuse-tab.interfaces'; interface IRouteConfigData { keep: boolean; } interface ICachedRoute { handle: ReuseComponentHandle; data: IRouteConfigData; } @Injectable({ providedIn: 'root' }) export class ReuseTabService { selectedIndex = 0; reuseItem = null; // reuseItem 数据 public static routeCache = new Map(); private static waitDelete: string; // 当前页未进行存储时需要删除 private static currentDelete: string; // 当前页存储过时需要删除 constructor( private injector: Injector, private settingService: SettingService ) { } /** 进入路由触发，判断是否是同一路由 */ shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean { return future.routeConfig === curr.routeConfig && JSON.stringify(future.params) == JSON.stringify(curr.params); } /** 表示对所有路由允许复用 如果你有路由不想利用可以在这加一些业务逻辑判断，这里判断是否有data数据判断是否复用 */ shouldDetach(route: ActivatedRouteSnapshot): boolean { if (this.getRouteData(route)) { return true; } return false; } /** 当路由离开时会触发。按path作为key存储路由快照&组件当前实例对象 */ store(route: ActivatedRouteSnapshot, handle: NzSafeAny): void { const url = this.getRouteUrl(route); const data = this.getRouteData(route); if (ReuseTabService.waitDelete && ReuseTabService.waitDelete === url) { // 如果待删除是当前路由，且未存储过则不存储快照 ReuseTabService.waitDelete = null; return null; } else { // 如果待删除是当前路由，且存储过则不存储快照 if (ReuseTabService.currentDelete && ReuseTabService.currentDelete === url) { ReuseTabService.currentDelete = null; return null; } else { if (handle) { ReuseTabService.routeCache.set(url, { handle, data }); this.addRedirectsRecursively(route); } else { console.log('routeCache：', ReuseTabService.routeCache); console.log(url); console.log(ReuseTabService.routeCache.get(url)); // 路由复用后触发自定义初始化钩子 const componentRef = ReuseTabService.routeCache.get(url).handle?.componentRef; timer(100).subscribe(() => this.runHook('onReuseInit', componentRef)); } } } if (handle && handle.componentRef) { // 路由复用后触发自定义销毁钩子 this.runHook('onReuseDestroy', handle.componentRef); } } /** 若 path 在缓存中有的都认为允许还原路由 */ shouldAttach(route: ActivatedRouteSnapshot): boolean { const url = this.getRouteUrl(route); const handle = ReuseTabService.routeCache.has(url) ? ReuseTabService.routeCache.get(url).handle : null; const data = this.getRouteData(route); return data && ReuseTabService.routeCache.has(url) && handle != null; } /** 从缓存中获取快照，若无则返回nul */ retrieve(route: ActivatedRouteSnapshot): NzSafeAny | null { const url = this.getRouteUrl(route); const data = this.getRouteData(route); return data && ReuseTabService.routeCache.has(url) ? ReuseTabService.routeCache.get(url).handle : null; } private addRedirectsRecursively(route: ActivatedRouteSnapshot): void { const config = route.routeConfig; if (config) { if (!config.loadChildren) { const routeFirstChild = route.firstChild; const routeFirstChildUrl = routeFirstChild ? this.getRouteUrlPaths(routeFirstChild).join('/') : ''; const childConfigs = config.children; if (childConfigs) { const childConfigWithRedirect = childConfigs.find( c => c.path === '' && !!c.redirectTo ); if (childConfigWithRedirect) { childConfigWithRedirect.redirectTo = routeFirstChildUrl; } } } route.children.forEach(childRoute => { this.addRedirectsRecursively(childRoute); }); } } private getRouteUrl(route: ActivatedRouteSnapshot) { return ( route['_routerState'].url.replace(/\\//g, '_') + '_' + (route.routeConfig.loadChildren || route.routeConfig.component .toString() .split('(')[0] .split(' ')[1]) ); } private getRouteUrlPaths(route: ActivatedRouteSnapshot): string[] { return route.url.map(urlSegment => urlSegment.path); } private getRouteData(route: ActivatedRouteSnapshot): IRouteConfigData { return ( route.routeConfig && (route.routeConfig.data as IRouteConfigData) && route.routeConfig.data.keep ); } /** 用于删除路由快照*/ deleteRouteSnapshot(url: string): void { if (url[0] === '/') { url = url.substring(1); } url = url.replace('/', '_'); // console.log(\"del-url\",url); // console.log('routeCache',ReuseTabService .routeCache); if (ReuseTabService.routeCache.has(url)) { // console.log(\"del-url-OK\",url); ReuseTabService.routeCache.delete(url); ReuseTabService.currentDelete = url; } else { ReuseTabService.waitDelete = url; } } clear() { ReuseTabService.routeCache.clear(); } clearExcept(list) { if (!list || !ReuseTabService.routeCache) return; try { let waitDelete = []; ReuseTabService.routeCache.forEach((value: ICachedRoute, key) => { let handle: any = value.handle; let url = handle.route.value._routerState.snapshot.url; if (list.indexOf(url) { ReuseTabService.routeCache.delete(item); }); } catch (error) { console.log('clearExcept error', error); } } /** 执行钩子 */ runHook( method: ReuseHookTypes, componentRef: ReuseComponentRef | undefined, type: ReuseHookOnReuseInitType = 'init' ): void { if (componentRef == null || !componentRef.instance) { return; } const componentThis = componentRef.instance; const fn = componentThis[method]; if (typeof fn !== 'function') { return; } if (method === 'onReuseInit') { fn.call(componentThis, type); } else { (fn as () => void).call(componentThis); } } /** 关闭所有标签 */ closeAll() { this.settingService.tabList = [this.settingService.tabList.shift()]; localStorage.setItem('tabList', JSON.stringify(this.settingService.tabList)); this.clear(); this.injector.get(CommonService).toPage({ url: this.settingService.tabList[0].routerLink }); } /** 关闭当前标签 */ close() { if (this.reuseItem) { // 关闭 tab 同时移除菜单中隐藏的 非menu 项 const i = this.settingService.menuList.findIndex((item: any) => item.path === this.settingService.tabList[this.reuseItem.index].routerLink && item.hasOwnProperty('isExtra') && item.isExtra); if (i > -1) { this.settingService.menuList.splice(i, 1); } // 删除当前page页面路由复用 this.deleteRouteSnapshot(this.settingService.tabList[this.reuseItem.index].delrouterurl); this.settingService.tabList.splice(this.reuseItem.index, 1); localStorage.setItem('tabList', JSON.stringify(this.settingService.tabList)); if (this.selectedIndex >= this.reuseItem.index && this.settingService.tabList.length > 0) { this.selectedIndex -= 1; this.injector.get(CommonService).toPage({ url: this.settingService.tabList[this.selectedIndex].routerLink, params: this.settingService.tabList[this.selectedIndex].queryParams }); } } } /** 关闭其他标签 */ closeOther() { if (this.reuseItem) { const list = []; list.push(this.settingService.tabList[0]); const index = this.settingService.tabList.findIndex((item: any) => item.routerLink === this.reuseItem.routerLink); if (index > -1) { list.push(this.settingService.tabList[index]); } this.clearExcept([this.settingService.tabList[0].routerLink, this.reuseItem.routerLink]); this.settingService.tabList = [...list]; localStorage.setItem('tabList', JSON.stringify(this.settingService.tabList)); if (index > -1 && index !== this.selectedIndex && this.settingService.tabList.length > 0) { this.injector.get(CommonService).toPage({ url: this.settingService.tabList[this.settingService.tabList.length - 1].routerLink, params: this.settingService.tabList[this.settingService.tabList.length - 1].queryParams }); } } } /** 关闭右边标签 */ closeRight() { if (this.reuseItem) { const index = this.settingService.tabList.findIndex((item: any) => item.routerLink === this.reuseItem.routerLink); this.settingService.tabList.forEach((item: any, i: number) => { if (i > index) { this.deleteRouteSnapshot(this.settingService.tabList[i].delrouterurl); } }) this.settingService.tabList = this.settingService.tabList.splice(0, index + 1); localStorage.setItem('tabList', JSON.stringify(this.settingService.tabList)); if (index > -1 && index 0) { this.injector.get(CommonService).toPage({ url: this.settingService.tabList[this.settingService.tabList.length - 1].routerLink, params: this.settingService.tabList[this.settingService.tabList.length - 1].queryParams }); } } } } %/accordion% 路由复用自定义钩子 描述 1.自定义钩子属于组件实例方法。 2.使用了路由复用后可根据触发机制进行相应触发，无需删除路由快照，也无需进行路由跳转，只需要添加复用钩子，对需要刷新的数据进行相应处理即可。 3.还可根据需求添加其他自定义钩子函数，默认添加了onReuseInit和onReuseDestroy2个钩子方法。 具体使用方式参考以下示例： 用法 export class xxxComponent implements OnInit { ngOnInit(): void { } ... /** 路由复用后触发钩子（可局部刷新数据） */ onReuseInit(): void { // 需要刷新的数据或请求 } /** 路由复用后销毁钩子 */ onReuseDestroy(): void { } } Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-05-13 15:04:13 "},"antd/栅格.html":{"url":"antd/栅格.html","title":"栅格","keywords":"","body":"栅格布局 一行6列 col： nzXXl='4' nzXl=\"6\" nzLg=\"8\" nzMd=\"8\" nzSm=\"12\" nzXs=\"24\" form-label： [nzSpan]=\"8\" form-content： [nzSpan]=\"16\" // 开始结束日期、备注等较长表单组件 col： nzXXl='8' nzXl=\"12\" nzLg=\"16\" nzMd=\"16\" nzSm=\"12\" nzXs=\"24\" form-label： [nzSpan]=\"4\" form-content： [nzSpan]=\"20\" 一行4列 col： nzXXl='6' nzXl=\"6\" nzLg=\"8\" nzMd=\"8\" nzSm=\"12\" nzXs=\"24\" form-label： [nzSpan]=\"8\" form-content： [nzSpan]=\"16\" // 开始结束日期、备注等较长表单组件 col： nzXXl='6' nzXl=\"12\" nzLg=\"16\" nzMd=\"16\" nzSm=\"12\" nzXs=\"24\" form-label： nzXXl='8' nzXl=\"4\" nzLg=\"4\" nzMd=\"4\" nzSm=\"4\" nzXs=\"4\" form-content： nzXXl='16' nzXl=\"20\" nzLg=\"20\" nzMd=\"20\" nzSm=\"20\" nzXs=\"20\" Demo ... ... ... ... 搜索 重置 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-04-01 10:38:22 "},"antd/栅格布局组件排序及显示方案.html":{"url":"antd/栅格布局组件排序及显示方案.html","title":"栅格布局组件排序及显示方案","keywords":"","body":"栅格布局组件排序及显示方案 通过插槽原理，对指定模板进行渲染 ng-template 定义插槽名称 ng-container 指定渲染模板名称 优点： 1.可灵活定义模板插入位置，无需关注模板定义位置 2.无需写for循环一个个匹对，减少if和switch多层匹配，渲染性能更好 用法： 示例： 实战： import { ChangeDetectorRef, Component, NgZone, TemplateRef, ViewChild } from '@angular/core'; @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'] }) export class AppComponent { @ViewChild('Stylist1Temp', { static: false }) Stylist1Temp!: TemplateRef; @ViewChild('Stylist2Temp', { static: false }) Stylist2Temp!: TemplateRef; list: any[] = [ { FieldCustTitle: 'FieldCustTitle1', FieldName: 'Stylist1', Visibled: true }, { FieldCustTitle: 'FieldCustTitle2', FieldName: 'Stylist2', Visibled: true } ]; constructor( public cdr: ChangeDetectorRef ) { } ngOnInit(): void { } ngAfterViewInit(): void { this.list = this.list.map((item: any) => { let temp = null; switch (item.FieldName) { case 'Stylist1': temp = this.Stylist1Temp; break; case 'Stylist2': temp = this.Stylist2Temp; break; } return { ...item, temp } }); // 视图检测变更 this.cdr.markForCheck(); this.cdr.detectChanges(); } } 当前索引： FieldCustTitle： FieldName： 当前索引： FieldCustTitle： FieldName： Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-04-06 13:56:30 "},"antd/表格勾选.html":{"url":"antd/表格勾选.html","title":"表格勾选","keywords":"","body":"表格勾选 非分组 allChecked = false; indeterminate = false; setOfCheckedId = new Set(); /** 更新勾选状态设置 */ updateCheckedSet(index: number, checked: boolean): void { if (checked) { this.setOfCheckedId.add(index); } else { this.setOfCheckedId.delete(index); } } /** 全选 */ allCheckedChange(value: boolean) { this.tableList.forEach((item: any, index: number) => this.updateCheckedSet(index, value)); this.refreshCheckedStatus(); } /** 单选 */ singleCheckedChange(index: number, checked: boolean) { this.updateCheckedSet(index, checked); this.refreshCheckedStatus(); } /** 更新勾选状态 */ refreshCheckedStatus(): void { this.allChecked = this.tableList.every((item: any, index: number) => this.setOfCheckedId.has(index)); this.indeterminate = this.tableList.some((item: any, index: number) => this.setOfCheckedId.has(index)) && !this.allChecked; } 普通分组 /** 更新勾选状态设置 */ updateCheckedSet(index: number, checked: boolean): void { if (checked) { this.setOfCheckedId.add(index); } else { this.setOfCheckedId.delete(index); } } /** 全选 */ allCheckedChange(value: boolean) { if (this.tabIndex === 0 || this.tabIndex === 1) { this.tableList1.forEach((item: any, index: number) => this.updateCheckedSet(index, value)); } else if (this.tabIndex === 2 || this.tabIndex === 3) { this.tableList2.forEach((item: any, index: number) => { item.groupList.forEach((item2: any, index2: number) => { this.updateCheckedSet(index * 10 + index2, value); }); }); } this.refreshCheckedStatus(); } /** 单选 */ singleCheckedChange(index: number, checked: boolean) { this.updateCheckedSet(index, checked); this.refreshCheckedStatus(); } /** 更新勾选状态 */ refreshCheckedStatus(): void { this.allChecked = this.tableList.every((item: any, index: number) => this.setOfCheckedId.has(index)); this.indeterminate = this.tableList.some((item: any, index: number) => this.setOfCheckedId.has(index)) && !this.allChecked; } 含tab切换分组 /** 更新勾选状态设置 */ updateCheckedSet(index: number, checked: boolean): void { if (checked) { this.setOfCheckedId.add(index); } else { this.setOfCheckedId.delete(index); } } /** 全选 */ allCheckedChange(value: boolean) { this.tableList.forEach((item: any, index: number) => this.updateCheckedSet(index, value)); this.refreshCheckedStatus(); } /** 单选 */ singleCheckedChange(index: number, checked: boolean) { this.updateCheckedSet(index, checked); this.refreshCheckedStatus(); } /** 更新勾选状态 */ refreshCheckedStatus(): void { if (this.tabIndex === 0 || this.tabIndex === 1) { this.allChecked = this.tableList1.every((item: any, index: number) => this.setOfCheckedId.has(index)); this.indeterminate = this.tableList1.some((item: any, index: number) => this.setOfCheckedId.has(index)) && !this.allChecked; } else if (this.tabIndex === 2 || this.tabIndex === 3) { const allCheckedList = []; const indeterminateList = []; this.tableList2.forEach((item: any, index: number) => { item.groupList.forEach((item2: any, index2: number) => { allCheckedList.push(this.setOfCheckedId.has(index * 10 + index2)); indeterminateList.push(this.setOfCheckedId.has(index * 10 + index2)); }); }); this.allChecked = allCheckedList.every((item: any) => item === true); this.indeterminate = allCheckedList.some((item: any) => item === true) && !this.allChecked; } } Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-04-01 10:38:51 "},"cordova/插件.html":{"url":"cordova/插件.html","title":"插件","keywords":"","body":"app自动更新 npm install @ionic-native/device @ionic-native/app-version cordova plugin add cordova-plugin-appversion cordova-plugin-app-update Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-05-04 16:51:52 "},"git/常用命令.html":{"url":"git/常用命令.html","title":"常用命令","keywords":"","body":"全局信息配置 git config --global user.name \"\" git config --global user.email \"\" 查看全局设置 git config -l 删除本地缓存 git rm -r --cached . 查看分支 git branch -a 查看所有分支 git branch -r 查看远程分支 git branch 查看本地分支 格式化日志 git log --pretty=oneline git log --pretty=format:\"%h - %an, %ar : %s\" 以theirs方式合并指定分支 git merge --strategy-option=theirs origin/xxx 取消合并 git merge --abort 撤销合并 git reset --soft: 将分支回退到指定提交，工作区维持现状不变,暂存区会在现有基础上增加该commit之后的提交。 git reset --mixed: （默认操作）将分支回退到指定提交，暂存区也被同步为该指定提交，工作区保持不变。 git reset --hard: 将分支回退到指定分支，暂存区和工作区都会被同步为该指定的提交。 拉取远程指定分支 git clone -b 远程分支名 远程地址 push 远程指定分支（未创建） git push --set-upstream origin xxx 强推并覆盖远程分支（提交记录会被清掉） git push origin xxx --force 拉取一条本地不存在的分支，并关联起来 git checkout -b 本地分支名 origin/远程分支名 删除本地分支 git branch -D xxx 删除远程分支 1.查看远程分支 git branch -a 2.切换到查看到的远程分支（remotes/origin/HEAD -> origin/master） git checkout master 3.执行删除 git push origin --delete 远程分支 回滚指定版本并覆盖远程 git reset --hard xxx git push --force // 强制覆盖到远程，会将日志重置到指定版本 强制拉取覆盖本地： git fetch --all git reset --hard origin/master git pull 分支覆盖：（将 dev 覆盖到 master 分支） git checkout master git reset --hard origin/dev git push -f 添加钩子 git remote add origin [git地址] git push -u origin master git 切换到远程分支（remote后需要关联到指定分支操作） git branch xxx git checkout xxx 切换到第二个分支 git branch --set-upstream-to origin/xxx 关联到第二个分支 git log --graph --decorate --oneline --simplify-by-decoration --all 显示分支图，找到远程分支的开始节点 git reset --hard *** 切换到远程分支 xxx 的工作目录，这时候就可以正常使用了 将其他分支所有日志与当前分支合并 参考： https://www.cnblogs.com/coderxx/p/11544550.html git checkout dev git merge dev_add --no-ff Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2021-12-23 15:45:42 "},"git/里程碑.html":{"url":"git/里程碑.html","title":"里程碑","keywords":"","body":"里程碑(tags) 描述 里程碑就是Git中的tag，tag是与某个具体的提交（commit）关联的，使用里程碑的好处在于可以直观的看到版本的演变历史，而不是简单生硬的commit id。里程碑的命令是git tag，可以创建、删除和查看里程碑。 查看标签 git ls-remote --tags origin # 查看远程所有标签 git tag -l # 查看本地所有标签 创建标签 # 方式一: 默认 `HEAD` 指向的版本 git tag 标签名 # 方式二: 指定 `commit_id` 表示的版本 git tag 标签名 [] # 方式三: 指定 `commit_id` 表示的版本,同时创建标签说明信息 git tag -a 标签名 -m 提交信息 [] 删除标签 远程： git push origin :refs/tags/标签名 # 推送并删除远程标签，只能单个删除 git push origin -d tag 标签名 # git v1.7.0 之后支持该写法，可同时推送并删除多个tag 本地： git tag -d 标签名 推送标签 git push origin --tags # 推送所有标签 git push origin 标签名 # 推送单个标签 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-03-30 13:26:32 "},"ionic/ionic.html":{"url":"ionic/ionic.html","title":"ionic","keywords":"","body":"ionic（移动端UI） 官网地址：https://ionicframework.com/ 兼容 ios|android(md) 系统 安装 npm install -g @ionic/cli Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-05-04 16:50:54 "},"javascript/DOM对象属性、鼠标事件.html":{"url":"javascript/DOM对象属性、鼠标事件.html","title":"DOM对象属性、鼠标事件","keywords":"","body":"DOM 对象属性 clientWidth、clientHeight clientWidth：width(样式中设置的) + 左右padding - 垂直滚动条宽度 clientHeight：height(样式中设置的) + 上下padding - 水平滚动条宽度 offsetWidth、offsetHeight 只与当前元素有关，与其他元素无关 offsetWidth：width(样式中设置的) + 左右padding + 左右border offsetHeight：height(样式中设置的) + 上下padding + 上下border offsetParent offsetParent属性返回一个对象的引用，这个对象是距离调用offsetParent的元素最近的（在包含层次中最靠近的），并且是已进行过CSS定位的容器元素。 如果这个容器元素未进行CSS定位, 则offsetParent属性的取值为根元素的引用 1、如果当前元素的父级元素没有进行CSS定位（position为absolute或relative），offsetParent为body。 2、如果当前元素的父级元素中有CSS定位（position为absolute或relative），offsetParent取最近的那个父级元素。 offsetTop、offsetLeft 与 offsetWidth 和 offsetHeight不同的是，它们受到 offsetParent 的影响 offsetLeft：(offsetParent的padding-left) + (中间元素的offsetWidth) + (当前元素的margin-left) offsetTop：(offsetParent的padding-top) + (中间元素的offsetHeight) + (当前元素的margin-top) scrollWidth、scrollHeight scrollWidth 可视区域宽度 + 被隐藏区域宽度 scrollHeight 可视区域高度 + 被隐藏区域高度 scrollTop、scrollLeft scrollTop：对象的最顶部到对象在当前窗口显示的范围内的顶边的距离，即在出现了纵向滚动条的情况下，滚动条拉动的距离 scrollLeft：对象的最左边到对象在当前窗口显示的范围内的左边的距离，即在出现了横向滚动条的情况下，滚动条拉动的距离 鼠标事件 onclick 鼠标点击事件 box.onclick = function(e){ console.log(e) } onmousedown 鼠标按下事件 box.onmousedown = function(e){ console.log(e) } onmouseup 鼠标松开事件 box.onmouseup = function(e){ console.log(e) } onmousemove 鼠标移动事件 box.onmousemove = function(e){ console.log(e) } onmouseover 鼠标经过事件 box.onmouseover = function(e){ console.log(e) } onmouseout 鼠标划出事件 box.onmouseout = function(e){ console.log(e) } 一、clientX、clientY 点击位置距离当前body可视区域的x，y坐标 二、pageX、pageY 对于整个页面来说，包括了被卷去的body部分的长度 三、screenX、screenY 点击位置距离当前电脑屏幕的x，y坐标 四、offsetX、offsetY 相对于带有定位的父盒子的x，y坐标 五、x、y 和screenX、screenY一样 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-03-30 13:26:32 "},"javascript/前端实用方法.html":{"url":"javascript/前端实用方法.html","title":"前端实用方法","keywords":"","body":"获取文件的base64 return new Promise((resolve, reject) => { const render = new FileReader(); reader.readAsDataURL(file); reader.onload = () => resolve(reader.result); reader.onerror = error => reject(error); }) 生成guid function guid() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) { const r = Math.random() * 16 | 0; const v = c == 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); } Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2021-11-29 17:53:26 "},"js特效/特效.html":{"url":"js特效/特效.html","title":"特效","keywords":"","body":"粒子特效 https://github.com/VincentGarreau/particles.js 鼠标点击烟花效果 雪花特效 音乐播放器 离开页面改变title var time; var normar_title=document.title; document.addEventListener('visibilitychange', function () { if (document.visibilityState == 'hidden') { clearTimeout(time); document.title = '又是分手的一天ε=ε=ε=┏(゜ロ゜;)┛'; } else { document.title = '你终于回来了(。・∀・)ノ'; time=setTimeout(function(){ document.title = normar_title; }, 3000); } }); Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-01-04 11:22:10 "},"mysql/mysql学习.html":{"url":"mysql/mysql学习.html","title":"mysql学习","keywords":"","body":"MySQL学习 数据库存储数据的特点 1.将数据放到表中，表再放到库中 2.一个数据库中可以有多个表，每个表都有一个名字，用来标识自己，表明具有唯一性 3.表具有一些特性，这些特性定义了数据在表中如何存储，类似 java 中 ”类“ 的设计 4.表由列组成，我们也成为字段。所有表都由一个或多个列组成的，每一列类似 java 的 ”属性“ 5.表中的数据是按行存储的，每一行类似于 java 的 ”对象“ 下载 https://dev.mysql.com/downloads/mysql 社区版（免费） 企业版（收费） MySQL 8.0 报错解决 参考：https://stackoverflow.com/questions/50093144/mysql-8-0-client-does-not-support-authentication-protocol-requested-by-server express mysql 登录 mysql 并分别执行以下代码： alter user 'root'@'localhost' identified with mysql_native_password by '密码'; flush privileges; 启动和停止 mysql 服务 1.右击计算机 - 管理 - 服务和应用程序 - 服务 2.打开 cmd（管理员身份） 开启：net start [mysql名称] 停止：net stop [mysql名称] 数据库连接和退出 1.连接（cmd方式） -h：主机 -P（必须大写）：端口 -u：用户名 -p 密码 方式一：mysql -h localhost -P 3306 -u root -p 密码 方式二（连本机，默认端口3306）： mysql -u root -p 密码 2.退出 方式一：exit 方式二：按 2 次 ctrl + c MySQL的常见命令 1.查看当前所有的数据库 show databases; 2.打开指定的库 use 库名 3.查看当前库的所有表 show tables; 4.查看其他库的所有表 show tables form 库名； 5.创建表 create table 表名{ 列名 列类型, 列名 列类型, ... }; 6.查看表结构 desc 表名; 7.查看服务器的版本 方式一：登录到mysql服务端 select version(); 方式二：没有登录到mysql服务端 mysql --version 或 mysql --V MySQL的语法规范 1.不区分大小写，建议关键字大写，表名、列名小写 2.每条命令最好用分号结尾 3.每条命令根据需要，可进行缩进或换行 4.注释 单行：#注释文字 单行：-- 注释文字 多行：/* 注释文字 */ DQL语言（数据查询语言） 基础查询 条件查询 排序查询 常见函数 分组函数 分组查询 链接查询 子查询 分页查询 union联合查询 DML语言（数据操作语言） 插入语句 修改语句 删除语句 DDL语言（数据定义语言） 库和表的管理 常见数据类型介绍 常见约束 TCL语言（事务控制语言） 事务和事务处理 SELECT 语法：SELECT 查询列表 FROM 表名; 特点： 1、查询列表可以是：表中的字段、常量值、表达式、函数 2、查询的结果是一个虚拟表格 起别名 1.SELECT 字段名 AS 别名 FROM 表名; 2.使用空格：SELECT 字段名 别名 FROM 表名; 去重(DISTINCT) SELECT DISTINCT 字段名 FROM 表名; 连接(CONCAT) SELECT CONCAT(str1,str2,...) AS 别名 FROM 表名; 判断(IFNULL) SELECT IFNULL(expr1,expr2) AS 别名 FROM 表名; 查看表结构 DESC 表名; 条件查询 语法： SELECT 查询列表 FROM 表名 WHERE 筛选条件; 分类： 一、按条件表达式筛选 > >= 查询第几个字符，使用 \"_\" 通配符 SELECT 查询列表 FROM 表名 WHERE 列名 LIKE '__n_l%'; 查询含有 \"_\" 字符，需转义 SELECT 查询列表 FROM 表名 WHERE 列名 LIKE '_\\_%'; 或者 SELECT 查询列表 FROM 表名 WHERE 列名 LIKE '_$_%' ESCAPE '$'; IN SELECT 查询列表 FROM 表名 WHERE 列名 IN (值1,值2,...); ISNULL、IS NOT NULL SELECT 查询列表 FROM 表名 WHERE ISNULL(列名); SELECT 查询列表 FROM 表名 WHERE 列名 IS NOT NULL; 安全等于 SELECT 列名 FROM 表名 WHERE 列名 值; 排序 语法: SELECT 查询列表 FROM 表名 [WHERE 筛选条件] ORDER BY 排序列表 [ASC|DESC], 排序列表 [ASC|DESC], ...; 特点： 1.ASC 代表升序，DESC 代表降序。不写默认升序。 2.ORDER BY 子句支持单个字段、多个字段、表达式、函数、别名。 3.ORDER BY 子句以一般是放在查询语句的最后，limit 子句除外。 函数 概念：将一组逻辑语句封装在方法体中，对外暴露方法名。 好处： 1.隐藏了实现细节 2.提高代码的重用性 调用：SELECT 函数名(参数列表) [FROM 表名]; 分类： 1.普通函数 字符函数 数学函数 日期函数 其他函数 流程控制函数 2.分组函数 功能：做统计使用，又称为统计函数、聚合函数、组函数 查看字符集： SHOW VARIABLES LIKE '%char%'; 字符函数 -- LENGTH 长度 SELECT LENGTH(str); -- UPPER 转大写 SELECT UPPER(str); -- LOWER 转小写 SELECT LOWER(str); -- CONCAT 拼接 SELECT CONCAT(str,str,...); -- SUBSTR 字符串截取 SELECT SUBSTR(str,start,[end]); -- INSTR 获取字符所在位置 SELECT INSTR(str,str); -- TRIM 去左右字符 SELECT TRIM(str); -- LPAD 左填充 SELECT LPAD(str,填充个数,填充字符); -- RPAD 右填充 SELECT RPAD(str,填充个数,填充字符); -- EPLACE 替换 SELECT EPLACE(str,需要替换的字符,替换后的字符); 数学函数 -- ROUND 四舍五入 SELECT ROUND(数值); SELECT ROUND(数值,保留位数); -- CEIL 向上取整 SELECT CEIL(数值); -- FLOOR 向下取整 SELECT FLOOR(数值); -- TRUNCATE 截断 SELECT TRUNCATE(小数,截断位数); -- MOD 取余 SELECT MOD(被除数,除数); 日期函数 %Y：年（4位） %y：年（2位） %m：月（2位）(01,02...11,12) %c：月（1位）(1,2...11,12) %d：日（2位）(01,02...) %H：小时（24小时制） %h：小时（12小时制） %i：分钟(01,02...) %s：秒(01,02...) -- 返回当前系统日期+时间 SELECT NOW(); -- CURDATE 返回当前系统日期，不包含时间 SELECT CURDATE(); -- CURTIME 返回当前时间，不包含日期 SELECT CURTIME(); -- 获取指定的部分，年月日时分秒 SELECT YEAR(NOW()) 年; SELECT YEAR('1994-9-28') 年; SELECT MONTH(NOW()) 月; -- 英文名 SELECT MONTHNAME(NOW()) 月; -- STR_TO_DATE 将日期格式的字符转换成指定的日期格式 YYYY-MM-DD SELECT STR_TO_DATE('1994-9-28','%Y-%c-%d'); SELECT STR_TO_DATE('9-28 1994','%c-%d %Y'); -- DATE_FORMAT 将日期转换成字符串 SELECT DATE_FORMAT(NOW(),'%Y年%m月%d日'); 其他函数 SELECT VERSION(); // 查看mysql版本 SELECT DATABASE(); // 查看当前数据库 SELECT USER(); // 查看当前库的用户 流程控制函数 -- IF 函数 SELECT IF(10>5,'大','小'); -- CASE 函数 /* 用法一：(类同 switch) case 要判断的字段或表达式 when 常量1 then 要显示的值1或语句1; when 常量2 then 要显示的值2或语句2; ... else 要显示的值n或语句n; end 用法二：（类同 if） case when 条件1 then 要显示的值1或语句1; when 条件2 then 要显示的值2或语句2; ... else 要显示的值n或语句n; end */ SELECT salary,department_id, CASE department_id WHEN 30 THEN salary*1.1 WHEN 40 THEN salary*1.2 WHEN 50 THEN salary*1.3 END AS 新工资 FROM employees; SELECT salary, CASE WHEN salary>20000 THEN 'A' WHEN salary>15000 THEN 'B' WHEN salary>10000 THEN 'C' ELSE 'D' END AS 工资等级 FROM employees; 分组函数 /* 功能：用作统计使用，又称为聚合函数或统计函数或组函数 分类： sum 求和、avg 平均值、max 最大值、min 最小值、count 计算个数 特点： 1、sum、avg 一般用于处理数值型 max、min、count 可以处理任何类型 2、以上文组函数都忽略 null 值 3、可以和 DISTINCT 搭配实现去重 4、count 函数单独介绍 一般使用count(*)用作统计行数 5、和分组函数一同查询的字段要求是 group by 后的字段 */ SELECT SUM(字段名) FROM 表名; SELECT AVG(字段名) FROM 表名; SELECT MIN(字段名) FROM 表名; SELECT MAX(字段名) FROM 表名; SELECT COUNT(字段名) FROM 表名; # 配合 DISTINCT 实现去重 SELECT SUM(DISTINCT 字段名) FROM 表名; SELECT COUNT(DISTINCT 字段名) FROM 表名; # count 函数的详细介绍 # 当前行任意一个属性部位null，则统计当前行，以下效果一样 SELECT COUNT(*) FROM 表名; SELECT COUNT(1) FROM 表名; SELECT COUNT(2) FROM 表名; # 效率 MYISAM 存储引擎下，COUNT(*) 的效率高 INNODB 存储引擎下，COUNT(*) 和 COUNT(1) 的效果差不多，比 COUNT(字段) 要高一些 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-05-13 15:06:17 "},"node包管理器/npm.html":{"url":"node包管理器/npm.html","title":"npm","keywords":"","body":"npm（Node Page Manage） 查看全局安装的依赖 npm list -g --depth 0 镜像源（查看/设置） # 查看 npm get registry # 设置 npm set registry http://registry.npmjs.org # npm源 npm set registry http://registry.npm.taobao.org # 淘宝源 安装pkg npm install (with no args, in package dir) npm install [/] npm install [/]@ npm install [/]@ npm install [/]@ npm install @npm: npm install npm install npm install npm install npm install / aliases: i, isntall, add common options: [--save-prod|--save-dev|--save-optional] [--save-exact] [--no-save] 卸载 npm uninstall [/][@]... [--save-prod|--save-dev|--save-optional] [--no-save] Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-05-04 16:16:34 "},"node包管理器/nvm.html":{"url":"node包管理器/nvm.html","title":"nvm","keywords":"","body":"nvm（Node Version Manage） github releases 地址：https://github.com/coreybutler/nvm-windows/releases 注：不同版本对系统安装有影响，例如v1.1.7之后安装后会报错，提示安装路径不能含有空格等。 查看所有版本 nvm ls 添加/卸载指定版本 nvm install nvm uninstall 使用（切换）版本 nvm use [version] 解决镜像下载过慢问题 参考：https://blog.csdn.net/qq_32754575/article/details/102412473 where nvm 找到nvm安装路径 找到settings.txt文件, 并添加以下代码 node_mirror: https://npm.taobao.org/mirrors/node/ npm_mirror: https://npm.taobao.org/mirrors/npm/ Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-05-04 16:18:13 "},"node包管理器/pnpm.html":{"url":"node包管理器/pnpm.html","title":"pnpm","keywords":"","body":"pnpm 官网地址：https://www.pnpm.cn/ 节省磁盘空间并提升安装速度 快速 比传统方案安装包的速度快了两倍，以下是官方给出的benchmarks，在多种常见情况下，执行install的速度比较。 安装 npm install -g pnpm 注：全局安装的包，在同级包管理器下是共享访问的。 升级 一旦安装完 pnpm 之后，就无需使用其它软件包管理器来更新 pnpm 了。 你可以让 pnpm 自己来更新自己，如下所示： pnpm add -g pnpm 兼容性 Node.js pnpm 4 pnpm 5 pnpm 6 pnpm 7 Node.js 10 ✔️ ✔️ ❌ ❌ Node.js 12 ✔️ ✔️ ✔️ ❌ Node.js 14 ✔️ ✔️ ✔️ ✔️ Node.js 16 ?️ ?️ ✔️ ✔️ Node.js 18 ?️ ?️ ✔️ ✔️ Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-05-04 18:20:57 "},"typescript/进阶及高级用法.html":{"url":"typescript/进阶及高级用法.html","title":"进阶及高级用法","keywords":"","body":"参考：https://zhuanlan.zhihu.com/p/503812618 TS 是一种静态类型检测，并不会执行你的代码 泛型（type） 把明确类型的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型，简单点来讲我们可以将泛型理解成为把类型当作参数一样去传递 接口泛型位置不同，效果也会不同。 泛型约束 所谓泛型约束，通俗点来讲就是约束泛型需要满足的格式。 解决泛型约束方法，使用extends 关键字 。 extends extends 关键字在声明泛型时约束泛型需要满足的条件 keyof 运算符 运算符采用keyof对象类型并生成其键的字符串或数字文字联合 is（关键字） is 关键字其实更多用在函数的返回值上，用来表示对于函数返回值的类型保护 | （条件类型或分发） type isString = T extends string ? true : false; // a 的类型为 true let a: isString // b 的类型为 false let b: isString; 循环 interface IProps { name: string; age: number; highSchool: string; university: string; } // IPropsKey类型为 // type IPropsKey = { // name: boolean; // age: boolean; // highSchool: boolean; // university: boolean; // } type IPropsKey = { [K in keyof IProps]: boolean }; Exclude（类型排除） type TypeA = string | number | boolean | symbol; // ExcludeSymbolType 类型为 string | number | boolean，排除了symbol类型 type ExcludeSymbolType = Exclude; 类型兼容性（多的可以赋给少的） 分发的参数类型多的可赋给少的，但方法只能是参数类型少的赋值给多的 infer（待推断类型） infer 代表待推断类型，它的必须和 extends 条件约束类型一起使用 type Flatten = Type extends Array ? Item : Type; 逆变（少的可以赋给多的，与类型兼容性相反） 函数的参数的方式被称为逆变。 let fn1!: (a: string, b: number) => void; let fn2!: (a: string, b: number, c: boolean) => void; fn1 = fn2; // TS Error: 不能将fn2的类型赋值给fn1 let fn1!: (a: string, b: number) => void; let fn2!: (a: string, b: number, c: boolean) => void; fn2 = fn1; // 正确，被允许 unknown & any（任意类型） 对于以后并不确定类型的变量尽量使用更多的 unknown 来代替 any 让你的代码更加强壮 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-04-28 15:46:00 "},"vue/devtools.html":{"url":"vue/devtools.html","title":"devtools","keywords":"","body":"Devtools 安装及使用 克隆官方项目 git clone https://github.com/vuejs/devtools.git 安装依赖 # 官方使用的是 yarn，所以使用 yarn 进行安装，否则会报错 yarn install 打包 yarn run build 使用 chrome 更多工具 -> 扩展程序 -> 启用开发者模式 -> 加载已解压的扩展程序，把项目的 packages/shell-chrome 文件夹导入即可。 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-05-04 14:07:15 "},"vue/vue3.0.html":{"url":"vue/vue3.0.html","title":"vue3","keywords":"","body":"Vue 3.0 官网：https://v3.cn.vuejs.org/guide/migration/introduction.html 冷启动/热启动 冷启动 当启动应用时，后台没有该应用的进程，这时系统会重新创建一个新的进程分配给该应用，这个启动方式就是冷启动。 热启动 当启动应用时，后台已有该应用的进程（例：按home键回到桌面，但是该应用的进程是依然会保留在后台，可进入任务列表查看），所以在已有进程的情况下，这种启动会从已有的进程中来启动应用，这个方式叫热启动。 vite 介绍 参考地址：https://baijiahao.baidu.com/s?id=1684779666333900793&wfr=spider&for=pc Vite是Vue的作者尤雨溪开发的Web开发构建工具，它是一个基于浏览器原生ES模块导入的开发服务器，在开发环境下，利用浏览器去解析import，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随启随用。同时不仅对Vue文件提供了支持，还支持热更新，而且热更新的速度不会随着模块增多而变慢。在生产环境下使用Rollup打包。 vite 特点 1.快速的冷启动 2.即时热模块更新（HMR，Hot Module Replacement） 3.真正按需编译 Vite是在推出Vue 3的时候开发的，目前仅支持Vue 3.x，这意味着与Vue 3不兼容的库也不能与Vite一起使用。 安装/起步 通过脚手架 Vite npm init @vitejs/app hello-vue3 # OR yarn create @vitejs/app hello-vue3 通过脚手架 vue-cli npm install -g @vue/cli # 或 yarn global add @vue/cli vue create hello-vue3 新特性 组合式 API Teleport 片段 触发组件选项 来自 @vue/runtime-core 的 createRenderer API 创建自定义渲染器 单文件组件组合式 API 语法糖 () 单文件组件状态驱动的 CSS 变量 () 单文件组件 `` 现在可以包含全局规则或只针对插槽内容的规则 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2021-11-18 15:05:29 "},"vue/vue3.0开发事项.html":{"url":"vue/vue3.0开发事项.html","title":"vue3","keywords":"","body":"找不到模块“@/xxx”或其相应的类型声明 https://www.cnblogs.com/JasmineHan/p/13673560.html Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2021-11-18 15:06:00 "},"vue/vue细节处理.html":{"url":"vue/vue细节处理.html","title":"vue细节处理","keywords":"","body":"Vue细节处理 语法糖 v-bind: : // 绑定属性，如果属性有大写，需使用kebab-case方式绑定 v-on: @ // 绑定事件 v-slot: # // 指定插槽名称，默认为#default，必须带参 组件名大小写（2种） kebab-case(短横线隔开式) PascalCase(驼峰式) v-model基本原理 等价于： 将原生事件绑定到组件 .native可直接监听原生事件 eg: 注意：在app、小程序端和h5端表现不一致，h5端获取到的是浏览器原生事件 子组件数据同步更新到父组件 当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定。 .sync 它会被扩展为一个自动更新父组件属性的 v-on 监听器 eg： 插槽（匿名插槽、具名插槽、作用于插槽） 子组件 template 中没有包含一个 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃（即：子组件内容会被丢弃） 一个不带 name 的 出口会带有隐含的名字 “default” Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-04-28 16:56:31 "},"分享/ng-alain.html":{"url":"分享/ng-alain.html","title":"ng-alain","keywords":"","body":"NG-ALAIN 官网地址：https://ng-alain.com/zh 介绍 环境搭建、安装、运行 体系架构 核心模块描述 项目结构 常用命令 基本使用 介绍 NG-ALAIN 是一个企业级中后台前端/设计解决方案脚手架，秉承 Ant Design 的设计价值观，目标是希望在Angular上面开发企业后台更简单、更快速。随着『设计者』的不断反馈，将持续迭代，逐步沉淀和总结出更多设计模式和相应的代码实现，阐述中后台产品模板/组件/业务场景的最佳实践。 环境搭建、安装、运行 安装并使用 node LTS 版 全局安装 ng 脚手架 npm install -g @angular/cli 创建 ng 项目 并 安装 ng-alain 脚手架 ng new my-project --style less --routing ng add ng-alain 运行 ng serve 或 npm run start 版本升级 https://ng-alain.com/docs/upgrade-v11/zh 体系架构 类库 描述 @delon/theme 主题系统除了包含 NG-ALAIN 基础框架及所需样式（包含CSS工具集，一套类似Bootstrap）以外，还包含一些通用的数据渲染（Pipe）、服务工具类（页面标题、滚动条等）的集合，这些是日常必不可少的一些组成 @delon/abc 脚手架内提供了一套默认业务组件，这些组件抽象了控制台业务中的一些常见区块。我们将持续维护和迭代这些组件，为中后台业务提供比 Ant Design 基础组件更高级别的抽象 @delon/chart 基于 G2 的基础上二次封装，提供了业务中常用的图表套件，可以单独使用，也可以组合起来实现复杂的展示效果 @delon/form 基于 JSON Schema 标准的动态构建表单 @delon/auth 用户认证模块，用于解决如何获取、存取、使用这三个步骤的用户认证环节 @delon/acl 访问控制列表，是一种非常简单的基于角色权限控制，甚至达到控制某个按钮显隐的粒度 @delon/cache 将字典、城市数据等缓存至内存或持久化当中，有效减少 Http 请求 @delon/mock Mock 会拦截 Angular Http 请求并返回测试数据，当后端未完成接口时 Mock 技术是一项不会影响前端开发进度的工具 @delon/util 包含数组、延迟、字符串、日期、校验等常见工具集 @delon/testing 常用测试套件 CLI Schematics 快速生成统一的模板、可插拔的插件等 项目结构 ├── _mock # Mock 数据规则目录 ├── angular.json # Angular 项目配置文件 ├── src │ ├── app │ │ ├── core # 核心模块 │ │ │ ├── i18n │ │ │ ├── net │ │ │ │ └── default.interceptor.ts # 默认HTTP拦截器 │ │ │ ├── services │ │ │ │ └── startup.service.ts # 初始化项目配置 │ │ │ └── core.module.ts # 核心模块文件 │ │ ├── layout # 通用布局 │ │ ├── routes │ │ │ ├── ** # 业务目录 │ │ │ ├── routes.module.ts # 业务路由模块 │ │ │ └── routes-routing.module.ts # 业务路由注册口 │ │ ├── shared # 共享模块 │ │ │ ├── shared-delon.module.ts # @Delon/* 次级共享模块导入 │ │ │ ├── shared-zorro.module.ts # NG-ZORRO 次级共享模块导入 │ │ │ └── shared.module.ts # 共享模块文件 │ │ ├── app.component.ts # 根组件 │ │ └── app.module.ts # 根模块 │ │ └── global-config.module.ts # @delon & ng-zorro 全局配置项 │ ├── assets # 本地静态资源 │ ├── environments # 环境变量配置 │ ├── styles # 样式目录 └── └── style.less # 样式引导入口 补充 图表：Antv(G2 G6 F2 L7等) 项目脚手架跟随 Angular 及 NG-ZORRO 同步更新 常用指令 ng g ng-alain:module 模块名 ng g ng-alain:list 列表名 -m 模块名 ng g ng-alain:view 详情名 -m 模块名 -t 文件夹名称 补充 https://ng-alain.com/cli/plugin/zh 相关配置可到 angular.json 中配置 基本使用 @delon main.ts -> appModule -> 加载所有模块、组件、服务、指令等 appModule：通过 StartupService 服务，启动项目，Promise.resolve() 异步渲染视图，设置/存储处理项目基本信息 MenuService： 菜单服务，处理菜单列表 titleService：项目标题服务 ACLService：权限服务 ITokenService：token服务，token处理（设置） SettingsService：系统设置服务，含项目登录信息、项目密钥信息等 _HttpClient：alain 封装的网络请求服务，含 token 校验等 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2021-11-18 14:09:00 "},"分享/webcomponent及angular的变化检测机制.html":{"url":"分享/webcomponent及angular的变化检测机制.html","title":"webcomponent及angular的变化检测机制","keywords":"","body":"webcomponent 、angular的变化检测机制 webcomponent（网页组件） 参考文档： https://developer.mozilla.org/en-US/docs/Web/Web_Components Web Components 入门实例教程 - 阮一峰的网络日志 (ruanyifeng.com) 1.概念 Web Components 是一套不同的技术，允许您创建可重用的自定义元素——它们的功能被封装在你的代码的其余部分之外——并在你的 Web 应用程序中使用它们。 Web Components旨在解决这些问题 — 它由三项主要技术组成，它们可以一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。 Custom elements（自定义元素）：一组JavaScript API，允许您定义custom elements及其行为，然后可以在您的用户界面中按照需要使用它们。 Shadow DOM（影子DOM）：一组JavaScript API，用于将封装的“影子”DOM树附加到元素（与主文档DOM分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。 HTML templates（HTML模板）： 和 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用 实现web component的基本方法通常如下所示： 创建一个类或函数来指定web组件的功能，如果使用类，请使用 ECMAScript 2015 的类语法(参阅类获取更多信息)。 使用 CustomElementRegistry.define() 方法注册您的新自定义元素 ，并向其传递要定义的元素名称、指定元素功能的类、以及可选的其所继承自的元素。 如果需要的话，使用Element.attachShadow() 方法将一个shadow DOM附加到自定义元素上。使用通常的DOM方法向shadow DOM中添加子元素、事件监听器等等。 如果需要的话，使用 定义一个HTML模板。再次使用常规DOM方法克隆模板并将其附加到您的shadow DOM中。 在页面任何您喜欢的位置使用自定义元素，就像使用常规HTML元素那样。 2.元素注册器 CustomElementRegistry：CustomElementRegistry接口提供注册自定义元素和查询已注册元素的方法。要获取它的实例，请使用 window.customElements属性。 3.语法 customElements.define(name, constructor, options); 4.生命周期回调 定义在自定义元素的类定义中的特殊回调函数，影响其行为： connectedCallback: 当自定义元素第一次被连接到文档DOM时被调用。 disconnectedCallback: 当自定义元素与文档DOM断开连接时被调用。 adoptedCallback: 当自定义元素被移动到新文档时被调用。 attributeChangedCallback: 当自定义元素的一个属性被增加、移除或更改时被调用。 5.Shadow DOM Web components 的一个重要属性是封装——可以将标记结构、样式和行为隐藏起来，并与页面上的其他代码相隔离，保证不同的部分不会混在一起，可使代码更加干净、整洁。其中，Shadow DOM 接口是关键所在，它可以将一个隐藏的、独立的 DOM 附加到一个元素上。 ShadowRoot 表示shadow DOM子树的根节点。 Element extensions 与shadow DOM有关的Element 接口的扩展: Element.attachShadow() 方法将shadow DOM树附加给特定元素。 Element.shadowRoot 属性返回附加给特定元素的shadow root，或者 null 如果没有shadow root被附加。 Node 相关拓展 与 shadow DOM 相关的 Node 接口的拓展: Node.getRootNode() 方法返回上下文对象的根，可以选择包含shadow root，如果可用的话。 Node.isConnected 属性返回一个布尔值表示节点是否连接（直接或间接）到上下文对象。例如，在普通DOM的情况下为Document 对象，或者在shadow DOM的情况下为 ShadowRoot Event 拓展 与shadow DOM相关的Event 接口的扩展： Event.composed: 返回 Boolean 它表明事件是否会通过shadow DOM边界传播到标准DOM。 返回事件的路径（侦听器将被调用的对象）。如果shadow root是使用ShadowRoot.mode为closed创建的，则不包括shadow树中的节点。 6.HTML templates 包含一个HTML片段，不会在文档初始化时渲染。但是可以在运行时使用JavaScript显示。主要用作自定义元素结构的基础。关联的DOM接口是HTMLTemplateElement。 HTML 内容模板（）元素是一种用于保存客户端内容机制，该内容在加载页面时不会呈现，但随后可以 (原文为 may be) 在运行时使用 JavaScript 实例化。 web component中的一个占位符，你可以填充自己的标记，这样你就可以创建单独的DOM树并将它们呈现在一起。关联的DOM接口是HTMLSlotElement。 HTML 元素 ，作为 Web Components 技术套件的一部分，是Web 组件内的一个占位符。该占位符可以在后期使用自己的标记语言填充，这样您就可以创建单独的 DOM 树，并将它与其它的组件组合在一起。 7.示例 class ElementA extends HTMLElement { constructor() { // 必须首先调用 super 方法 super(); // 元素的功能代码写在这里 // ... } /** 生命周期 */ connectedCallback() { // 自定义元素首次插入文档dom时调用 // 相较于constructor只会执行一次，这个生命周期每次将节点连接到dom时都会调用 // 可能会执行多次(比如同一个自定义元素remove, append多次) } disconnectedCallback() { // 自定义元素从文档中删除时，调用 } adoptedCallback() { // 自定义元素移动到新的文档 // 比如使用 adoptNode 方法在多iframe下移动元素 } attributeChangedCallback(name, oldVal, newVal) { // 属性变更时调用：三个参数对应属性名，旧值，新值 } } customElements.define(name, ElementA); 8.实战 class CodeFront extends HTMLElement { constructor() { super(); const shadow = this.attachShadow({ mode: 'open' }); const span = document.createElement('span'); span.setAttribute('class', 'code-front-text'); setTimeout(() => { span.textContent = this.getAttribute('text') || '默认内容'; }, 10); const style = document.createElement('style'); style.textContent = ` .code-front-text { font-family: 微软雅黑; font-weight: 400; font-size: 80px; margin: 0 auto; color: rgba(255, 255, 255, 0.1); background: #ed8080; background: linear-gradient(to right, #ed8080 0%, #2a77d6 16%, #5eb524 32%, #eacd25 48%, #ed8080 64%, #2a77d6 80%, #5eb524 100%); filter: progid: DXImageTransform.Microsoft.gradient(startColorstr='#ed8080', endColorstr='#5eb524', GradientType=1); background-size: 300% 300%; -webkit-background-clip: text; background-clip: text; animation: shimmer infinite 3s linear; -webkit-animation: shimmer infinite 3s linear; background-repeat: no-repeat; background-position: top left; background-color: #222; } @keyframes shimmer { 0% { background-position: top left; } 100% { background-position: top right; } } `; shadow.appendChild(style); shadow.appendChild(span); } } // Define the new element customElements.define('code-front', CodeFront); // class CodeFront extends HTMLElement { // constructor() { // // Always call super first in constructor // super(); // // Create a shadow root // // open：shadow root元素可以从js外部访问根节点 // // closed：拒绝从js外部访问关闭的shadow root节点 // const shadow = this.attachShadow({ // mode: 'open' // }); // // Create div // const wrapper = document.createElement('div'); // wrapper.setAttribute('class', 'wrapper'); // // Create input // const input = document.createElement('input'); // // Define Attribute // const placeholder = this.getAttribute('placeholder'); // input.placeholder = placeholder || '暂无提示'; // // Create some CSS to apply to the shadow dom // const style = document.createElement('style'); // style.textContent = ` // .wrapper{ // display: inline-block; // } // `; // wrapper.appendChild(input); // shadow.appendChild(style); // shadow.appendChild(wrapper); // } // } // // Define the new element // customElements.define('code-front', CodeFront); angular的变化检测机制 参考： https://blog.csdn.net/zyxzp2012/article/details/90208489 什么是变更检测 变更检测的基本任务是获得程序的内部状态并使之在用户界面可见。这个状态可以是任意的数据类型。 引起变更原因 异步（Event、xhr、定时器）操作改变了程序的状态，导致视图的更新。 Angular 内的处理 Angular 有着自己的zone，称为NgZone。Angular源码的某个地方，有一个东西叫做ApplicationRef，它监听NgZones的onTurnDone事件。只要这个事件发生了，它就执行tick()函数，这个函数执行变更检测 // 真实源码的非常简化版本。 class ApplicationRef { changeDetectorRefs:ChangeDetectorRef[] = []; constructor(private zone: NgZone) { this.zone.onTurnDone.subscribe(() => this.zone.run(() => this.tick()); } tick() { this.changeDetectorRefs .forEach((ref) => ref.detectChanges()); } } 变更检测 在 Angular 中，每个组件都有它自己的 change detector (变更检测器) ChangeDetectorRef Angular 各种视图的基础类，提供变更检测功能。 变更检测树会收集要检查的所有视图。 使用这些方法从树中添加或移除视图、初始化变更检测并显式地把这些视图标记为脏的，意思是它们变了、需要重新渲染。 OnPush 的两种状态：https://angular.cn/api/core/ChangeDetectionStrategy 主要方法： abstract markForCheck(): void abstract detach(): void abstract detectChanges(): void abstract checkNoChanges(): void abstract reattach(): void 变更监听值变化及自定义变更： ngOnChanges：检测监听值的变更 ngDoCheck：检测和处理 Angular 自己没有捕捉到的变化，可自定义变更检测逻辑 组件注入 ChangeDetectorRef，并调用 markForCheck 方法，会告诉Angular，标记整条路径，从这个组件到根组件都需要被checked，一旦变更检测结束，它就会恢复为整棵树恢复OnPush状态 示例 app.conponent.ts import { ChangeDetectionStrategy, Component } from '@angular/core'; @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'], changeDetection: ChangeDetectionStrategy.OnPush }) export class AppComponent { text = ''; constructor() { } ngOnInit(): void { } } app.conponent.html app-child.ts import { ChangeDetectionStrategy, Component, EventEmitter, Input, OnInit, Output, SimpleChanges } from '@angular/core'; @Component({ selector: 'app-child', templateUrl: './child.component.html', styleUrls: ['./child.component.scss'], changeDetection: ChangeDetectionStrategy.OnPush }) export class ChildComponent implements OnInit { @Input() text = ''; @Output() textChange = new EventEmitter(); obj = { currentValue: '', previousValue: '' } constructor() { } ngOnInit(): void { } ngOnChanges(changes: SimpleChanges): void { console.log(changes); this.obj.currentValue = changes['text'].currentValue; this.obj.previousValue = changes['text'].previousValue; } change() { this.textChange.emit(this.text); } } app-child.html currentValue： previousValue： Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-03-30 13:26:32 "},"分享/技术选型及代码规范.html":{"url":"分享/技术选型及代码规范.html","title":"技术选型及代码规范","keywords":"","body":"概述 本期演讲内容包含: 技术选型 项目架构及框架对比 模块化分析 Less 与 Scss 相关技术演示 技术选型 前端三剑客：Angular、Vue、React UI库(或框架)：ng-zorro-antd、ng-zorro-mobile、IONIC、Boopstrap 5.0.0-alpha1等 UI(或代码)规范：antd规范、网易代码规范 中后台解决方案：ng-alain、antd-vue-pro 项目管理：git、svn 接口规范：RESTful API规范、swagger 附：ng-zorro-antd 官方群：320404326 ng-alain 官方群：316911865 前端在线调试工具：https://stackblitz.com/ git 简易视频教程：https://www.bilibili.com/video/BV1BE411g7SV 什么是Swagger？ Swagger 是一个规范且完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。 Swagger 的目标是对 REST API 定义一个标准且和语言无关的接口，可以让人和计算机拥有无须访问源码、文档或网络流量监测就可以发现和理解服务的能力。当通过 Swagger 进行正确定义，用户可以理解远程服务并使用最少实现逻辑与远程服务进行交互。与为底层编程所实现的接口类似，Swagger 消除了调用服务时可能会有的猜测。 Swagger 有什么优势？ 支持 API 自动生成同步的在线文档：使用 Swagger 后可以直接通过代码生成文档，不再需要自己手动编写接口文档了，对程序员来说非常方便，可以节约写文档的时间去学习新技术。 提供 Web 页面在线测试 API：光有文档还不够，Swagger 生成的文档还支持在线测试。参数和格式都定好了，直接在界面上输入参数对应的值即可在线测试接口。 项目架构及框架对比 目前：PC端 使用：angular+ng-zorro-antd 移动端 使用：angular+IONIC 静态单页面可使用：bootstrap 针对不同的业务需求，选择相应的技术栈。 附：静态项目可使用CDN加速链接：https://www.bootcdn.cn/ 模块化分析 模块化分为 CMD、AMD、CommonJs AMD 是RequireJS在推广过程中对模块定义的规范化产出，通过define()函数定义，第一个参数是一个数组，里面定义一些需要依赖的包，第二个参数是一个回调函数，代表：RequireJS CMD 是SeaJS在推广过程中对模块定义的规范化产出，是一个同步模块定义，是SeaJS的一个标准，SeaJS是CMD概念的一个实现，SeaJS是淘宝团队提供的一个模块开发的js框架，代表：SeaJS CommonJS 是通过module.exports定义的，在前端浏览器里面并不支持module.exports，通过node.js后端使用的。Nodejs端是使用CommonJS规范的，前端浏览器一般使用AMD、CMD、ES6等定义模块化开发，写法有：module export 和 exports.xx(参数)两种， 代表：CommonJS 模块化及组件化 模块化（按功能） -> 汽车组装 = 车架+车门+车轮+发动机等 组件化（按最小元部件）-> 车轮 = 橡胶轮胎+轮轴+轮架子等 Less 与 Scss Less中文官网：http://lesscss.cn/ 简述： Sass和Less都属于Css预处理器，Css预处理器定义了一种新的语言，其基本思想是用一种专门的编程语言，为Css增加一些编程的特性，将Css作为目标生成文件，然后开发者使用这种语言进行Css编码工作(用一种专门的编程语言，进行Web网页样式设计，再通过编译器转化为正常的Css文件，以供项目使用)。写法大体相同。 其中Scss分2种：1.Sass：格式严谨，写法类同python。2.Scss：可与普通写法嵌套 共同点： 混合(Mixins):将一个定义好的classA引入到另一个classB中，从而简单实现classB继承了classA的所有属性； 参数混合(Parametric):可以像函数一样传递参数的class 嵌套规则：class中嵌套class,从而减少重复的代码 运算：css中的数学计算 颜色功能：可以编辑你的颜色 命名空间：样式分组，从而方便被调用 作用域：局部修改样式 JavaScript表达式：在css样式中使用javaScript表达式赋值 附：css、less、scss相互转换工具：http://koala-app.com/ Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-03-30 13:26:32 "},"实用工具/工具.html":{"url":"实用工具/工具.html","title":"工具","keywords":"","body":"css文件转行内样式（打印机使用） https://github.com/jonkemp/inline-css var inlineCss = require('inline-css'); var html = ``; inlineCss(html,{url:'/'}).then(function(html) { console.log(html); }); GitLab 使用 GitLab - 芒果文档 (imangodoc.com) Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-03-30 13:26:32 "}}