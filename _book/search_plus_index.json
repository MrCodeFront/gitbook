{"./":{"url":"./","title":"前言","keywords":"","body":"前言 欢迎阅读 CodeFront 笔记 我们的口号是：日积月累，提升自我！ 作者正在内卷中... Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-03-30 13:26:32 "},"android/Android学习.html":{"url":"android/Android学习.html","title":"Android学习","keywords":"","body":"Android 学习 词汇 AVD（安卓虚拟设备） 应用组件(共4种) 1.Activity 2.服务 3.广播接收器 4.内容提供程序 https://developer.android.google.cn/guide/components/fundamentals Activity 是与用户交互的入口点。它表示拥有界面的单个屏幕. 服务 是一个通用入口点，用于因各种原因使应用在后台保持运行状态。它是一种在后台运行的组件，用于执行长时间运行的操作或为远程进程执行作业。服务不提供界面。 借助广播接收器组件，系统能够在常规用户流之外向应用传递事件，从而允许应用响应系统范围内的广播通知。 内容提供程序 管理一组共享的应用数据，您可以将这些数据存储在文件系统、SQLite 数据库、网络中或者您的应用可访问的任何其他持久化存储位置。 在 Android 系统启动应用组件之前，系统必须通过读取应用的清单文件 (AndroidManifest.xml) 确认组件存在。您的应用必须在此文件中声明其所有组件，该文件必须位于应用项目目录的根目录中。 Android API https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element#ApiLevels 什么是API级别 API 级别是对 Android 平台版本提供的框架 API 修订版进行唯一标识的整数值。 Android 平台提供一种框架 API，应用可利用它与底层 Android 系统进行交互。该框架 API 由以下部分组成： 一组核心软件包和类 一组用于声明清单文件的 XML 元素和属性 一组用于声明和访问资源的 XML 元素和属性 一组 Intent 一组应用可请求的权限，以及系统中包括的权限强制执行 Android 平台的每个后续版本均可包括其提供的 Android 应用框架 API 的更新。 框架 API 更新的设计用途是使新 API 与早期版本的 API 保持兼容。换言之，大多数 API 更改都是新增更改，并且会引入新功能或替代功能。在 API 的某些部分得到升级时，系统会弃用经替换的旧版部分，但不会将其移除，以便其仍可供现有应用使用。在极少数情况下，系统可能会修改或移除 API 的某些部分，但通常只有在为确保 API 稳健性以及应用或系统安全性时，才需要进行此类更改。所有其他来自早期修订版的 API 部分都将继续保留，不做任何修改。 Android 平台提供的框架 API 使用称为“API 级别”的整数标识符指定。每个 Android 平台版本恰好支持一个 API 级别，但隐含对所有早期 API 级别（低至 API 级别 1）的支持。Android 平台初始版本提供的是 API 级别 1，后续版本的 API 级别则依次增加。 Android Studio 与 逍遥模拟器 连接 查看Microvirt\\MEmu\\MemuHyperv VMs\\MEmu目录下MEmu.memu的端口号。cmd 到逍遥模拟器Microvirt\\MEmu目录下，运行:adb.exe connect 127.0.0.1 看见 connected to 127.0.0.1:21503 表示连接成功 官方demo讲解: https://www.it610.com/article/1297923636153360384.htm Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2021-11-18 15:08:38 "},"android/打包.html":{"url":"android/打包.html","title":"打包","keywords":"","body":"Android 打包 自定义apk名称 路径：app/build.gradle android { android.applicationVariants.all { variant -> variant.outputs.all { //在这里修改apk文件名 outputFileName = \"01-cutting-supermarket-v${new String(variant.versionName).replace('.','')}.apk\" } } } 修改版本号 路径：app/build.gradle versionName 路径：app/build/generated/source/buildConfig/debug/io/ionic/starter/BuildConfig.java VERSION_NAME Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-03-30 13:26:32 "},"android/环境搭建.html":{"url":"android/环境搭建.html","title":"环境搭建","keywords":"","body":"android环境安装配置： https://www.jianshu.com/p/c3a8a158edf4 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-07-11 11:14:31 "},"angular/Overlay遮罩.html":{"url":"angular/Overlay遮罩.html","title":"Overlay遮罩","keywords":"","body":"Overlay 遮罩 参考： https://zhuanlan.zhihu.com/p/146943731 github：https://github.com/angular/components/tree/7cd78ffc59c1975012b4a7913f147cedc9c97ae0/src/cdk/overlay OverlayContainer OverlayContainer 在 body 元素的最后创建了一个元素，用于包裹全部的浮层元素。之后我们会称该元素为 container element。 该元素会在 getContainerElement 方法第一次被调用的时候创建（惰性实例化）。 注意这个服务是全局的。 Overlay Overlay 是一个服务，通过它的 create 方法可以创建一个新的浮层，这个过程中主要做了以下几件事： 创建一个 host element 和一个 pane element，然后将 pane element 作为 PortalOutlet 的挂载点，而这里 PortalOutlet 的类型就是我在之前一篇文章中讲过的 DomPortalOutlet，它将会被用来挂在组件内容。 创建一个 OverlayConfig 对象，OverlayConfig 的构造方法仅仅是把 plain object 上面的非 undefined 属性转移到新创建的 OverlayConfig 对象上。 创建一个 OverlayRef 并返回，值得注意的是第一步中创建的 PortalOutlet 会被传递给 OverlayRef 的构造方法。 OverlayRef 类非常重要，它负责了浮层机制的绝大部分逻辑，并且是暴露给组件开发者操纵浮层的接口对象。 OverlayRef OverlayRef 的构造方法确定了该浮层的 scroll strategy 和 position strategy，这部分我们之后来谈。 组件开发者在新创建的浮层上添加组件时，应该调用 OverlayRef 的 attach 方法，参数应该是一个 Portal 对象。这个方法做了如下几件事情： 将 Portal attach 到 DomPortalOutlet 上，这一步会动态创建组件开发者定义的内容 启用 position strategy 通过 _updateStackingOrder 方法更新 host element 在 container element 中的位置，最新创建的浮层应该在 DOM 树的最上方 通过 _updateElementSize 方法更新 pane element 元素的样式 启用 scroll strategy 在 Angular zone 稳定之后（一般是组件 DOM 已经创建）调整浮层的位置 打开浮层的鼠标事件支持 根据配置创建 backdrop（之后再讲） 根据配置修改 pane element 的 CSS 类 派发 attach 事件 将自己注册到 KeyboardDispatcher 中（之后再讲） OverlayRef 类还有以下几个重要的方法： detach，卸载当前浮层添加的组件。 dispose，销毁当前浮层。 PositionStrategy attach 方法的第二步是启用 position strategy，这里我们先来讲解比较简单的 GlobalPositionStrategy，也是 BottomSheet 组件所使用的。 position strategy 就是定位策略，提供了一组定位浮层内元素的方法。 GlobalPositionStrategy 实现了 PositionStrategy 接口，用户也可以通过实现该接口自定义一个 position strategy。 attach 方法在浮层启用 position strategy 时被调用。对于 GlobalPositionStrategy 而言，主要是对 host element 增加了 cdk-global-overlay-wrapper CSS 类。 .cdk-global-overlay-wrapper { display: flex; position: absolute; z-index: 1000; pointer-events: none; top: 0; left: 0; height: 100%; width: 100%; } apply 方法在需要调整浮层元素位置时被调用。该方法通过修改 host element 和 pane element 的样式来控制浮层元素的位置。 还有如下方法比较重要： dispose，在 position strategy 被销毁（比如跟随浮层被销毁，或者浮层切换了 position strategy）的时候做回复操作。 其他方法都是暴露出来修改定位的，这里就不 cover 了。 辅助机制 Backdrop 有些浮层需要有一个后置的全屏图层，来凸显浮层内容，同时作为 MouseEvent 的 target，支持“点击浮层外关闭”这样的功能。 Backdrop 由 _attachBackdrop 方法所创建，实质上是创建了这样一个元素 并把它插入到 host element 之前，保持图层叠加的顺序。 同时在浮层上绑定了一个 click 事件的 handler，通过此 handle 派发 _backdropClick 事件。 KeyboardDispatcher KeyboardDispatcher 负责将键盘事件分派给最近打开的浮层。 之前讲到浮层 attach 的时候会调用 KeyboardDispatcher 的 add 方法，该方法会将调用此方法的 overlay 注册在 _attachedOverlays 数组的最后，且会第一个 overlay 注册的时候在 document 上绑定 keydown 事件的 handler，而该 handler 会从数组尾部开始逆序查找监听了 keydown 事件的 overlay，并对它派发 keydown 事件。 KeyboardDispatcher 使得最近一个打开的 overlay 才能监听键盘事件，一种常见的使用场景就是支持按 esc 键时有序地关闭 overlay。 ScrollStrategy scroll strategy 确定了在浮层展开时，原文档应当如何滚动。任意的 scroll strategy 都需要实现 ScrollStrategy 接口。 我们以 CDK 提供的 CloseScrollStrategy 为例，这种 strategy 会在页面内容滚动时关闭浮层。 在 OverlayRef 初始化时会调用 attach 方法，而 Overlay 的 attach 方法会调用 enable 方法，这个方法会监听全局滚动事件，并根据滚动范围和设置的门限调用 _detach 方法，最终是调用 OverlayRef 的 detach 方法卸载浮层内容。 例子 下面以 BottomSheet 组件为例，看一下 overlay 是如何使用的。 用户用 open 方法创建一个新的 BottomSheet 组件，这个方法会通过 _createOverlay 创建一个新的浮层，该方法的全部代码如下： /** * Creates a new overlay and places it in the correct location. * @param config The user-specified bottom sheet config. */ private _createOverlay(config: MatBottomSheetConfig): OverlayRef { const overlayConfig = new OverlayConfig({ direction: config.direction, hasBackdrop: config.hasBackdrop, disposeOnNavigation: config.closeOnNavigation, maxWidth: '100%', scrollStrategy: config.scrollStrategy || this._overlay.scrollStrategies.block(), positionStrategy: this._overlay.position().global().centerHorizontally().bottom('0') }); if (config.backdropClass) { overlayConfig.backdropClass = config.backdropClass; } return this._overlay.create(overlayConfig); } 可以看到默认使用的是 BlockScrollStrategy 和 GlobalPositionStrategy。 实际上是通过工厂类 OverlayPositionBuilder 和 ScrollStrategyOptions 创建的。 个人觉得这不是个好设计，会导致没用到的 Strategy 没法被 tree shake 掉。 然后 _attachContainer 方法就会将 BottomSheep 组件内容 attach 到 portal 上了。 const containerRef: ComponentRef = overlayRef.attach( containerPortal ) Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-04-18 11:17:03 "},"angular/内嵌视图、宿主视图.html":{"url":"angular/内嵌视图、宿主视图.html","title":"内嵌视图、宿主视图","keywords":"","body":"Angular 内嵌视图、宿主视图 - Zero_追梦 - 博客园 (cnblogs.com) Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-05-13 15:06:17 "},"angular/工作区.html":{"url":"angular/工作区.html","title":"工作区","keywords":"","body":"工作区（多项目、多库） 参考 https://zhuanlan.zhihu.com/p/54075580 https://zhuanlan.zhihu.com/p/157205769 https://blog.csdn.net/lvxinaidou/article/details/125856927 创建一个不包含初始化应用的 Angular 工作区 不包含 projects 配置项的 Angular 配置文件 单独ng build 或者 ng serve不会生效 ng new 工作区名 --createApplication=false 创建库项目 ng generate library 库名 --prefix=库前缀 创建应用 ng generate application 应用名 构建 ng build 应用名|库名 运行 ng serve 应用名|库名 测试 ng test 应用名|库名 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-10-20 10:15:48 "},"angular/常用命令.html":{"url":"angular/常用命令.html","title":"常用命令","keywords":"","body":"版本升级 ng update @angular/cli @angular/core --allow-dirty --force Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2021-12-14 09:47:02 "},"angular/开发问题.html":{"url":"angular/开发问题.html","title":"开发问题","keywords":"","body":"nz-zorro table 数据无法更新（使用深拷贝） 问题原因是，NG-ZORRO从 7.0 版本开始，NG-ZORRO 组件默认在 OnPush 模式下工作，OnPush 意味着只有在输入发生变化时才运行组件的变化检测，并且当输入发生变化时，它们的整个对象实例必须发生变化。如果对象实例引用不变，则不会运行变化检测。对象实例的引用没有发生变化，于是从 Angular 的视角看来，也就没有什么需要报告的变化了。如上所述，在使用 Table 组件时，如果对源数据数组进行 array.push/splice 操作，这并不会更改对象实例的引用，所以页面并不会发生更新。 // push concat 可用 this.tableList.push(res.data); this.tableList = [...this.tableList]; // 添加这行代码 // 使用 lodash 的 cloneDeep npm install lodash @types/lodash import * as _ from 'lodash'; this.tableList = _.cloneDeep(this.tableList); // html 中使用原始数据进行渲染 // 指定服务器端渲染(shiy) [nzFrontPagination]='false' input自定义指令修改value与ngModel绑定数据不一致 https://blog.csdn.net/rushichunqiu/article/details/79161076 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-10-14 11:06:51 "},"angular/标签区域配置.html":{"url":"angular/标签区域配置.html","title":"标签区域配置","keywords":"","body":"标签区域配置 ts html Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-12-02 09:14:13 "},"angular/相关资料.html":{"url":"angular/相关资料.html","title":"相关资料","keywords":"","body":"v13新功能及优化 https://zhuanlan.zhihu.com/p/429724953 常用管道 https://zhuanlan.zhihu.com/p/212204583 AOT编译出现内存溢出瓶颈 https://www.infoq.cn/article/2017/08/compile-project-memory-bottlenec/ Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-12-01 15:59:30 "},"angular/系统权限.html":{"url":"angular/系统权限.html","title":"系统权限","keywords":"","body":"系统权限 可全局使用，菜单权限逐步迁移到服务中进行配置。 auth.service.ts 权限服务中添加权限配置项，只有再服务中配置后，使用的时候才会生效。具体配置请看例子 auth-name.ts 权限名称配置，为能在服务中方便查阅 具体使用： Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-11-24 17:53:32 "},"angular/自定义指令.html":{"url":"angular/自定义指令.html","title":"自定义指令","keywords":"","body":"自定义指令传参 通过 @Input() 进行传参 模板： private 私有属性 = 值; @Input() set 属性名称(值) { this.私有属性 = 值; } 示例： import { Directive, HostListener, Input } from '@angular/core'; @Directive({ selector: '[inputNumber]', }) export class InputNumberDirective { constructor() { } @HostListener('input', ['$event.target']) inputChange(event) { let str = ''; if (this.dotNum > 0) { str = `\\\\d*(\\\\.{0,1}\\\\d{0,${this.dotNum}})?`; } else { str = `\\\\d*`; } const reg = new RegExp(str); event.value = !isNaN(value) ? value.match(reg) ? value.match(reg)[0] : '' : ''; } private dotNum = 2; // 小数位 @Input() set inputNumber(obj: { dotNum?: number }) { this.dotNum = !isNaN(obj.dotNum) && obj.dotNum >= 0 ? obj.dotNum : 2; } } Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-04-01 10:28:49 "},"angular/路由复用及自定义钩子方法.html":{"url":"angular/路由复用及自定义钩子方法.html","title":"路由复用及自定义钩子方法","keywords":"","body":"路由复用 实现 %accordion%ts%accordion% import { Component, OnInit } from '@angular/core'; import { ActivatedRoute, NavigationEnd, Router } from '@angular/router'; import { NzContextMenuService, NzDropdownMenuComponent } from 'ng-zorro-antd/dropdown'; import { Subscription } from 'rxjs'; import { filter, map } from 'rxjs/operators'; import { SettingService, TAB } from '../../services/setting.service'; import { CloseType } from './reuse-tab.interfaces'; import { ReuseTabService } from './reuse-tab.service'; @Component({ selector: 'reuse-tab', templateUrl: './reuse-tab.component.html', styleUrls: ['./reuse-tab.component.scss'] }) export class ReuseTabComponent implements OnInit { subscript: Subscription; constructor( public router: Router, public activatedRoute: ActivatedRoute, public settingService: SettingService, public reuseTabService: ReuseTabService, public nzContextMenuService: NzContextMenuService ) { this.subscript = this.router.events.pipe( filter(event => event instanceof NavigationEnd), map(() => this.activatedRoute), map(route => { while (route.firstChild) { route = route.firstChild; } return route; }), filter(route => route.outlet === 'primary') ).subscribe((res: any) => { const obj: TAB = { title: res.data.value.title, module: res.data.value.module, routerLink: res._routerState.snapshot.url.split('?')[0], queryParams: res.queryParams.value, disabled: false, close: true, delrouterurl: res._routerState.snapshot.url.replace(/\\//g, '_') + '_' + (res.routeConfig.loadChildren || res.routeConfig.component.toString().split('(')[0].split(' ')[1]) }; if (obj.routerLink === '/dashboard/home') { obj.disabled = true; obj.close = false; } if (obj.routerLink.endsWith('working/ww')) { obj.title = '成品加工单'; } else if (obj.routerLink.endsWith('working/pur')) { obj.title = '成品采购单'; } else if (obj.routerLink.endsWith('working/wp')) { obj.title = '工艺加工单'; } else if (obj.routerLink.endsWith('working/ww/detail')) { obj.title = '成品加工单详情'; } else if (obj.routerLink.endsWith('working/pur/detail')) { obj.title = '成品采购单详情'; } else if (obj.routerLink.endsWith('working/wp/detail')) { obj.title = '工艺加工单详情'; } //判断是否存在相同路由，如果不存在新增，如果存在则修改 if (this.settingService.tabList.every((item: any) => item.routerLink !== obj.routerLink)) { //判断标题是否重复; //obj['no'] = 1; //obj['newTitle'] = res.data.value.title; // if (this.settingService.tabList.some((item: any) => item.title === `${res.data.value.title}`)) { // const maxNo = Math.max(...this.settingService.tabList.filter((item: any) => item.title === `${res.data.value.title}`).map((item: any) => (item.no))); // obj['no'] = maxNo + 1; // obj['newTitle'] = `${obj.title}(${obj['no']})`; // } // 新增tab并跳转 this.settingService.setTab(obj); this.reuseTabService.selectedIndex = this.settingService.tabList.length; } else { //存在，改变路由参数和看板 模块标题 this.settingService.tabList.forEach((item: any, index: number) => { if (item.routerLink == obj.routerLink) { this.settingService.tabList[index].queryParams = obj.queryParams; this.reuseTabService.selectedIndex = index; } }); } }); } ngOnInit(): void { } toPage(item: { routerLink: string, queryParams: object }) { this.router.navigate([item.routerLink], { queryParams: item.queryParams }); } /** 菜单操作 */ doneMenu(e: any, type: CloseType) { switch (type) { case 'clear': this.reuseTabService.clear(); break; case 'close': this.reuseTabService.close(); break; case 'closeOther': this.reuseTabService.closeOther(); break; case 'closeRight': this.reuseTabService.closeRight(); break; } } /** 关闭当前标签 */ close(e: Event, item: object, index: number) { e.stopPropagation(); this.reuseTabService.reuseItem = { ...item, index } this.reuseTabService.close(); } /** 创建菜单 */ contextMenu($event: MouseEvent, menu: NzDropdownMenuComponent): void { this.nzContextMenuService.close(); if (!this.reuseTabService.reuseItem.disabled) { this.nzContextMenuService.create($event, menu); } } ngOnDestroy(): void { this.subscript.unsubscribe(); } } %/accordion% %accordion%html%accordion% 关闭 关闭右侧标签页 2)\">关闭其他标签页 1)\">关闭所有标签页 %/accordion% %accordion%scss%accordion% .main-tabset-card { border: 0; ::ng-deep .ant-tabs-tab { background: rgba(250, 250, 250, .5); .icon-close { font-size: 14px; padding: 2px; margin: 0 0 0 12px; &:hover { color: rgba(0, 0, 0, 0.85); background: rgba(0, 0, 0, .15); border-radius: 100%; } } &:hover { color: rgba(0, 0, 0, 0.85); background-color: #ffffff; span, i { color: rgba(0, 0, 0, 0.85); } } &.ant-tabs-tab-active { color: #ffffff; background-color: rgb(0, 183, 150); span, i { color: #ffffff; } .icon-close { font-size: 14px; padding: 2px; margin: 0 0 0 12px; color: #ffffff; &:hover { background: rgba(0, 0, 0, .15); border-radius: 100%; } } } } ::ng-deep .ant-tabs-nav { margin: 0; } } .context-menu { position: relative; top: 0; left: 0; width: 100%; height: 100%; } %/accordion% %accordion%directive%accordion% import { Directive, Input } from '@angular/core'; import { NzContextMenuService, NzDropdownMenuComponent } from 'ng-zorro-antd/dropdown'; import { ReuseTabService } from './reuse-tab.service'; @Directive({ selector: '[reuse-tab-context-menu]', exportAs: 'reuseTabContextMenu', host: { '(nzContextmenu)': '_onContextMenu($event)' } }) export class ReuseTabContextDirective { private reuseItem = null; @Input('reuse-tab-context-menu') set obj(obj: { item: any, index: number }) { this.reuseItem = { ...obj.item, index: obj.index }; }; constructor( public nzContextMenuService: NzContextMenuService, public reuseTabService: ReuseTabService ) { } _onContextMenu(event: MouseEvent, menu: NzDropdownMenuComponent): void { this.reuseTabService.reuseItem = this.reuseItem; event.preventDefault(); event.stopPropagation(); } } %/accordion% %accordion%interface%accordion% export type CloseType = 'clear' | 'close' | 'closeOther' | 'closeRight' | 'custom' | 'refresh' | null; export type ReuseHookTypes = 'onReuseInit' | 'onReuseDestroy'; export type ReuseHookOnReuseInitType = 'init' | 'reflash'; export interface ReuseComponentHandle { componentRef: ReuseComponentRef; } export interface ReuseComponentRef { instance: ReuseComponentInstance; } export interface ReuseComponentInstance { onReuseInit: (type: ReuseHookOnReuseInitType) => void; onReuseDestroy: () => void; } %/accordion% %accordion%service%accordion% import { Injectable, Injector } from '@angular/core'; import { ActivatedRouteSnapshot } from '@angular/router'; import { NzSafeAny } from 'ng-zorro-antd/core/types'; import { timer } from 'rxjs'; import { CommonService } from '../../services/common.service'; import { SettingService } from '../../services/setting.service'; import { ReuseComponentHandle, ReuseComponentRef, ReuseHookOnReuseInitType, ReuseHookTypes } from './reuse-tab.interfaces'; interface IRouteConfigData { keep: boolean; } interface ICachedRoute { handle: ReuseComponentHandle; data: IRouteConfigData; } @Injectable({ providedIn: 'root' }) export class ReuseTabService { selectedIndex = 0; reuseItem = null; // reuseItem 数据 public static routeCache = new Map(); private static waitDelete: string; // 当前页未进行存储时需要删除 private static currentDelete: string; // 当前页存储过时需要删除 constructor( private injector: Injector, private settingService: SettingService ) { } /** 进入路由触发，判断是否是同一路由 */ shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean { return future.routeConfig === curr.routeConfig && JSON.stringify(future.params) == JSON.stringify(curr.params); } /** 表示对所有路由允许复用 如果你有路由不想利用可以在这加一些业务逻辑判断，这里判断是否有data数据判断是否复用 */ shouldDetach(route: ActivatedRouteSnapshot): boolean { if (this.getRouteData(route)) { return true; } return false; } /** 当路由离开时会触发。按path作为key存储路由快照&组件当前实例对象 */ store(route: ActivatedRouteSnapshot, handle: NzSafeAny): void { const url = this.getRouteUrl(route); const data = this.getRouteData(route); if (ReuseTabService.waitDelete && ReuseTabService.waitDelete === url) { // 如果待删除是当前路由，且未存储过则不存储快照 ReuseTabService.waitDelete = null; return null; } else { // 如果待删除是当前路由，且存储过则不存储快照 if (ReuseTabService.currentDelete && ReuseTabService.currentDelete === url) { ReuseTabService.currentDelete = null; return null; } else { if (handle) { ReuseTabService.routeCache.set(url, { handle, data }); this.addRedirectsRecursively(route); } else { console.log('routeCache：', ReuseTabService.routeCache); console.log(url); console.log(ReuseTabService.routeCache.get(url)); // 路由复用后触发自定义初始化钩子 const componentRef = ReuseTabService.routeCache.get(url).handle?.componentRef; timer(100).subscribe(() => this.runHook('onReuseInit', componentRef)); } } } if (handle && handle.componentRef) { // 路由复用后触发自定义销毁钩子 this.runHook('onReuseDestroy', handle.componentRef); } } /** 若 path 在缓存中有的都认为允许还原路由 */ shouldAttach(route: ActivatedRouteSnapshot): boolean { const url = this.getRouteUrl(route); const handle = ReuseTabService.routeCache.has(url) ? ReuseTabService.routeCache.get(url).handle : null; const data = this.getRouteData(route); return data && ReuseTabService.routeCache.has(url) && handle != null; } /** 从缓存中获取快照，若无则返回nul */ retrieve(route: ActivatedRouteSnapshot): NzSafeAny | null { const url = this.getRouteUrl(route); const data = this.getRouteData(route); return data && ReuseTabService.routeCache.has(url) ? ReuseTabService.routeCache.get(url).handle : null; } private addRedirectsRecursively(route: ActivatedRouteSnapshot): void { const config = route.routeConfig; if (config) { if (!config.loadChildren) { const routeFirstChild = route.firstChild; const routeFirstChildUrl = routeFirstChild ? this.getRouteUrlPaths(routeFirstChild).join('/') : ''; const childConfigs = config.children; if (childConfigs) { const childConfigWithRedirect = childConfigs.find( c => c.path === '' && !!c.redirectTo ); if (childConfigWithRedirect) { childConfigWithRedirect.redirectTo = routeFirstChildUrl; } } } route.children.forEach(childRoute => { this.addRedirectsRecursively(childRoute); }); } } private getRouteUrl(route: ActivatedRouteSnapshot) { return ( route['_routerState'].url.replace(/\\//g, '_') + '_' + (route.routeConfig.loadChildren || route.routeConfig.component .toString() .split('(')[0] .split(' ')[1]) ); } private getRouteUrlPaths(route: ActivatedRouteSnapshot): string[] { return route.url.map(urlSegment => urlSegment.path); } private getRouteData(route: ActivatedRouteSnapshot): IRouteConfigData { return ( route.routeConfig && (route.routeConfig.data as IRouteConfigData) && route.routeConfig.data.keep ); } /** 用于删除路由快照*/ deleteRouteSnapshot(url: string): void { if (url[0] === '/') { url = url.substring(1); } url = url.replace('/', '_'); // console.log(\"del-url\",url); // console.log('routeCache',ReuseTabService .routeCache); if (ReuseTabService.routeCache.has(url)) { // console.log(\"del-url-OK\",url); ReuseTabService.routeCache.delete(url); ReuseTabService.currentDelete = url; } else { ReuseTabService.waitDelete = url; } } clear() { ReuseTabService.routeCache.clear(); } clearExcept(list) { if (!list || !ReuseTabService.routeCache) return; try { let waitDelete = []; ReuseTabService.routeCache.forEach((value: ICachedRoute, key) => { let handle: any = value.handle; let url = handle.route.value._routerState.snapshot.url; if (list.indexOf(url) { ReuseTabService.routeCache.delete(item); }); } catch (error) { console.log('clearExcept error', error); } } /** 执行钩子 */ runHook( method: ReuseHookTypes, componentRef: ReuseComponentRef | undefined, type: ReuseHookOnReuseInitType = 'init' ): void { if (componentRef == null || !componentRef.instance) { return; } const componentThis = componentRef.instance; const fn = componentThis[method]; if (typeof fn !== 'function') { return; } if (method === 'onReuseInit') { fn.call(componentThis, type); } else { (fn as () => void).call(componentThis); } } /** 关闭所有标签 */ closeAll() { this.settingService.tabList = [this.settingService.tabList.shift()]; localStorage.setItem('tabList', JSON.stringify(this.settingService.tabList)); this.clear(); this.injector.get(CommonService).toPage({ url: this.settingService.tabList[0].routerLink }); } /** 关闭当前标签 */ close() { if (this.reuseItem) { // 关闭 tab 同时移除菜单中隐藏的 非menu 项 const i = this.settingService.menuList.findIndex((item: any) => item.path === this.settingService.tabList[this.reuseItem.index].routerLink && item.hasOwnProperty('isExtra') && item.isExtra); if (i > -1) { this.settingService.menuList.splice(i, 1); } // 删除当前page页面路由复用 this.deleteRouteSnapshot(this.settingService.tabList[this.reuseItem.index].delrouterurl); this.settingService.tabList.splice(this.reuseItem.index, 1); localStorage.setItem('tabList', JSON.stringify(this.settingService.tabList)); if (this.selectedIndex >= this.reuseItem.index && this.settingService.tabList.length > 0) { this.selectedIndex -= 1; this.injector.get(CommonService).toPage({ url: this.settingService.tabList[this.selectedIndex].routerLink, params: this.settingService.tabList[this.selectedIndex].queryParams }); } } } /** 关闭其他标签 */ closeOther() { if (this.reuseItem) { const list = []; list.push(this.settingService.tabList[0]); const index = this.settingService.tabList.findIndex((item: any) => item.routerLink === this.reuseItem.routerLink); if (index > -1) { list.push(this.settingService.tabList[index]); } this.clearExcept([this.settingService.tabList[0].routerLink, this.reuseItem.routerLink]); this.settingService.tabList = [...list]; localStorage.setItem('tabList', JSON.stringify(this.settingService.tabList)); if (index > -1 && index !== this.selectedIndex && this.settingService.tabList.length > 0) { this.injector.get(CommonService).toPage({ url: this.settingService.tabList[this.settingService.tabList.length - 1].routerLink, params: this.settingService.tabList[this.settingService.tabList.length - 1].queryParams }); } } } /** 关闭右边标签 */ closeRight() { if (this.reuseItem) { const index = this.settingService.tabList.findIndex((item: any) => item.routerLink === this.reuseItem.routerLink); this.settingService.tabList.forEach((item: any, i: number) => { if (i > index) { this.deleteRouteSnapshot(this.settingService.tabList[i].delrouterurl); } }) this.settingService.tabList = this.settingService.tabList.splice(0, index + 1); localStorage.setItem('tabList', JSON.stringify(this.settingService.tabList)); if (index > -1 && index 0) { this.injector.get(CommonService).toPage({ url: this.settingService.tabList[this.settingService.tabList.length - 1].routerLink, params: this.settingService.tabList[this.settingService.tabList.length - 1].queryParams }); } } } } %/accordion% 路由复用自定义钩子 描述 1.自定义钩子属于组件实例方法。 2.使用了路由复用后可根据触发机制进行相应触发，无需删除路由快照，也无需进行路由跳转，只需要添加复用钩子，对需要刷新的数据进行相应处理即可。 3.还可根据需求添加其他自定义钩子函数，默认添加了onReuseInit和onReuseDestroy2个钩子方法。 具体使用方式参考以下示例： 用法 export class xxxComponent implements OnInit { ngOnInit(): void { } ... /** 路由复用后触发钩子（可局部刷新数据） */ onReuseInit(): void { // 需要刷新的数据或请求 } /** 路由复用后销毁钩子 */ onReuseDestroy(): void { } } Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-05-13 15:04:13 "},"antd/栅格.html":{"url":"antd/栅格.html","title":"栅格","keywords":"","body":"栅格布局 一行6列 col： nzXXl='4' nzXl=\"6\" nzLg=\"8\" nzMd=\"8\" nzSm=\"12\" nzXs=\"24\" form-label： [nzSpan]=\"8\" form-content： [nzSpan]=\"16\" // 开始结束日期、备注等较长表单组件 col： nzXXl='8' nzXl=\"12\" nzLg=\"16\" nzMd=\"16\" nzSm=\"12\" nzXs=\"24\" form-label： [nzSpan]=\"4\" form-content： [nzSpan]=\"20\" 一行4列 col： nzXXl='6' nzXl=\"6\" nzLg=\"8\" nzMd=\"8\" nzSm=\"12\" nzXs=\"24\" form-label： [nzSpan]=\"8\" form-content： [nzSpan]=\"16\" // 开始结束日期、备注等较长表单组件 col： nzXXl='6' nzXl=\"12\" nzLg=\"16\" nzMd=\"16\" nzSm=\"12\" nzXs=\"24\" form-label： nzXXl='8' nzXl=\"4\" nzLg=\"4\" nzMd=\"4\" nzSm=\"4\" nzXs=\"4\" form-content： nzXXl='16' nzXl=\"20\" nzLg=\"20\" nzMd=\"20\" nzSm=\"20\" nzXs=\"20\" Demo ... ... ... ... 搜索 重置 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-04-01 10:38:22 "},"antd/栅格布局组件排序及显示方案.html":{"url":"antd/栅格布局组件排序及显示方案.html","title":"栅格布局组件排序及显示方案","keywords":"","body":"栅格布局组件排序及显示方案 通过插槽原理，对指定模板进行渲染 ng-template 定义插槽名称 ng-container 指定渲染模板名称 优点： 1.可灵活定义模板插入位置，无需关注模板定义位置 2.无需写for循环一个个匹对，减少if和switch多层匹配，渲染性能更好 用法： 示例： 实战： import { ChangeDetectorRef, Component, NgZone, TemplateRef, ViewChild } from '@angular/core'; @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'] }) export class AppComponent { @ViewChild('Stylist1Temp', { static: false }) Stylist1Temp!: TemplateRef; @ViewChild('Stylist2Temp', { static: false }) Stylist2Temp!: TemplateRef; list: any[] = [ { FieldCustTitle: 'FieldCustTitle1', FieldName: 'Stylist1', Visibled: true }, { FieldCustTitle: 'FieldCustTitle2', FieldName: 'Stylist2', Visibled: true } ]; constructor( public cdr: ChangeDetectorRef ) { } ngOnInit(): void { } ngAfterViewInit(): void { this.list = this.list.map((item: any) => { let temp = null; switch (item.FieldName) { case 'Stylist1': temp = this.Stylist1Temp; break; case 'Stylist2': temp = this.Stylist2Temp; break; } return { ...item, temp } }); // 视图检测变更 this.cdr.markForCheck(); this.cdr.detectChanges(); } } 当前索引： FieldCustTitle： FieldName： 当前索引： FieldCustTitle： FieldName： Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-04-06 13:56:30 "},"antd/表格勾选.html":{"url":"antd/表格勾选.html","title":"表格勾选","keywords":"","body":"表格勾选 非分组 allChecked = false; indeterminate = false; setOfCheckedId = new Set(); /** 更新勾选状态设置 */ updateCheckedSet(index: number, checked: boolean): void { if (checked) { this.setOfCheckedId.add(index); } else { this.setOfCheckedId.delete(index); } } /** 全选 */ allCheckedChange(value: boolean) { this.tableList.forEach((item: any, index: number) => this.updateCheckedSet(index, value)); this.refreshCheckedStatus(); } /** 单选 */ singleCheckedChange(index: number, checked: boolean) { this.updateCheckedSet(index, checked); this.refreshCheckedStatus(); } /** 更新勾选状态 */ refreshCheckedStatus(): void { this.allChecked = this.tableList.every((item: any, index: number) => this.setOfCheckedId.has(index)); this.indeterminate = this.tableList.some((item: any, index: number) => this.setOfCheckedId.has(index)) && !this.allChecked; } 普通分组 /** 更新勾选状态设置 */ updateCheckedSet(index: number, checked: boolean): void { if (checked) { this.setOfCheckedId.add(index); } else { this.setOfCheckedId.delete(index); } } /** 全选 */ allCheckedChange(value: boolean) { if (this.tabIndex === 0 || this.tabIndex === 1) { this.tableList1.forEach((item: any, index: number) => this.updateCheckedSet(index, value)); } else if (this.tabIndex === 2 || this.tabIndex === 3) { this.tableList2.forEach((item: any, index: number) => { item.groupList.forEach((item2: any, index2: number) => { this.updateCheckedSet(index * 10 + index2, value); }); }); } this.refreshCheckedStatus(); } /** 单选 */ singleCheckedChange(index: number, checked: boolean) { this.updateCheckedSet(index, checked); this.refreshCheckedStatus(); } /** 更新勾选状态 */ refreshCheckedStatus(): void { this.allChecked = this.tableList.every((item: any, index: number) => this.setOfCheckedId.has(index)); this.indeterminate = this.tableList.some((item: any, index: number) => this.setOfCheckedId.has(index)) && !this.allChecked; } 含tab切换分组 /** 更新勾选状态设置 */ updateCheckedSet(index: number, checked: boolean): void { if (checked) { this.setOfCheckedId.add(index); } else { this.setOfCheckedId.delete(index); } } /** 全选 */ allCheckedChange(value: boolean) { this.tableList.forEach((item: any, index: number) => this.updateCheckedSet(index, value)); this.refreshCheckedStatus(); } /** 单选 */ singleCheckedChange(index: number, checked: boolean) { this.updateCheckedSet(index, checked); this.refreshCheckedStatus(); } /** 更新勾选状态 */ refreshCheckedStatus(): void { if (this.tabIndex === 0 || this.tabIndex === 1) { this.allChecked = this.tableList1.every((item: any, index: number) => this.setOfCheckedId.has(index)); this.indeterminate = this.tableList1.some((item: any, index: number) => this.setOfCheckedId.has(index)) && !this.allChecked; } else if (this.tabIndex === 2 || this.tabIndex === 3) { const allCheckedList = []; const indeterminateList = []; this.tableList2.forEach((item: any, index: number) => { item.groupList.forEach((item2: any, index2: number) => { allCheckedList.push(this.setOfCheckedId.has(index * 10 + index2)); indeterminateList.push(this.setOfCheckedId.has(index * 10 + index2)); }); }); this.allChecked = allCheckedList.every((item: any) => item === true); this.indeterminate = allCheckedList.some((item: any) => item === true) && !this.allChecked; } } Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-04-01 10:38:51 "},"cordova/cordova.html":{"url":"cordova/cordova.html","title":"cordova","keywords":"","body":"CORDOVA 官网：https://cordova.apache.org/ 安装 npm install -g cordova 创建项目 cordova create [项目名] 平台(browser/android/ios) # 查看平台 cordova platform ls # 安装平台 cordova platform add [平台名] # 移除平台 cordova platform rm [平台名] 运行 cordova run [平台名] 插件 # 查看插件 cordova plugin ls # 添加插件 cordova plugin add [插件名] # 移除插件 cordova plugin rm [插件名] 打包 cordova build android/ios Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-06-07 13:53:09 "},"cordova/插件.html":{"url":"cordova/插件.html","title":"插件","keywords":"","body":"app自动更新 npm install @ionic-native/device @ionic-native/app-version cordova plugin add cordova-plugin-appversion cordova-plugin-app-update 手持高频扫码枪 npm install --save @ionic-native/broadcaster@4 cordova plugin add cordova-plugin-broadcaster 注意事项： import android.support.v4.content.LocalBroadcastManager找不到，需要对broadcaster相关代码进行修改。 参考：https://blog.csdn.net/pecke/article/details/108321888 github：https://github1s.com/bsorrentino/ionic-broadcaster-sample/blob/HEAD/angular-app/android-assets/src/io/ionic/starter/MainActivity.java build.gradle： dependencies{ classpath 'androidx.legacy:legacy-support-v4:1.0.0' } CDVBroadcaster.java: import android.support.v4.content.LocalBroadcastManage 改为： import androidx.localbroadcastmanager.content.LocalBroadcastManager; 移动端扫描 https://www.npmjs.com/package/cordova-plugin-qrbar PDA讯飞语音插件 https://www.ishare5.com/9490439/ 下载地址：https://os-android.liqucn.com/rj/120294.shtml Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-10-29 09:48:35 "},"css/常见问题.html":{"url":"css/常见问题.html","title":"常见问题","keywords":"","body":"子元素位置影响父元素，如margin等 https://blog.51cto.com/u_15082403/3439560 原理：margin折叠 在css2.1盒模型仲规定的内容 因为嵌套也属于毗邻，所以在样式表中优先级更高子元素的margin会覆盖外层父元素定义的margin。 父元素的第一个子元素的上边距margin-top如果碰不到有效的border或者padding.就会不断一层一层的找自己 “领导”(父元素，祖先元素)的麻烦。只要给领导设置个有效的 border或者padding就可以有效的管制这个目无领导的margin防止它越级，假传圣旨，把自己的margin当领导的margin执行。 解决办法： 1、父元素或者子元素使用浮动或者绝对定位。 2、父级设置overflow:hidden 3、父级设置padding（破坏非空白的折叠条件） 4、父级设置border 元素之间默认出现空白问题 https://blog.csdn.net/bidang3275/article/details/121603878 产生间隙的原因 元素被当成行内元素排版的时候，元素之间的空白符（空格、回车换行等）都会被浏览器处理，根据 white-space 的处理方式（默认是 normal ，合并多余空白），所以元素之间就出现了空隙。并且行内元素之间的间距会随着字体的大小而变化，当行内元素 font-size:16px 时，Chrome 浏览器的间距为 8px 。 解决方法【7个】 1、行内元素写在一行 2、行内元素之间加上空白注释 3、父元素的 font-size 设置为 0，子元素单独设置 font-size 4、【不推荐】给行内元素设置【负 margin 】抵消元素间的空白，该方法不通用，因为不同浏览器之间行内元素间隙大小不统一 5、让行内块浮动起来 6、父元素开启 flex 或 grid 布局 7、给父元素设置【负字符间距】 或 【负单词间距】，行内子元素再设置为 0 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-11-03 10:43:25 "},"daily work/app打包及上传.html":{"url":"daily work/app打包及上传.html","title":"app打包及上传","keywords":"","body":"nestapi.rossai.cn/rossapp // 获取所有app应用信息 nestapi.rossai.cn/rossapp // 添加新应用 id: number; app_version: string; app_logo_addr: string; platform_type: string; app_status: number; download_urls: string; app_name: string; used_customers: string; app_device_type: string; package_name: string; remark: string; create_time: Date; update_time: Date; nestapi.rossai.cn/rossapp/update/:id // 更改app应用信息 app_version:x.x.x download_urls:http://cloudpf.weunit.cn/app_download/apk/app仓库名称.apk app_name app_logo_addr ftp上传apk 站点：cloudpf.weunit.cn 密码：Ross_ftp 文件路径：/mnt/nfs-020/yly_docker/www/public/app_download/apk 裁片超市 app对应id：9 文件名：01-cutting-supermarket.apk xml：cp_version.xml 打包环境：caipian-build-env 裁片超市(天守) app对应id：58 文件名：01-cutting-supermarket.apk xml：cp_TianShou_version.xml 打包环境：caipian-build-env 扫码app（scan-app） app对应id：54 文件名：01-scan-app.apk xml：scan_version.xml 打包环境：cordova直接打包，版本修改在config.xml中 wms app对应id：56 文件名：02-pdawms-new.apk xml：wms_version.xml 打包环境：wms-build-env 上线平板 app对应id：46 文件名：02-onlinearrange.apk xml：oa_version.xml 打包环境：cordova直接打包，版本修改在config.xml中 aql app对应id：38 文件名：01-AQL.apk xml：aql_version.xml 打包环境：AQL-build-env Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-08-04 10:34:07 "},"daily work/app条码.html":{"url":"daily work/app条码.html","title":"app条码","keywords":"","body":"WMS 物料收料 i7nbgpmmo 6tzrdwef9s dctmifob4 ojhsilah7 zdkzvx8i3 2soo56d0ln 执料出库 2kwcn5w2cb HBCDPIL2NEWDXKYX 一般出库 I21122300001 R22011900009 R22011900008 R22011900008 R22011900008 R22011900010 OutMatioid 出库单号 ReqMatioid 领料通知单 WwMatioid 生产通知单 库位调整 测试环境： B1-20 的 PD22032408273 调到 G00001 A1-1 的 PD22032408273 调到 A1-2 裁片超市 扫码计件 00100003595 00100003594 0010000330302 0010000330202 0010000330102 0010000330002 00100003759 00100003760 00100003761 00100003762 00100003766 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-08-04 10:34:07 "},"daily work/周报模板.html":{"url":"daily work/周报模板.html","title":"周报模板","keywords":"","body":"周报模板 每周一前发送到赖总和东哥的邮箱 http://mail.ross.com.cn/ 赖总邮箱：lai0001@ross.com.cn 东哥邮箱：ent@ross.com.cn 张总邮箱:zhang0002@ross.com.cn 每周周报要求的内容 本周工作 1.客户项目： 2.软件产品名称： 3.软件版本号 4.开发内容列表和重点技术点 5.相关文档：直接写链接 6.修改发布不同的版本 7.沟通事宜 例子： 一.部门：技术部 二.汇报人：陈柏霖 三.软件产品名称（客户项目）：衣链云 四.软件版本号：R1.20200229 五.开发内容列表 1.新增商城，防疫专区，内衣专区 2.订单微信推送，下单成功后，给管理员或者商家负责人推送信息，给买家推送支付成功信息； 3.订单列表页面，新增取消订单，删除订单，确认收货，查询快递等 4.防疫入口首页修改和底部菜单修改，会员中心跳转路由修改（用于微信菜单增加会员中心，方便在这里进行商家入驻） 6.企业二维码改成个人分享二维码 7.商家后台订单列表修改（类似俏丹娜） 8.新增货到付款，上门自提等快递插件 9.会员中心，增加会员清单（会员中心的我的粉丝，一级粉丝和二级粉丝）； 增加分成清单（会员中心的推广收益）； 个人信息，增加会员角色：店长/会员； 10.商品页面，增加分享利益的浮动提示（接口开发）； 11.下单，付款后，按照分钱模式进行分钱。 12.企业入驻，增加买手/业务经理 13.解决实施反馈的问题 六.重点技术点 分享收益浮动提示采用ion-fab标签 七.沟通事宜 开发细节已和赖总，东哥，刘工等沟通确认 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-08-04 10:34:07 "},"daily work/工作信息.html":{"url":"daily work/工作信息.html","title":"工作信息","keywords":"","body":"日常工作文档 http://markdown.rossai.cn/login?redirect=http%3A%2F%2Fmarkdown.rossai.cn%2Fmember%2Fdoc 账号：广州-罗斯-新手 密码：123456 或 账号：webteam 密码：Ross0000 我的公司邮箱 http://mail.ross.com.cn/alimail/ 账号：liang0608@ross.com.cn 初始密码：Ross1234 禅道(问题跟踪) http://zentao.rossai.cn:38080/index.php http://192.168.1.197:38080/index.php 账号：ross007 密码：ross123456 ross智能库dokuwiki跟工单系统redmine 内网配置： 将doku.ross.210写入hosts文件里 C盘 - > Windows - > System32 - > drivers-> etc - > hosts http://doku.ross.210 外网地址：http://59.41.187.98:10083/ 90ftp 地址:192.168.2.90 账号：0web 密码：0web 许总原型图 https://2yozsg.axshare.com 密码：Rossrandy812 样衣 https://37eg2i.axshare.com 密码：Rossrandy812 飞鹅打印机默认配置 账号：2183558705@qq.com 密钥：ZpeSxTBgSCm6yYkJ 编号：960205439 运程 59.41.187.99:6789 账号：administrator 979152145 111222 远程密码：Ross_ftp 周报 http://markdown.rossai.cn/r/6y7uoz9y2gd8g1ddhlgr git 日志 实时推送到线上 http://192.168.2.208:10081/xrayly/06-yilianyun2018 账号：xrayly 密码：123456 所有项目地址 http://192.168.2.208:3000/xrayly 账号：xrayly 密码：123456 线上仓库 http://zentao.rossai.cn:30001 账号：ross 密码：test1234 本地看板 http://192.168.2.208:3000/xrayly/03-bigDataKanban.git 账号：lkf 密码：111222 开发文档 http://markdown.rossai.cn/r/g2cmdbmrnwdtsv7lesos#12.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE swagger http://cloudpf.weunit.cn:30004/ i9项目 237外网访问地址： http://237i9.rossai.cn:414/i9scm http://237i9.rossai.cn:414/i9mes 内部访问地址： http://192.168.1.237:414/i9scm 内部测试地址： http://192.168.1.115:414/i9scm 220打包地址：http://192.168.1.242:30080 用户名：xrayly 密码：123456 scm升ng14测试地址 http://weunit.rossai.cn/i9scm/ 对应仓库： http://192.168.1.220:3000/xrayly/05-webscm.git 线上看板 http://zentao.rossai.cn:30001/ross/03-bigDataKanban 账号：ross 密码：test1234 智能化数字工厂看板系统 https://www.kdocs.cn/l/ch4aAY0CRjvp http://cloudpf.weunit.cn/cloudpf/KanBanApp/getKanbanList?taxpayerid=91440116726790339T&password=123456&equipment_id=001 企业纳税号：91440116726790339T 企业密码：123456 设备号：001 衣链云项目 本地地址：http://yilianyun2018.test.com/index.php/Admin/Index/index.html 线上地址：http://cloudpf.weunit.cn/index.php/Admin/Index/index.html 账号：admin 密码：111222 产销通 http://markdown.rossai.cn/r/r8nndzarlaw9duwwg1rl http://markdown.rossai.cn/r/nybgfhfohspigoylnevg swagger地址：http://cloudpf.weunit.cn:30004/ 线上地址：http://cloudpf.weunit.cn/productsale/index/ token: d2a0714d8da2160952a21eaba0b05341 apiHost: http://cloudpf.weunit.cn 竞品效果图：http://markdown.rossai.cn/r/8akixzjxr9txwueyljgk 生产排期字段描述：http://markdown.rossai.cn/r/ibjg2fvfaemeg8hrdnpg 验布 http://cloudpf.weunit.cn/erpapp/yanbu/index/login 验布APP使用流程文档：http://markdown.rossai.cn/r/0svzjlmcqphmvgx2klmu#%E7%99%BB%E5%BD%95%E9%A1%B5 衣链云： ip地址：cloudpf.weunit.cn 端口号：80 账号：13503090926 密码：123456 ip地址：cloudpf.weunit.cn 端口号：80 账号：1007 密码：123456 溢丰达： ip地址：59.33.34.118 端口号：50080 账号：系统管理员 密码：9009 面辅料 https://lanhuapp.com/url/4PKN0 APP 打包流程 http://markdown.rossai.cn/r/jdrfucjix4ev0nslep0k 账号：www-data 密码：Ross_ftp 账号：user205 密码：654321 所有 APK 下载 http://cloudpf.weunit.cn/apk/#/ Swagger 与 OpenAPI 文档 https://www.breakyizhan.com/swagger/2994.html IONIC项目测试 账号：13662992256 密码：111222 开发问题分享 http://markdown.rossai.cn/r/qv4t5gjibbuzhqhzrr90 聊天：https://jchat.im.jiguang.cn/#/main https://github.com/jpush/cordova-plugin-jcore 翻墙工具： https://github.com/Alvin9999/new-pac/wiki/ss%E5%85%8D%E8%B4%B9%E8%B4%A6%E5%8F%B7 二哈（公众号管理后台） http://test.rossai.cn/admin/login/index.html 账号：admin 密码：Ross0000 多公众号相关账号说明 http://markdown.rossai.cn/r/4zkufoscgqlqcfrjdvmw 多公众号云工厂说明文档 http://markdown.rossai.cn/r/od5iguobkdwc29rtngej 开发账号及配置 俏丹娜 柏林： 账号：13662992256 密码：111222 谭工： 账号：18102816288 密码：123456 公众号：娜生活 NA LIFE 网页地址：http://kangduoebao.com/sellerapp 衣链云dev 账号：13662992256 密码：111222 上线平板 测试服务器连接地址：r7test.gloria.com.cn:5414 正式服务器环境地址：r7weblogic.gloria.com.cn:5414 咖啡吧数据库：59.41.187.99:6790 李伟建地址：192.168.1.88:8001 工作组：001 用户名：001 员工卡：0001760333 工票卡：0011487460 000000000101 000000000102 000000000103 000000000104 单号：2022040101 Scan.onRocardEvent({cardNo:''}); 咖啡吧 工作组：001 用户名：001 员工卡：0001760333 工票卡：0010861747 拉布APP 配置接口IP：r7test.gloria.com.cn:5414 PO备注：0002575088 咖啡吧：59.41.187.99:6790 卡号：0000080276 拉布操作和接口 http://markdown.rossai.cn/r/zruwteqqke4rq8gemets http://markdown.rossai.cn/r/gxuxjbslaurhelcgmlyl 拉布说明 1.填写备注后点击标题登录 2.如果是刷唛架那些，就不调刷卡登录，刷卡登录是全局的 o2o-sellerapp 账号：13662992256 密码：111222 测试地址：http://o2o.weunit.cn/sellerapp/ 公众号：锵锵服装 o2o-mall 请求地址加”?store_id=2“ 账号：19175888020 密码：111222 上线平板、广告机，拉布不用管 交接地址：http://markdown.rossai.cn/r/hfgujv5ttkaex4oh9mmm PDA型号：ax 6737 65 n PDA WMS 移动仓库 ip：59.41.187.99 端口：6791 账号：RFID 密码： 返工号：0002390914 歌莉娅正式环境： ip：formgly.rossai.cn 端口：8803 账号：吴真 密码：123456 歌莉娅测试环境： ip：testgly.rossai.cn 端口：8889 账号：IT 密码：123456 PC端测试地址： 咖啡吧测试地址：http://59.41.187.99:6789/wmsnew 1段网络直连梁工电脑：http://192.168.2.71/02-pdawms-new/www PDA 天守 MES 裁片超市 ip：59.41.187.99 端口：6790 账号：系统管理员 密码：0000 PC端测试地址： 咖啡吧测试地址：http://59.41.187.99:6789/caipiannew 2段网络直连梁工电脑：http://192.168.2.71/01-cutting-supermarket/www PDA 天守 MES 裁片超市（客户配置） ip：211.143.202.8 端口：5414 账号：系统管理员 密码：0000 返工登记卡号：0002246779 测试账号：罗斯测试 测试密码：0000 PDA 天守 MES 裁片超市（新端口） ip：47.106.144.103 端口：8001 ip:cloudpf.weunit.cn 端口：80 ip:61.142.88.249 端口：5414 50080 账号：系统管理员 密码：0000 演示环境：http://ross.rossai.cn/i9mes 对应ip：http://rossapi.rossai.cn 对应端口：80 验收环境：http://rd.rossai.cn/i9mes 对应ip：http://cloudpf.weunit.cn 对应端口：80 验布（dev） ip：59.33.34.118 端口：50080 账号：系统管理员 密码：9009 收料单号：IN2203-0076 PC端测试地址： 咖啡吧测试地址：http://59.41.187.99:6789/yanbu 2段网络直连梁工电脑：http://192.168.2.71/02-yanbu/www QC巡检（polling） ip：120.238.147.132 端口：5416 账号：rfid 密码： 返工登记卡号：0002246779 ip：cloudpf.weunit.cn 端口：80 账号：罗斯测试 密码：0000 返工登记卡号：0005427105 MES工位机 工作组：001 用户名：Ross 密码：sa 服务器连接地址：59.41.187.99:6790 解锁密码：710289 辉鹏 地址：http://www.rossai.com.cn:6789/www 账号：13662992256 密码：111222 AQL 账号：1007 密码：123456 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-11-30 12:13:06 "},"daily work/开发对照表.html":{"url":"daily work/开发对照表.html","title":"开发对照表","keywords":"","body":"i9scm默认跟进人列表： 1、企划任务/拍照上传/产品墙/成本计价： 前端：叶锐林，后端：颜平 2、款号档案/产品工艺单/样板工艺单/生产订单/加工BOM： 前端：焦工， 后端：蔡贤龙，Linda 3、供应商档案，生产排单，成品加工，成品采购，工艺加工： 前端：梁坤峰，后端：陈柏霖，linda 4、物料计划： 前端：张丞源，后端：张平 5、采购单: 前端：韦泽南，后端：朱立合 5、收料单: 前端：张丞源，后端：张平 6、入库单: 前端：张丞源，后端：黄海斌 7、采购结算单: 前端：韦泽南，后端：黄海斌，梁云 8、加工收货: 前端：叶锐林，后端：朱立合 9、加工入库: 前端：叶锐林，后端：朱立合 10、加工结算: 前端：韦泽南，后端：黄海斌，梁云 11、领料通知: 前端：叶锐林，后端：杨磊 12、领料出库: 前端：叶锐林，后端：杨磊 13、原料加工单: 前端：韦泽南，后端：杨磊 14、原料加工领料: 前端：叶锐林，后端：杨磊 15、原料加工收料: 前端：张丞源，后端：颜平 16、原料加工入库: 前端：张丞源，后端：颜平 17、原料加工结算: 前端：韦泽南，后端：颜平 18、主料检验: 前端：何梓贤，后端：吴燕兵 19、辅料检验: 前端：何梓贤，后端：吴燕兵 20、一般入库: 前端：张丞源，后端：杨磊 21、开发进度: 前端：陆同乐，后端：吴燕兵 22、生产排期: 前端：陆同乐，后端：吴燕兵 23、生产协同: 前端：陆同乐，后端：吴燕兵 24、一般出库: 前端：陈俊宇，后端：张平 25、物料调拨: 前端：陈俊宇，后端：杨磊 26、销售出库: 前端：叶锐林，后端：张平,李振兴 27、销售结算: 前端：韦泽南，后端：黄海斌，梁云 28、备料计划: 前端：叶锐林，后端：张平 29、请购单: 前端：韦泽南，后端：黄海斌 30、微信推送: 前端：陈伯林，后端：黄海波 31、主料档案、辅料档案: 前端：韦泽南，后端：黄海波 32、自定义报表平台 前端：叶锐林，后端：李振兴 33、自定义菜单 前端：梁坤峰，后端：李振兴 34、成品调拨 前端：张丞源，后端：黄海波 35、加工登记: 前端：叶锐林，后端：李伟健 36、应收管理 前端：张丞源，后端：杨磊 37、应付管理 前端：陈俊宇，后端：黄海斌 38、跟单成本核算 前端：张丞源 后端：黄海斌 39、板房APP、样衣APP 前端：梁坤峰 后端：陈柏霖 40、WMS 前端：梁坤峰/陈俊宇 后端：朱立合 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-09-24 11:16:08 "},"daily work/微信推送.html":{"url":"daily work/微信推送.html","title":"微信推送","keywords":"","body":"微信推送 test.rossai.cn/weapp/Wechat/getPushMessageDetail：企业微信端获取详情接口。 test.rossai.cn/mp/MultipleWechat/getPushMessageDetail：微信公众号端获取详情接口。 id:1300 token:3877151c4f6e58e923fd3be2928f8d41 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-10-11 10:11:49 "},"daily work/项目推送.html":{"url":"daily work/项目推送.html","title":"项目推送","keywords":"","body":"前后端一起 ssh user209@192.168.1.209 bash /home/user209/mnt/rsync_menu.sh 测试到生产的命令 密码：123456 0 -- 到沙箱 1.2.3 到客户 如果不选123，就客户自动拉 --后端 ssh user209@192.168.1.209 bash /home/user209/mnt/rsync_backend.sh 密码：123456 0 -- 到沙箱 1.2.3 到客户 如果不选123，就客户自动拉 http://weunitscm.rossai.cn/i9 ylyadmin/111222 # 中山同益 http://14.118.134.30:8081/i9scm 数据库：i9fs， 账套：发饰事业部 tyfsadmin 111222 # 推送 ssh user209@192.168.1.209 bash /home/user209/mnt/rsync_tongyi.sh 密码123456 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-09-21 19:16:27 "},"git/常用命令.html":{"url":"git/常用命令.html","title":"常用命令","keywords":"","body":"全局信息配置 git config --global user.name \"\" git config --global user.email \"\" 局部信息配置 git config user.name \"\" git config user.email \"\" 查看设置 git config --list 或 git config --system --list # 查看系统配置 git config --global --list # 查看全局配置 git config --local --list # 查看本地仓库配置 删除本地缓存 git rm -r --cached . 查看分支 git branch -a 查看所有分支 git branch -r 查看远程分支 git branch 查看本地分支 格式化日志 git log --pretty=oneline git log --pretty=format:\"%h - %an, %ar : %s\" git log --pretty=format:\"%an %ae %ad %cn %ce %cd %cr %s\" # git log --author lkf --pretty=format:\"%cr %s\" 以theirs方式合并指定分支 git merge --strategy-option=theirs origin/xxx 取消合并 git merge --abort 撤销合并 git reset --soft: 将分支回退到指定提交，工作区维持现状不变,暂存区会在现有基础上增加该commit之后的提交。 git reset --mixed: （默认操作）将分支回退到指定提交，暂存区也被同步为该指定提交，工作区保持不变。 git reset --hard: 将分支回退到指定分支，暂存区和工作区都会被同步为该指定的提交。 拉取远程指定分支 git clone -b 远程分支名 远程地址 push 远程指定分支（未创建） git push --set-upstream origin xxx 强推并覆盖远程分支（提交记录会被清掉） git push origin xxx --force 拉取一条本地不存在的分支，并关联起来 git checkout -b 本地分支名 origin/远程分支名 删除本地分支 git branch -D xxx 恢复本地分支 git checkout -b 删除的分支名 删除的commitid 删除远程分支 1.查看远程分支 git branch -a 2.切换到查看到的远程分支（remotes/origin/HEAD -> origin/master） git checkout master 3.执行删除 git push origin --delete 远程分支 回滚指定版本并覆盖远程 git reset --hard xxx git push --force # 强制覆盖到远程，会将日志重置到指定版本 强制拉取覆盖本地： git fetch --all git reset --hard origin/master git pull 分支覆盖：（将 dev 覆盖到 master 分支） git checkout master git reset --hard origin/dev git push -f 添加钩子 git remote add origin [git地址] git push -u origin master git 切换到远程分支（remote后需要关联到指定分支操作） git branch xxx git checkout xxx 切换到第二个分支 git branch --set-upstream-to origin/xxx 关联到第二个分支 git log --graph --decorate --oneline --simplify-by-decoration --all 显示分支图，找到远程分支的开始节点 git reset --hard *** 切换到远程分支 xxx 的工作目录，这时候就可以正常使用了 将其他分支所有日志与当前分支合并 参考： https://www.cnblogs.com/coderxx/p/11544550.html git checkout dev git merge dev_add --no-ff Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-11-21 09:41:14 "},"git/里程碑.html":{"url":"git/里程碑.html","title":"里程碑","keywords":"","body":"里程碑(tags) 描述 里程碑就是Git中的tag，tag是与某个具体的提交（commit）关联的，使用里程碑的好处在于可以直观的看到版本的演变历史，而不是简单生硬的commit id。里程碑的命令是git tag，可以创建、删除和查看里程碑。 查看标签 git ls-remote --tags origin # 查看远程所有标签 git tag -l # 查看本地所有标签 创建标签 # 方式一: 默认 `HEAD` 指向的版本 git tag 标签名 # 方式二: 指定 `commit_id` 表示的版本 git tag 标签名 [] # 方式三: 指定 `commit_id` 表示的版本,同时创建标签说明信息 git tag -a 标签名 -m 提交信息 [] 删除标签 远程： git push origin :refs/tags/标签名 # 推送并删除远程标签，只能单个删除 git push origin -d tag 标签名 # git v1.7.0 之后支持该写法，可同时推送并删除多个tag 本地： git tag -d 标签名 推送标签 git push origin --tags # 推送所有标签 git push origin 标签名 # 推送单个标签 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-03-30 13:26:32 "},"ionic/ionic.html":{"url":"ionic/ionic.html","title":"ionic","keywords":"","body":"ionic（移动端UI） 官网地址：https://ionicframework.com/ 兼容 ios|android(md) 系统 安装 npm install -g @ionic/cli 创建项目 ionic start --list ionic start 项目名称 ionic start 项目名称 blank ionic start 项目名称 tabs --cordova ionic start 项目名称 tabs --capacitor ionic start 项目名称 super --type=ionic-angular ionic start 项目名称 blank --type=ionic1 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-07-15 17:09:44 "},"ionic/开发问题.html":{"url":"ionic/开发问题.html","title":"开发问题","keywords":"","body":"打包apk，页面被上移 http://www.wjhsh.net/share901124-p-7645324.html Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-10-14 10:28:01 "},"javascript/css文件转行内样式.html":{"url":"javascript/css文件转行内样式.html","title":"css文件转行内样式","keywords":"","body":"css文件转行内样式（打印机使用） https://github.com/jonkemp/inline-css var inlineCss = require('inline-css'); var html = ``; inlineCss(html,{url:'/'}).then(function(html) { console.log(html); }); Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-07-13 09:33:12 "},"javascript/DOM对象属性、鼠标事件.html":{"url":"javascript/DOM对象属性、鼠标事件.html","title":"DOM对象属性、鼠标事件","keywords":"","body":"DOM 对象属性 clientWidth、clientHeight clientWidth：width(样式中设置的) + 左右padding - 垂直滚动条宽度 clientHeight：height(样式中设置的) + 上下padding - 水平滚动条宽度 offsetWidth、offsetHeight 只与当前元素有关，与其他元素无关 offsetWidth：width(样式中设置的) + 左右padding + 左右border offsetHeight：height(样式中设置的) + 上下padding + 上下border offsetParent offsetParent属性返回一个对象的引用，这个对象是距离调用offsetParent的元素最近的（在包含层次中最靠近的），并且是已进行过CSS定位的容器元素。 如果这个容器元素未进行CSS定位, 则offsetParent属性的取值为根元素的引用 1、如果当前元素的父级元素没有进行CSS定位（position为absolute或relative），offsetParent为body。 2、如果当前元素的父级元素中有CSS定位（position为absolute或relative），offsetParent取最近的那个父级元素。 offsetTop、offsetLeft 与 offsetWidth 和 offsetHeight不同的是，它们受到 offsetParent 的影响 offsetLeft：(offsetParent的padding-left) + (中间元素的offsetWidth) + (当前元素的margin-left) offsetTop：(offsetParent的padding-top) + (中间元素的offsetHeight) + (当前元素的margin-top) scrollWidth、scrollHeight scrollWidth 可视区域宽度 + 被隐藏区域宽度 scrollHeight 可视区域高度 + 被隐藏区域高度 scrollTop、scrollLeft scrollTop：对象的最顶部到对象在当前窗口显示的范围内的顶边的距离，即在出现了纵向滚动条的情况下，滚动条拉动的距离 scrollLeft：对象的最左边到对象在当前窗口显示的范围内的左边的距离，即在出现了横向滚动条的情况下，滚动条拉动的距离 鼠标事件 onclick 鼠标点击事件 box.onclick = function(e){ console.log(e) } onmousedown 鼠标按下事件 box.onmousedown = function(e){ console.log(e) } onmouseup 鼠标松开事件 box.onmouseup = function(e){ console.log(e) } onmousemove 鼠标移动事件 box.onmousemove = function(e){ console.log(e) } onmouseover 鼠标经过事件 box.onmouseover = function(e){ console.log(e) } onmouseout 鼠标划出事件 box.onmouseout = function(e){ console.log(e) } 一、clientX、clientY 点击位置距离当前body可视区域的x，y坐标 二、pageX、pageY 对于整个页面来说，包括了被卷去的body部分的长度 三、screenX、screenY 点击位置距离当前电脑屏幕的x，y坐标 四、offsetX、offsetY 相对于带有定位的父盒子的x，y坐标 五、x、y 和screenX、screenY一样 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-07-13 10:13:48 "},"javascript/excel导出.html":{"url":"javascript/excel导出.html","title":"excel导出","keywords":"","body":"excel导出 官方中文文档：https://github.com/exceljs/exceljs/blob/master/README_zh.md Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-08-04 10:34:07 "},"javascript/pdf文本获取.html":{"url":"javascript/pdf文本获取.html","title":"pdf文本获取","keywords":"","body":"pdf文本获取 参考：https://qa.1r1g.com/sf/ask/2844518561/ work工作区配置：https://www.aciuz.com/tech/PDF-js-workerSrc.html 注：pdf文件必须存放在服务器上，不能获取file://协议文件，会提示跨域。 const pdfUrl = 'http://192.168.1.71/files/c.pdf'; function getText(pdfUrl) { var loadingTask = pdfjsLib.getDocument(pdfUrl); return loadingTask.promise.then((pdf) => { // 获取页数 const pageNum = pdf._pdfInfo.numPages; const countPromises = []; for (let index = 1; index { // 获取文本 const data = res.getTextContent(); return data.then((text) => { return text.items.map((item, i) => { return item.str; }).join(``); }); })); } console.log(countPromises); return Promise.all(countPromises).then((res) => { return res.join(''); }); }); } getText(pdfUrl).then((res) => { console.log(res); }, (err) => { console.log(err); }); Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-08-20 11:15:22 "},"javascript/前端实用方法.html":{"url":"javascript/前端实用方法.html","title":"前端实用方法","keywords":"","body":"获取文件的base64 return new Promise((resolve, reject) => { const render = new FileReader(); reader.readAsDataURL(file); reader.onload = () => resolve(reader.result); reader.onerror = error => reject(error); }) base64转文件 /** 将base64转换为文件 */ function dataURLtoFile(base64) { var arr = base64.split(','), bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while (n--) { u8arr[n] = bstr.charCodeAt(n) } let file = { name: String(new Date().getTime()), type: arr[0].match(/:(.*?);/)[1] }; return new File([u8arr], file.name, { type: file.type }) } 生成guid function guid() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) { const r = Math.random() * 16 | 0; const v = c == 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); } Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-10-21 14:17:54 "},"javascript/实用工具.html":{"url":"javascript/实用工具.html","title":"实用工具","keywords":"","body":"smms图床 官网：https://smms.app/ API文档：https://doc.sm.ms/ markdown配置： https://blog.csdn.net/spongebob0018/article/details/122748701 上传失败处理： 修改picgo的smms插件请求地址 https://www.bilibili.com/video/BV17D4y167ue/?vd_source=1390a41caddc0c842b1b8449237f0024 具体操作： 1.打开C:\\Users\\CodeFront\\AppData\\Roaming\\picgo\\node_modules\\picgo-plugin-smms-user\\src\\index.js https://sm.ms修改为https://smms.app 2.在C:\\Users\\CodeFront\\AppData\\Roaming\\picgo目录下克隆 picgo-plugin-smms-user （git clone https://github.com/xlzy520/picgo-plugin-smms-user.git）插件，执行 npm install ./picgo-plugin-smms-user，并重启 PicGO 图床工具 PicGO图床工具 下载页面：https://github.com/Molunerfinn/picgo/releases 下载地址：https://github.com/Molunerfinn/ cdnjs 仓库 https://cdnjs.com/ 编程电子书 itdevbooks dragula 拖拽 https://github.com/bevacqua/dragula 示例：https://valor-software.com/ng2-dragula/index.html 表单解析器：https://github.com/JakHuang/form-generator/issues/32 ng2-dragula 拖拽 https://github.com/valor-software/ng2-dragula#readmebai 自定义拖拽插件原理解析：https://juejin.cn/post/6908502083075325959 angular项目地址：https://gitee.com/codefront/from-design-angular // 解决ng2-dragula插件不拖拽阴影导致的节点报错 // https://github.com/valor-software/ng2-dragula/issues/487 .gu-transit { pointer-events: none; } Exif.js获取图像元数据 http://code.ciaoca.com/javascript/exif-js/ GitLab 使用 GitLab - 芒果文档 (imangodoc.com) pdf转其他格式文件 https://www.hipdf.cn/ notepadd++添加至右键菜单 reg add \"hkey_classes_root\\*\\shell\\notepad++\" /t reg_sz /v \"\" /d \"notepad++ 编辑\" /f VSCode添加至右键菜单 https://blog.csdn.net/assassinator_567/article/details/106719647 Monaco Editor(代码编辑器) https://github.com/microsoft/monaco-editor 注：配置后格式化未生效，需添加定时器延迟触发更新 setTimeout(() => { const code = this.editorRef.editor?.getValue(); this.editorRef.editor?.getAction('editor.action.formatDocument').run(); this.editorRef.editor?.setValue(code); }, 1200); // 配置信息 const option = { value: '', // 编辑器初始显示文字 language: 'sql', // 语言支持自行查阅demo automaticLayout: true, // 自动布局 foldingStrategy: 'indentation', // 代码可分小段折叠 autoClosingBrackets: 'always', // 是否自动添加结束括号(包括中括号) \"always\" | \"languageDefined\" | \"beforeWhitespace\" | \"never\" autoClosingDelete: 'always', // 是否自动删除结束括号(包括中括号) \"always\" | \"never\" | \"auto\" autoClosingQuotes: 'always', // 是否自动添加结束的单引号 双引号 \"always\" | \"languageDefined\" | \"beforeWhitespace\" | \"never\" autoIndent: 'None', // 控制编辑器在用户键入、粘贴、移动或缩进行时是否应自动调整缩进 comments: { ignoreEmptyLines: true, // 插入行注释时忽略空行。默认为真。 insertSpace: true // 在行注释标记之后和块注释标记内插入一个空格。默认为真。 }, // 注释配置 cursorBlinking: 'Solid', // 光标动画样式 cursorSmoothCaretAnimation: true, // 是否启用光标平滑插入动画 当你在快速输入文字的时候 光标是直接平滑的移动还是直接\"闪现\"到当前文字所处位置 cursorSurroundingLines: 0, // 光标环绕行数 当文字输入超过屏幕时 可以看见右侧滚动条中光标所处位置是在滚动条中间还是顶部还是底部 即光标环绕行数 环绕行数越大 光标在滚动条中位置越居中 cursorSurroundingLinesStyle: 'all', // \"default\" | \"all\" 光标环绕样式 cursorWidth: 2, // Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-12-02 09:34:08 "},"javascript/粘贴板.html":{"url":"javascript/粘贴板.html","title":"粘贴板","keywords":"","body":"从粘贴板复制图片并自定义上传 参考： https://developer.aliyun.com/article/980183 http://www.deathghost.cn/article/javascript/89 import { Component, EventEmitter, Input, OnInit, Output } from '@angular/core'; import { CommonService } from '../../services/common.service'; @Component({ selector: 'btn-clipboard-upload', template: ` 从剪贴板上传 ` }) export class BtnBoardUploadComponent implements OnInit { //正在上传 @Input() isLoading = false; /** 是否转图片 */ @Input() toFile = false; /** 解析触发事件 */ @Output() pasteChange = new EventEmitter; constructor( private commonService: CommonService ) { } ngOnInit(): void { } getFromClipboard(e) { // 浏览器安全检测 if (window.isSecureContext) { // 查找具体类型状态 window.event ? window.event.cancelBubble = true : e.stopPropagation(); let flag = false; navigator.clipboard.read().then((clipboardItems) => { const reader = new FileReader(); clipboardItems.forEach((clipboardItem: any) => { clipboardItem.types.forEach(async (type: any) => { if (type === 'image/png') { flag = true; const blob = await clipboardItem.getType(type); reader.readAsDataURL(blob); reader.onload = (event) => { const base64Str = event.target.result; this.toFile ? this.pasteChange.emit(this.dataURLtoFile(base64Str)) : base64Str; } } }); }) if (!flag) { this.commonService.notificationInfo({ type: 'info', content: '未获取到粘贴板数据' }) } }).catch((error) => { console.log(error) this.commonService.notificationInfo({ type: 'info', content: '粘贴板数据不符，请重新复制' }) }); } else { this.commonService.notificationInfo({ type: 'info', content: '您的浏览器因安全性问题，禁用了功能，请检查并使用安全性的域名' }) } } /** 将base64转换为文件 */ dataURLtoFile(base64) { var arr = base64.split(','), bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while (n--) { u8arr[n] = bstr.charCodeAt(n) } let file = { name: String(new Date().getTime() + '.png'), type: arr[0].match(/:(.*?);/)[1] }; return new File([u8arr], file.name, { type: file.type }) } } 父组件 /** 粘贴板 */ pasteChange(e: any){ console.log(e); } 浏览器安全问题，无法使用 https://developer.mozilla.org/zh-CN/docs/Web/Security/Secure_Contexts // 浏览器安全检测 if (window.isSecureContext) { ... } 其他代码实现： 可粘贴图片不能使用input、textarea等元素，使用div元素，并添加 contenteditable=true 属性即可。 /** 创建元素 */ // const dom = document.createElement('div'); // dom.setAttribute('contenteditable', 'true'); // dom.style.display = 'none'; // console.log(dom) // /** 添加监听事件 */ // dom.addEventListener('paste', (e: any) => { // const data = e.clipboardData || window['clipboardData']; // const blob = data.items[0].getAsFile(); // // 判断是不是图片，最好通过文件类型判断 // const isImg = (blob && 1) || -1; // const reader = new FileReader(); // if (isImg >= 0) { // reader.readAsDataURL(blob); // reader.onload = (event) => { // const base64Str = event.target.result; // fileList.push(base64Str); // } // } else { // if (!(e.clipboardData && e.clipboardData.items)) { // console.log('没有粘贴到内容') // return; // } // for (let i = 0, len = e.clipboardData.items.length; i { // strList.push(str); // }) // } else if (item.kind === \"file\") { // reader.readAsDataURL(item.getAsFile()); // reader.onload = (event) => { // const base64Str = event.target.result; // fileList.push(base64Str); // } // } // } // } // console.log(222) // document.body.removeChild(dom); // this.pasteChange.emit({ // strList, // fileList // }); // }) // document.body.appendChild(dom); // dom.focus(); // document.execCommand('paste'); Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-10-22 10:10:59 "},"js特效/特效.html":{"url":"js特效/特效.html","title":"特效","keywords":"","body":"粒子特效 https://github.com/VincentGarreau/particles.js 鼠标点击烟花效果 雪花特效 音乐播放器 离开页面改变title var time; var normar_title=document.title; document.addEventListener('visibilitychange', function () { if (document.visibilityState == 'hidden') { clearTimeout(time); document.title = '又是分手的一天ε=ε=ε=┏(゜ロ゜;)┛'; } else { document.title = '你终于回来了(。・∀・)ノ'; time=setTimeout(function(){ document.title = normar_title; }, 3000); } }); Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-01-04 11:22:10 "},"mysql/mysql学习.html":{"url":"mysql/mysql学习.html","title":"mysql学习","keywords":"","body":"MySQL学习 数据库存储数据的特点 1.将数据放到表中，表再放到库中 2.一个数据库中可以有多个表，每个表都有一个名字，用来标识自己，表明具有唯一性 3.表具有一些特性，这些特性定义了数据在表中如何存储，类似 java 中 ”类“ 的设计 4.表由列组成，我们也成为字段。所有表都由一个或多个列组成的，每一列类似 java 的 ”属性“ 5.表中的数据是按行存储的，每一行类似于 java 的 ”对象“ 下载 https://dev.mysql.com/downloads/mysql 社区版（免费） 企业版（收费） MySQL 8.0 报错解决 参考：https://stackoverflow.com/questions/50093144/mysql-8-0-client-does-not-support-authentication-protocol-requested-by-server express mysql 登录 mysql 并分别执行以下代码： alter user 'root'@'localhost' identified with mysql_native_password by '密码'; flush privileges; 启动和停止 mysql 服务 1.右击计算机 - 管理 - 服务和应用程序 - 服务 2.打开 cmd（管理员身份） 开启：net start [mysql名称] 停止：net stop [mysql名称] 数据库连接和退出 1.连接（cmd方式） -h：主机 -P（必须大写）：端口 -u：用户名 -p 密码 方式一：mysql -h localhost -P 3306 -u root -p 密码 方式二（连本机，默认端口3306）： mysql -u root -p 密码 2.退出 方式一：exit 方式二：按 2 次 ctrl + c MySQL的常见命令 1.查看当前所有的数据库 show databases; 2.打开指定的库 use 库名 3.查看当前库的所有表 show tables; 4.查看其他库的所有表 show tables form 库名； 5.创建表 create table 表名{ 列名 列类型, 列名 列类型, ... }; 6.查看表结构 desc 表名; 7.查看服务器的版本 方式一：登录到mysql服务端 select version(); 方式二：没有登录到mysql服务端 mysql --version 或 mysql --V MySQL的语法规范 1.不区分大小写，建议关键字大写，表名、列名小写 2.每条命令最好用分号结尾 3.每条命令根据需要，可进行缩进或换行 4.注释 单行：#注释文字 单行：-- 注释文字 多行：/* 注释文字 */ DQL语言（数据查询语言） 基础查询 条件查询 排序查询 常见函数 分组函数 分组查询 链接查询 子查询 分页查询 union联合查询 DML语言（数据操作语言） 插入语句 修改语句 删除语句 DDL语言（数据定义语言） 库和表的管理 常见数据类型介绍 常见约束 TCL语言（事务控制语言） 事务和事务处理 SELECT 语法：SELECT 查询列表 FROM 表名; 特点： 1、查询列表可以是：表中的字段、常量值、表达式、函数 2、查询的结果是一个虚拟表格 起别名 1.SELECT 字段名 AS 别名 FROM 表名; 2.使用空格：SELECT 字段名 别名 FROM 表名; 去重(DISTINCT) SELECT DISTINCT 字段名 FROM 表名; 连接(CONCAT) SELECT CONCAT(str1,str2,...) AS 别名 FROM 表名; 判断(IFNULL) SELECT IFNULL(expr1,expr2) AS 别名 FROM 表名; 查看表结构 DESC 表名; 条件查询 语法： SELECT 查询列表 FROM 表名 WHERE 筛选条件; 分类： 一、按条件表达式筛选 > >= 查询第几个字符，使用 \"_\" 通配符 SELECT 查询列表 FROM 表名 WHERE 列名 LIKE '__n_l%'; 查询含有 \"_\" 字符，需转义 SELECT 查询列表 FROM 表名 WHERE 列名 LIKE '_\\_%'; 或者 SELECT 查询列表 FROM 表名 WHERE 列名 LIKE '_$_%' ESCAPE '$'; IN SELECT 查询列表 FROM 表名 WHERE 列名 IN (值1,值2,...); ISNULL、IS NOT NULL SELECT 查询列表 FROM 表名 WHERE ISNULL(列名); SELECT 查询列表 FROM 表名 WHERE 列名 IS NOT NULL; 安全等于 SELECT 列名 FROM 表名 WHERE 列名 值; 排序 语法: SELECT 查询列表 FROM 表名 [WHERE 筛选条件] ORDER BY 排序列表 [ASC|DESC], 排序列表 [ASC|DESC], ...; 特点： 1.ASC 代表升序，DESC 代表降序。不写默认升序。 2.ORDER BY 子句支持单个字段、多个字段、表达式、函数、别名。 3.ORDER BY 子句以一般是放在查询语句的最后，limit 子句除外。 函数 概念：将一组逻辑语句封装在方法体中，对外暴露方法名。 好处： 1.隐藏了实现细节 2.提高代码的重用性 调用：SELECT 函数名(参数列表) [FROM 表名]; 分类： 1.普通函数 字符函数 数学函数 日期函数 其他函数 流程控制函数 2.分组函数 功能：做统计使用，又称为统计函数、聚合函数、组函数 查看字符集： SHOW VARIABLES LIKE '%char%'; 字符函数 -- LENGTH 长度 SELECT LENGTH(str); -- UPPER 转大写 SELECT UPPER(str); -- LOWER 转小写 SELECT LOWER(str); -- CONCAT 拼接 SELECT CONCAT(str,str,...); -- SUBSTR 字符串截取 SELECT SUBSTR(str,start,[end]); -- INSTR 获取字符所在位置 SELECT INSTR(str,str); -- TRIM 去左右字符 SELECT TRIM(str); -- LPAD 左填充 SELECT LPAD(str,填充个数,填充字符); -- RPAD 右填充 SELECT RPAD(str,填充个数,填充字符); -- EPLACE 替换 SELECT EPLACE(str,需要替换的字符,替换后的字符); 数学函数 -- ROUND 四舍五入 SELECT ROUND(数值); SELECT ROUND(数值,保留位数); -- CEIL 向上取整 SELECT CEIL(数值); -- FLOOR 向下取整 SELECT FLOOR(数值); -- TRUNCATE 截断 SELECT TRUNCATE(小数,截断位数); -- MOD 取余 SELECT MOD(被除数,除数); 日期函数 %Y：年（4位） %y：年（2位） %m：月（2位）(01,02...11,12) %c：月（1位）(1,2...11,12) %d：日（2位）(01,02...) %H：小时（24小时制） %h：小时（12小时制） %i：分钟(01,02...) %s：秒(01,02...) -- 返回当前系统日期+时间 SELECT NOW(); -- CURDATE 返回当前系统日期，不包含时间 SELECT CURDATE(); -- CURTIME 返回当前时间，不包含日期 SELECT CURTIME(); -- 获取指定的部分，年月日时分秒 SELECT YEAR(NOW()) 年; SELECT YEAR('1994-9-28') 年; SELECT MONTH(NOW()) 月; -- 英文名 SELECT MONTHNAME(NOW()) 月; -- STR_TO_DATE 将日期格式的字符转换成指定的日期格式 YYYY-MM-DD SELECT STR_TO_DATE('1994-9-28','%Y-%c-%d'); SELECT STR_TO_DATE('9-28 1994','%c-%d %Y'); -- DATE_FORMAT 将日期转换成字符串 SELECT DATE_FORMAT(NOW(),'%Y年%m月%d日'); 其他函数 SELECT VERSION(); // 查看mysql版本 SELECT DATABASE(); // 查看当前数据库 SELECT USER(); // 查看当前库的用户 流程控制函数 -- IF 函数 SELECT IF(10>5,'大','小'); -- CASE 函数 /* 用法一：(类同 switch) case 要判断的字段或表达式 when 常量1 then 要显示的值1或语句1; when 常量2 then 要显示的值2或语句2; ... else 要显示的值n或语句n; end 用法二：（类同 if） case when 条件1 then 要显示的值1或语句1; when 条件2 then 要显示的值2或语句2; ... else 要显示的值n或语句n; end */ SELECT salary,department_id, CASE department_id WHEN 30 THEN salary*1.1 WHEN 40 THEN salary*1.2 WHEN 50 THEN salary*1.3 END AS 新工资 FROM employees; SELECT salary, CASE WHEN salary>20000 THEN 'A' WHEN salary>15000 THEN 'B' WHEN salary>10000 THEN 'C' ELSE 'D' END AS 工资等级 FROM employees; 分组函数 /* 功能：用作统计使用，又称为聚合函数或统计函数或组函数 分类： sum 求和、avg 平均值、max 最大值、min 最小值、count 计算个数 特点： 1、sum、avg 一般用于处理数值型 max、min、count 可以处理任何类型 2、以上文组函数都忽略 null 值 3、可以和 DISTINCT 搭配实现去重 4、count 函数单独介绍 一般使用count(*)用作统计行数 5、和分组函数一同查询的字段要求是 group by 后的字段 */ SELECT SUM(字段名) FROM 表名; SELECT AVG(字段名) FROM 表名; SELECT MIN(字段名) FROM 表名; SELECT MAX(字段名) FROM 表名; SELECT COUNT(字段名) FROM 表名; # 配合 DISTINCT 实现去重 SELECT SUM(DISTINCT 字段名) FROM 表名; SELECT COUNT(DISTINCT 字段名) FROM 表名; # count 函数的详细介绍 # 当前行任意一个属性部位null，则统计当前行，以下效果一样 SELECT COUNT(*) FROM 表名; SELECT COUNT(1) FROM 表名; SELECT COUNT(2) FROM 表名; # 效率 MYISAM 存储引擎下，COUNT(*) 的效率高 INNODB 存储引擎下，COUNT(*) 和 COUNT(1) 的效果差不多，比 COUNT(字段) 要高一些 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-05-13 15:06:17 "},"node package manage/npm.html":{"url":"node package manage/npm.html","title":"npm","keywords":"","body":"npm（Node Page Manage） 查看全局安装的依赖 npm list -g --depth 0 镜像源（查看/设置） # 查看 npm get registry # 设置 npm set registry http://registry.npmjs.org # npm源 npm set registry http://registry.npm.taobao.org # 淘宝源 安装pkg npm install (with no args, in package dir) npm install [/] npm install [/]@ npm install [/]@ npm install [/]@ npm install @npm: npm install npm install npm install npm install npm install / aliases: i, isntall, add common options: [--save-prod|--save-dev|--save-optional] [--save-exact] [--no-save] 卸载 npm uninstall [/][@]... [--save-prod|--save-dev|--save-optional] [--no-save] Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-08-04 10:34:07 "},"node package manage/nvm.html":{"url":"node package manage/nvm.html","title":"nvm","keywords":"","body":"nvm（Node Version Manage） github releases 地址：https://github.com/coreybutler/nvm-windows/releases 注：不同版本对系统安装有影响，例如v1.1.7之后安装后会报错，提示安装路径不能含有空格等。 查看所有版本 nvm ls 添加/卸载指定版本 nvm install nvm uninstall 使用（切换）版本 nvm use [version] 解决镜像下载过慢问题 参考：https://blog.csdn.net/qq_32754575/article/details/102412473 where nvm 找到nvm安装路径 找到settings.txt文件, 并添加以下代码 node_mirror: https://npm.taobao.org/mirrors/node/ npm_mirror: https://npm.taobao.org/mirrors/npm/ Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-08-04 10:34:07 "},"node package manage/pnpm.html":{"url":"node package manage/pnpm.html","title":"pnpm","keywords":"","body":"pnpm 官网地址：https://www.pnpm.cn/ 注：请使用@6版本，@7版本全局添加命令异常 npm install -g pnpm@6 pnpm add -g [package] 节省磁盘空间并提升安装速度 快速 比传统方案安装包的速度快了两倍，以下是官方给出的benchmarks，在多种常见情况下，执行install的速度比较。 安装 npm install -g pnpm 注：全局安装的包，在同级包管理器下是共享访问的。 升级 一旦安装完 pnpm 之后，就无需使用其它软件包管理器来更新 pnpm 了。 你可以让 pnpm 自己来更新自己，如下所示： pnpm add -g pnpm 兼容性 Node.js pnpm 4 pnpm 5 pnpm 6 pnpm 7 Node.js 10 ✔️ ✔️ ❌ ❌ Node.js 12 ✔️ ✔️ ✔️ ❌ Node.js 14 ✔️ ✔️ ✔️ ✔️ Node.js 16 ?️ ?️ ✔️ ✔️ Node.js 18 ?️ ?️ ✔️ ✔️ Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-09-19 09:38:02 "},"node package manage/其他.html":{"url":"node package manage/其他.html","title":"其他","keywords":"","body":"npm link https://cloud.tencent.com/developer/article/1878795 npm 包版本号划分 https://juejin.cn/post/7000396951392878628 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-08-30 10:30:23 "},"pda/broadcast广播.html":{"url":"pda/broadcast广播.html","title":"broadcast广播","keywords":"","body":"broadcast 广播 新pda //刷卡 //注册广播 IntentFilter LfDataIntentFilter = new IntentFilter(); LfDataIntentFilter.addAction(\"ACTION_BAR_LF\"); registerReceiver(mLfDataReceiver, LfDataIntentFilter); //注销广播 unregisterReceiver(mLfDataReceiver); //数据接收 private BroadcastReceiver mScanDataReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub String action = intent.getAction(); if (action.equals(\"ACTION_BAR_SCAN\")) { String str = intent.getStringExtra(\"EXTRA_SCAN_DATA\"); // str : barcode appView.loadUrl(\"javascript:Scan.ScanBar('\"+str+\"',1)\"); } } }; //扫描 //注册广播 IntentFilter scanDataIntentFilter = new IntentFilter(); scanDataIntentFilter.addAction(\"ACTION_BAR_SCAN\"); registerReceiver(mScanDataReceiver, scanDataIntentFilter); //注销广播 unregisterReceiver(mScanDataReceiver); //数据接收 private BroadcastReceiver mScanDataReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub String action = intent.getAction(); if (action.equals(\"ACTION_BAR_SCAN\")) { String str = intent.getStringExtra(\"EXTRA_SCAN_DATA\"); // str : barcode appView.loadUrl(\"javascript:Scan.ScanBar('\"+str+\"',0)\"); } } }; 高频pda //刷卡 //注册广播 IntentFilter LfDataIntentFilter = new IntentFilter(); LfDataIntentFilter.addAction(\"ACTION_BAR_LF\"); registerReceiver(mLfDataReceiver, LfDataIntentFilter); //注销广播 unregisterReceiver(mLfDataReceiver); //数据接收 private BroadcastReceiver mScanDataReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub String action = intent.getAction(); if (action.equals(\"ACTION_BAR_SCAN\")) { String str = intent.getStringExtra(\"EXTRA_SCAN_DATA\"); // str : barcode appView.loadUrl(\"javascript:Scan.ScanBar('\"+str+\"',1)\"); } } }; //扫描 //注册广播 IntentFilter scanDataIntentFilter = new IntentFilter(); scanDataIntentFilter.addAction(\"ACTION_BAR_SCAN\"); registerReceiver(mScanDataReceiver, scanDataIntentFilter); //注销广播 unregisterReceiver(mScanDataReceiver); //数据接收 private BroadcastReceiver mScanDataReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub String action = intent.getAction(); if (action.equals(\"ACTION_BAR_SCAN\")) { String str = intent.getStringExtra(\"EXTRA_SCAN_DATA\"); // str : barcode appView.loadUrl(\"javascript:Scan.ScanBar('\"+str+\"',0)\"); } } }; yfd //扫描 //注册广播 IntentFilter yfdScanDataIntentFilter = new IntentFilter(); yfdScanDataIntentFilter.addAction(\"android.intent.ACTION_DECODE_DATA\"); registerReceiver(yfdScanDataReceiver, yfdScanDataIntentFilter); //注销广播 unregisterReceiver(yfdScanDataIntentFilter); //数据接收 private BroadcastReceiver yfdScanDataReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub String action = intent.getAction(); if (action.equals(\"ACTION_BAR_SCAN\")) { String str = intent.getStringExtra(\"barcode_string\"); // str : barcode appView.loadUrl(\"javascript:Scan.ScanBar('\"+str+\"',0)\"); } } }; mianActivity中添加 import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.os.Bundle; import org.apache.cordova.*; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // enable Cordova apps to be started in the background Bundle extras = getIntent().getExtras(); if (extras != null && extras.getBoolean(\"cdvStartInBackground\", false)) { moveTaskToBack(true); } //注册按键广播接收者 IntentFilter scanDataIntentFilter = new IntentFilter(); scanDataIntentFilter.addAction(\"ACTION_BAR_SCAN\"); registerReceiver(mScanDataReceiver, scanDataIntentFilter); IntentFilter LfDataIntentFilter = new IntentFilter(); LfDataIntentFilter.addAction(\"ACTION_BAR_LF\"); registerReceiver(mLfDataReceiver, LfDataIntentFilter); IntentFilter topScanIntentFilter = new IntentFilter(); topScanIntentFilter.addAction(\"com.android.server.scannerservice.broadcast1\"); registerReceiver(topScanDataReceiver, topScanIntentFilter); IntentFilter topLfIntentFilter = new IntentFilter(); topLfIntentFilter.addAction(\"com.android.server.scannerservice.broadcast2\"); registerReceiver(topLfDataReceiver, topLfIntentFilter); IntentFilter iDataScanIntentFilter = new IntentFilter(); iDataScanIntentFilter.addAction(\"android.intent.action.SCANRESULT\"); registerReceiver(iDataScanDataReceiver, iDataScanIntentFilter); IntentFilter iDataLfIntentFilter = new IntentFilter(); iDataLfIntentFilter.addAction(\"com.idata.uhfdata\"); registerReceiver(iDataLfDataReceiver, iDataLfIntentFilter); // Set by in config.xml loadUrl(launchUrl); } /** * 广播接收器 */ private BroadcastReceiver mScanDataReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub String action = intent.getAction(); if (action.equals(\"ACTION_BAR_SCAN\")) { String str = intent.getStringExtra(\"EXTRA_SCAN_DATA\"); // str : barcode appView.loadUrl(\"javascript:Scan.ScanBar('\"+str+\"',0)\"); } } }; private BroadcastReceiver mLfDataReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub String action = intent.getAction(); if (action.equals(\"ACTION_BAR_LF\")) { String str = intent.getStringExtra(\"EXTRA_LF_DATA\"); // str : ID appView.loadUrl(\"javascript:Scan.ScanBar('\"+str+\"',1)\"); } } }; // 高频枪 private BroadcastReceiver topScanDataReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub String action = intent.getAction(); if (action.equals(\"com.android.server.scannerservice.broadcast1\")) { String str = intent.getStringExtra(\"scannerdata\"); // str : ID appView.loadUrl(\"javascript:Scan.ScanBar('\"+str+\"',0)\"); } } }; private BroadcastReceiver topLfDataReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub String action = intent.getAction(); if (action.equals(\"com.android.server.scannerservice.broadcast2\")) { String str = intent.getStringExtra(\"scannerdata\"); // str : ID appView.loadUrl(\"javascript:Scan.ScanBar('\"+str+\"',1)\"); } } }; // iData private BroadcastReceiver iDataScanDataReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub String action = intent.getAction(); if (action.equals(\"android.intent.action.SCANRESULT\")) { String str = intent.getStringExtra(\"value\"); appView.loadUrl(\"javascript:Scan.ScanBar('\"+str+\"',0)\"); } } }; private BroadcastReceiver iDataLfDataReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub String action = intent.getAction(); if (action.equals(\"com.idata.uhfdata\")) { String str = intent.getStringExtra(\"value\"); appView.loadUrl(\"javascript:Scan.ScanBar('\"+str+\"',1)\"); } } }; @Override public void onDestroy() { //注销广播 unregisterReceiver(mScanDataReceiver); unregisterReceiver(mLfDataReceiver); unregisterReceiver(topScanDataReceiver); unregisterReceiver(topLfDataReceiver); unregisterReceiver(iDataScanDataReceiver); unregisterReceiver(iDataLfDataReceiver); } 旧的广播事件及获取键： 扫码action：android.scanservice.action.UPLOAD_BARCODE_DATA 接收键名：barcode 刷卡action：android.rfid.FUN_KEY 接收键名：data Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-09-20 10:10:26 "},"python/python学习.html":{"url":"python/python学习.html","title":"python学习","keywords":"","body":"Python学习 下载地址 https://www.python.org/downloads/ pycharm下载地址(安装社区版) https://www.jetbrains.com/pycharm/ 注释 # 这是单行注释 \"\"\" 这是多行注释 \"\"\" type查看数据类型 type(123) 类型转换 int(123) float(12.3) str(123) 字符串拼接 注：python中的字符串拼接，不能直接拼接数字类型，需要转成字符类型才能拼接，或者通过 % 占位的方式拼接任意类型 占位类型3个：%s(字符) %d(整数) %f(浮点数) name = \"小明\" age = 123 msg = \"姓名：%s，年龄：%s\" % (name, age) print(msg) *** 姓名：小明，年龄：123 *** 数字精度控制 m.n *** m:控制宽度（设置宽度小于数字自身，不生效） .n:控制小数点精度（会进行小数的四舍五入） *** num1 = 11 num2 = 123.2423 print(\"num1=%1d\" % num1) print(\"num1=%4d\" % num1) print(\"num2=%6.1f\" % num2) print(\"num2=%.3f\" % num2) *** num1=11 num1= 11 num2= 123.2 num2=123.242 *** 快速格式化 f\"{占位}\" 可以是任意类型，不做精度控制，原来怎么样就是怎么样 name = \"小明\" age = 123 msg = f\"姓名：{name}，年龄：{age}\" print(msg) *** 姓名：小明，年龄：123 *** price = \"%.2f\" % ((1 * 1.2) ** 7 * 19.99) msg = f\"值为：{price}\" print(msg) *** 值为：71.63 *** input()获取键盘输入数据 content = input(f\"请输入任意内容：\") print(f\"您输入的内容是：{content}\") *** 请输入任意内容：你好 您输入的内容是：你好 *** bool布尔类型 bool1 = True bool2 = False print(f\"bool1={bool1}\") print(f\"bool2={bool2}\") print(f\"bool1={type(bool1)}\") print(f\"bool2={type(bool2)}\") *** bool1=True bool2=False bool1= bool2= *** 条件判断 *** 基本格式： if 判断的条件： 条件成立时... elif 条件成立时... else: 条件不成立时... 注： 1.条件判断末尾要加冒号 2.归属于if语句的代码块，前面需填充4个空格缩进 *** num = 85 if num > 90: print(f\"秀啊!\") elif num > 80 & num while循环 i = 1 sum = 0 while i for循环 name = \"CodeFront\" num = 0; for item in name: if item == \"o\": num += 1 print(f\"一共有{num}个‘o’\") *** 一共有2个‘o’ *** range生成序列 *** 语法： range(num)：生成0~num(不包含num)的序列 range(num1,num2)：生成num1~num2(不包含num2)的序列 range(num1,num2,step)：生成num1~num2(不包含num2)且步进为step的序列 *** for item in range(10): print(f\"{item} \", end=\"\") print() for item in range(5, 10): print(f\"{item} \", end=\"\") print() for item in range(5, 10, 2): print(f\"{item} \", end=\"\") *** 0 1 2 3 4 5 6 7 8 9 5 6 7 8 9 5 7 9 *** continue、break *** continue：结束当前循环，继续下一次循环 break：结束所有循环 *** 函数 *** def 函数名(传入参数): *** 说明文档 :params 传入参数: :return: *** 函数体 return 返回值 注：默认返回None *** def say(msg): \"\"\" say函数接收一个参数，返回说出的信息 :param msg:形参msg表示所说的内容 :return:返回值是说所的内容 \"\"\" print(f\"{msg}\") say(\"hello CodeFront\") *** hello CodeFront *** 作用域 *** 局部变量：作用域函数内部的变量 全局变量：在函数内及函数外都能使用的变量 注：局部变量通过global关键字可声明为全局变量 *** num = 100 def a(): # 通过global关键字将num声明为全局变量 global num num = 10 print(num) a() *** 10 *** 数组操作 index *** 返回元素在数组中的索引，找不到会报错 语法：数组.index(元素) *** stringList = ['a', 'b', 'c'] index = stringList.index('b') print(index) *** 1 *** insert *** 在指定的下标位置，插入指定元素 语法：数组.insert(索引,元素) *** stringList = ['a', 'b', 'c'] stringList.insert(1, 'd') print(stringList) *** ['a', 'd', 'b', 'c'] *** append *** 在数组末尾追加元素 语法：数组.append(元素) *** stringList = ['a', 'b', 'c'] stringList.append('d') print(stringList) *** ['a', 'b', 'c', 'd'] *** extend *** 在数组末尾追一批元素 语法：数组.extend(元素) *** stringList = ['a', 'b', 'c'] stringList.extend(['d', 'e', 'f']) print(stringList) *** ['a', 'b', 'c', 'd', 'e', 'f'] *** del *** 删除索引元素 语法：del 数组[索引] *** stringList = ['a', 'b', 'c'] del stringList[1] print(stringList) *** ['a', 'c'] *** pop *** 删除索引元素 语法：数组.pop(索引) *** stringList = ['a', 'b', 'c'] element = stringList.pop(2) print(f\"删除后的数据：{stringList}，获取的数据：{element}\") *** 删除后的数据：['a', 'b']，获取的数据：c *** remove *** 删除第一个出现的指定元素 语法：数组.remove(元素) *** stringList = ['a', 'b', 'c'] stringList.remove('b') print(stringList) *** ['a', 'c'] *** clear *** 删除所有元素 语法：数组.clear() *** stringList = ['a', 'b', 'c'] stringList.clear() print(stringList) *** [] *** count *** 统计元素出现的次数 语法：数组.count(元素) *** stringList = ['a', 'b', 'c', 'a', 'e'] count = stringList.count('a') print(count) *** 2 *** len *** 返回数组长度 语法：len(数组) *** stringList = ['a', 'b', 'c'] print(len(stringList)) *** 3 *** 元组 不可修改元素，但拥有数组的操作(除添加、删除) t1 = (1, 2, ['1', '2']) t2 = tuple() print(t1) print(t2) print(type(t1)) print(type(t2)) t1[2][0] = '3' t1[2][1] = '4' print(t1) *** (1, 2, ['1', '2']) () (1, 2, ['3', '4']) *** 字符串 字符串也是不可修改的元组 *** 根据索引获取字符 语法：字符串[索引] *** s = \"Hello CodeFront\" print(f\"{s[2]}\") *** l *** index *** 获取第一个出现的字符索引 语法：字符串.index(字符串) *** s = \"Hello CodeFront\" index = s.index('o') print(f\"{index}\") *** 4 *** replace *** 字符串替换 语法：字符串.replace(字符串1,字符串2) *** s = \"Hello CodeFront\" s = s.replace('F', 'f') print(f\"{s}\") *** Hello Codefront *** split *** 分割字符串 语法：字符串.split(字符串) *** s = \"Hello CodeFront\" my_list = s.split(' ') print(f\"{my_list}\") *** ['Hello', 'CodeFront'] *** strip *** 去除首尾的空格和换行符或自定字符串(不分先后顺序) 语法：字符串.strip(字符串) *** s = \"12Hello CodeFront21\" s = s.strip('12') print(f\"{s}\") *** Hello CodeFront *** count *** 统计字符串内某字符串出现次数 语法：字符串.count(字符串) *** s = \"Hello CodeFront\" count = s.count('o') print(f\"{count}\") *** 3 *** len *** 统计字符串长度 语法：len(字符串) *** s = \"Hello CodeFront\" length = len(s) print(f\"{length}\") *** 15 *** 序列 内容连续、有序、支持下标索引的一类数据容器 如：列表、元组、字符串 切片 *** 语法：序列[起始:结束:步长] 起始可以省略，省略从头开始 结束可以省略，省略到尾结束 步长可以省略，省略步长为1(可以为负数，表示倒序执行) *** a = [0, 1, 2, 3, 4, 5, 6] b = a[1:4] print(b) a = (0, 1, 2, 3, 4, 5, 6) b = a[:] print(b) a = '0123456' b = a[::2] print(b) a = '0123456' b = a[::-1] print(b) a = (0, 1, 2, 3, 4, 5, 6) b = a[::-2] print(b) a = '学Python，来黑马程序员，月薪过万' b = a[::-1] c = b[-10:4:-1] print(b) print(c) *** [1, 2, 3] (0, 1, 2, 3, 4, 5, 6) 0246 6543210 (6, 4, 2, 0) 万过薪月，员序程马黑来，nohtyP学 黑马程序员 *** Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-11-29 16:39:21 "},"shared/IM即时通信.html":{"url":"shared/IM即时通信.html","title":"IM即时通信","keywords":"","body":"IM即时通讯（Instant Messenger） 概念：是一款跨平台（Linux Server，Windows Server），可定制的 P2P 即时通信系统（集成多人视频会议功能），为各行业门户网站和企事业单位提供“一站式”定制解决方案。 功能描述 客户端能随时主动发送数据给服务端。 当客户端关注的内容在发生改变时，服务器能够实时地通知客户端。类比于传统的C/S请求模型，“实时通信”时客户端不需要主观地发送请求去获取自己关心的内容，而是由服务器端进行“推送”。 注意：上面的“推送”二字打了引号，实际上现有的几种技术实现方式中，并不是服务器端真正主动地推送，而是通过一定的手段营造了一种“实时通信”的假象。 常用方式 客户端轮询：传统意义上的短轮询（Short Polling） 服务器端轮询：长轮询（Long Polling） 单向服务器推送：Server-Sent Events（SSE） 全双工通信：WebSocket 短轮询（Short Polling） 客户端向服务器端发送一个请求，服务器返回数据，然后客户端根据服务器端返回的数据进行处理； 客户端继续向服务器端发送请求，继续重复以上的步骤，如果不想给服务器端太大的压力，一般情况下会设置一个请求的时间间隔。 使用场景：客户端通过定时器在规定时间内获取服务端的数据。如扫码。 优点：不需要额外的开发成本，请求数据，解析数据，作出响应，仅此而已，然后不断重复。 缺点：轮询的时间间隔不好控制。如果要求的实时性比较高，显然使用短轮询会有明显的短板，如果设置interval的间隔过长，会导致消息延迟，而如果太短，会对服务器产生压力。 长轮询（Long Polling） 客户端发送一个请求，服务器会hold住这个请求； 直到监听的内容有改变，才会返回数据，断开连接（或者在一定的时间内，请求还得不到返回，就会因为超时自动断开连接）; 客户端继续发送请求，重复以上步骤。 【实时通讯】轮询与长轮询_哔哩哔哩_bilibili 使用场景：弹幕、心跳包等 优点：新数据来了，连接断开后会释放客户端与服务器端的连接数，并产生新的连接。 缺点：阻塞服务器请求，依旧占用资源；如果客户端有新数据发送，但服务端没有再规定时间内返回，会导致响应失败。 Server-Sent Events（SSE） EventSource - Web API 接口参考 | MDN (mozilla.org) Server-Sent是HTML5提出一个标准。由客户端发起与服务器之间创建TCP连接，然后并维持这个连接，直到客户端或服务器中的任何一方断开，ServerSent使用的是\"问\"+\"答\"的机制，连接创建后浏览器会周期性地发送消息至服务器询问，是否有自己的消息。 SSE的本质其实就是一个HTTP的长连接，只不过它给客户端发送的不是一次性的数据包，而是一个stream流，格式为text/event-stream。所以客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。 兼容性：不兼容IE，其他现代浏览器基本都兼容 \"Server-Sent-Events\" | Can I use... Support tables for HTML5, CSS3, etc 使用场景：处理社交媒体状态更新，新闻提要或将数据传递到客户端存储机制（如 IndexedDB 或 Web 存储） 特点：客户端只需连接一次，Server就定时推送，除非其中一端断开连接。并且SSE会在连接意外断开时自动重连。 缺点：并没有达到最新消息服务器端的实时推送。 WebSocket 概念：WebSocket是一种网络通信协议，是HTML5新增的特性，实现了基于浏览器的远程socket，使浏览器和服务器可以进行全双工通信，大部分浏览器都对此做了支持。 与HTTP对比 不同点： HTTP的协议标识符是http，WebSocket的是ws； HTTP请求只能由客户端发起，服务器无法主动向客户端推送消息，而WebSocket可以； HTTP请求有同源限制，不同源之间通信需要跨域，而WebSocket没有同源限制。 相同点： 都是应用层的通信协议； 默认端口一样，都是80或443； 都可以用于浏览器和服务器间的通信； 都基于TCP协议。 兼容性：IE10以下不支持，现代浏览器基本都支持 WebSocket API | Can I use... Support tables for HTML5, CSS3, etc 使用场景：社交聊天、弹幕、多玩家游戏、协同编辑、股票基金实时报价、体育实况更新、视频会议/聊天、基于位置的应用、在线教育、智能家居等 特点： 可双向通信，设计的目的主要是为了减少传统轮询时http连接数量的开销； 建立在TCP协议之上，握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器； 与HTTP兼容性良好，同样可以使用80和443端口； 没有同源限制，客户端可以与任意服务器通信； 可以发送文本，也可以发送二进制数据； 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL. SSE与Websocket对比 1）SSE 使用 HTTP 协议，现有的服务器软件都支持。WebSocket 是一个独立协议。 2）SSE 属于轻量级，使用简单；WebSocket 协议相对复杂。 3）SSE 默认支持断线重连，WebSocket 需要自己实现。 4）SSE 一般只用来传送文本，二进制数据需要编码后传送，WebSocket 默认支持传送二进制数据。 5）SSE 支持自定义发送的消息类型。 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-12-02 09:30:17 "},"shared/ng-alain.html":{"url":"shared/ng-alain.html","title":"ng-alain","keywords":"","body":"NG-ALAIN 官网地址：https://ng-alain.com/zh 介绍 环境搭建、安装、运行 体系架构 核心模块描述 项目结构 常用命令 基本使用 介绍 NG-ALAIN 是一个企业级中后台前端/设计解决方案脚手架，秉承 Ant Design 的设计价值观，目标是希望在Angular上面开发企业后台更简单、更快速。随着『设计者』的不断反馈，将持续迭代，逐步沉淀和总结出更多设计模式和相应的代码实现，阐述中后台产品模板/组件/业务场景的最佳实践。 环境搭建、安装、运行 安装并使用 node LTS 版 全局安装 ng 脚手架 npm install -g @angular/cli 创建 ng 项目 并 安装 ng-alain 脚手架 ng new my-project --style less --routing ng add ng-alain 运行 ng serve 或 npm run start 版本升级 https://ng-alain.com/docs/upgrade-v11/zh 体系架构 类库 描述 @delon/theme 主题系统除了包含 NG-ALAIN 基础框架及所需样式（包含CSS工具集，一套类似Bootstrap）以外，还包含一些通用的数据渲染（Pipe）、服务工具类（页面标题、滚动条等）的集合，这些是日常必不可少的一些组成 @delon/abc 脚手架内提供了一套默认业务组件，这些组件抽象了控制台业务中的一些常见区块。我们将持续维护和迭代这些组件，为中后台业务提供比 Ant Design 基础组件更高级别的抽象 @delon/chart 基于 G2 的基础上二次封装，提供了业务中常用的图表套件，可以单独使用，也可以组合起来实现复杂的展示效果 @delon/form 基于 JSON Schema 标准的动态构建表单 @delon/auth 用户认证模块，用于解决如何获取、存取、使用这三个步骤的用户认证环节 @delon/acl 访问控制列表，是一种非常简单的基于角色权限控制，甚至达到控制某个按钮显隐的粒度 @delon/cache 将字典、城市数据等缓存至内存或持久化当中，有效减少 Http 请求 @delon/mock Mock 会拦截 Angular Http 请求并返回测试数据，当后端未完成接口时 Mock 技术是一项不会影响前端开发进度的工具 @delon/util 包含数组、延迟、字符串、日期、校验等常见工具集 @delon/testing 常用测试套件 CLI Schematics 快速生成统一的模板、可插拔的插件等 项目结构 ├── _mock # Mock 数据规则目录 ├── angular.json # Angular 项目配置文件 ├── src │ ├── app │ │ ├── core # 核心模块 │ │ │ ├── i18n │ │ │ ├── net │ │ │ │ └── default.interceptor.ts # 默认HTTP拦截器 │ │ │ ├── services │ │ │ │ └── startup.service.ts # 初始化项目配置 │ │ │ └── core.module.ts # 核心模块文件 │ │ ├── layout # 通用布局 │ │ ├── routes │ │ │ ├── ** # 业务目录 │ │ │ ├── routes.module.ts # 业务路由模块 │ │ │ └── routes-routing.module.ts # 业务路由注册口 │ │ ├── shared # 共享模块 │ │ │ ├── shared-delon.module.ts # @Delon/* 次级共享模块导入 │ │ │ ├── shared-zorro.module.ts # NG-ZORRO 次级共享模块导入 │ │ │ └── shared.module.ts # 共享模块文件 │ │ ├── app.component.ts # 根组件 │ │ └── app.module.ts # 根模块 │ │ └── global-config.module.ts # @delon & ng-zorro 全局配置项 │ ├── assets # 本地静态资源 │ ├── environments # 环境变量配置 │ ├── styles # 样式目录 └── └── style.less # 样式引导入口 补充 图表：Antv(G2 G6 F2 L7等) 项目脚手架跟随 Angular 及 NG-ZORRO 同步更新 常用指令 ng g ng-alain:module 模块名 ng g ng-alain:list 列表名 -m 模块名 ng g ng-alain:view 详情名 -m 模块名 -t 文件夹名称 补充 https://ng-alain.com/cli/plugin/zh 相关配置可到 angular.json 中配置 基本使用 @delon main.ts -> appModule -> 加载所有模块、组件、服务、指令等 appModule：通过 StartupService 服务，启动项目，Promise.resolve() 异步渲染视图，设置/存储处理项目基本信息 MenuService： 菜单服务，处理菜单列表 titleService：项目标题服务 ACLService：权限服务 ITokenService：token服务，token处理（设置） SettingsService：系统设置服务，含项目登录信息、项目密钥信息等 _HttpClient：alain 封装的网络请求服务，含 token 校验等 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-08-04 10:34:07 "},"shared/pdf预览、文本获取及处理.html":{"url":"shared/pdf预览、文本获取及处理.html","title":"pdf预览、文本获取及处理","keywords":"","body":"PDF预览、文本获取及处理 github：GitHub - mozilla/pdf.js: PDF Reader in JavaScript cdn地址：https://cdnjs.com/libraries/pdf.js 参考：https://qa.1r1g.com/sf/ask/2844518561/ 注：pdf文件必须存放在服务器上，不能获取file://协议文件，会提示跨域。预览文件须以https开头的安全域名。 预览 pdf文件：Git Tutorial (gjtool.cn) github的pdf-viewer：https://mozilla.github.io/pdf.js/web/viewer.html) 使用： pdf路径使用 encodeURIComponent 进行编码。encodeURIComponent('https://www.gjtool.cn/pdfh5/git.pdf') 最终效果：https://mozilla.github.io/pdf.js/web/viewer.html?file=https%3A%2F%2Fwww.gjtool.cn%2Fpdfh5%2Fgit.pdf) 文本获取 const pdfUrl = 'https://www.gjtool.cn/pdfh5/git.pdf'; function getText(pdfUrl) { var loadingTask = pdfjsLib.getDocument(pdfUrl); return loadingTask.promise.then((pdf) => { // 获取页数 const pageNum = pdf._pdfInfo.numPages; const countPromises = []; for (let index = 1; index { // 获取文本 const data = res.getTextContent(); return data.then((text) => { return text.items.map((item, i) => { return item.str; }).join(``); }); })); } console.log(countPromises); return Promise.all(countPromises).then((res) => { return res.join(''); }); }); } getText(pdfUrl).then((res) => { console.log(res); }, (err) => { console.log(err); }); 数据提取及处理 需处理的文件： 处理方法： import { HttpClient } from '@angular/common/http'; import { Injectable, Injector } from '@angular/core'; import { NzModalService } from 'ng-zorro-antd/modal'; import { GlobalWorkerOptions, getDocument } from 'pdfjs-dist'; import { PdfTmplListModalComponent } from '../components/pdf/pdf-tmpl-list-modal/pdf-tmpl-list-modal.component'; import { CommonService } from './common.service'; export interface PdfOption { title?: string, privige?: { }, type: 'PDF'; pdfTmplList?: { desction: string; fileCount: number; fileList: string[]; function: string, id: number; name: string; isUsed: boolean; [key: string]: any; }[], reflesh?: boolean } // pdf服务 @Injectable({ providedIn: 'root' }) export class PdfService { sectionSplitTag = ''; // 区域分割标识 contentSectionsplitTag = ''; // 内容分块分隔表示 contentSplitTag = '|'; // 内容分割标识 pageSplitTag = ''; // 页面分割标识 constructor( private nzModalService: NzModalService, private http: HttpClient, private injector: Injector ) { } /** 获取模板数据 */ getPdf() { return new Promise((resolve, reject) => { this.http.get(`assets/pdf/pdf.json?t=${Date.now()}`).subscribe((res: object) => { resolve(res); }); }); } /** 导入列表 */ getPdfImportList(params: object) { return this.injector.get(CommonService).httpGet({ url: '/PdfImport/getPdfImportList', params }); } /** 添加PDF数据 */ addPdfImport(fd: FormData) { return this.injector.get(CommonService).httpPost({ url: '/PdfImport/addPdfImport', fd }); } /** 编辑PDF导入数据 */ editPdfImportList(fd: FormData) { return this.injector.get(CommonService).httpPost({ url: '/PdfImport/editPdfImportList', fd }); } /** 上传文件 */ uploadFiles(fd: FormData) { return this.injector.get(CommonService).httpPost({ url: '/base/uploadFiles', fd }); } /** pdf模态框 */ pdfModal(obj?: PdfOption) { const modal = this.nzModalService.create({ nzContent: PdfTmplListModalComponent, nzComponentParams: { obj, type: obj ? obj.type : 'PDF' }, nzWidth: '1600px', nzFooter: null, nzCentered: true, nzMaskClosable: false, nzClosable: false }); return modal; } /** 获取pdf文本信息 */ getText(obj: { pdfUrl: string, sectionList?: string[], // 区域标识文字 }) { // 必须设定work工作区，否则会报错 GlobalWorkerOptions.workerSrc = 'https://cdn.bootcdn.net/ajax/libs/pdf.js/2.14.305/pdf.worker.min.js'; var loadingTask = getDocument(obj.pdfUrl); return loadingTask.promise.then((pdf) => { const pageNum = pdf._pdfInfo.numPages; const countPromises = []; for (let index = 1; index { const data = res.getTextContent(); return data.then((text) => { // console.log(text); const reg = /(^\\s+)|(\\s+$)|\\s+/g; return text.items .filter((item: any) => item.str !== '') .map((item: any) => { const str = item.str; if ((obj.sectionList || []).some((i) => i.startsWith(str))) { // 区域标识 return `${this.sectionSplitTag}${str}[${item.transform[4]},${item.transform[5]},${item.width}]${this.contentSectionsplitTag}`; } else { // 内容标识 if (str.trim() !== '') { // 内容不为空添加标识 return `${str}[${item.transform[4]},${item.transform[5]},${item.width}]${this.contentSplitTag}`; } else { return str; } } }).join(''); }); })); } return Promise.all(countPromises).then((res) => { return res.join(this.pageSplitTag); // 页面分割标识 }); }).catch((error) => { // 解析失败 throw new Error(error); }); } /** 删除前后分隔符 */ delLRSplit(obj: { str: string }) { if (obj.str.startsWith(this.contentSplitTag)) { obj.str = obj.str.substring(1, obj.str.length); } if (obj.str.endsWith(this.contentSplitTag)) { obj.str = obj.str.substring(0, obj.str.length - 1); } return obj.str; } /** 删除所有分隔符 */ delAllSplit(obj: { str: string }) { if (this.sectionSplitTag) { obj.str = obj.str.replaceAll(this.sectionSplitTag, this.contentSplitTag); } if (this.contentSectionsplitTag) { obj.str = obj.str.replaceAll(this.contentSectionsplitTag, this.contentSplitTag); } if (this.pageSplitTag) { obj.str = obj.str.replaceAll(this.pageSplitTag, this.contentSplitTag); } return obj.str; } /** 清除坐标 */ clearPosition(obj: { str: string }) { return obj.str.replaceAll(/\\[.*?\\]/g, ''); } /** 格式化回数组坐标 */ positionReset(obj: { str: string }) { obj.str = this.delAllSplit({ str: obj.str }); let list = this.delLRSplit({ str: obj.str }) .split(this.contentSplitTag) .filter((item) => item !== '') .map((item, i) => { let width = 0; let p = item.match(/\\[.*?\\]/g); let position = [-1, -1]; if (p) { position = JSON.parse(p[0]); width = JSON.parse(p[0]) && JSON.parse(p[0]).length > 2 ? JSON.parse(p[0])[2] : 0; } const index = item.indexOf('['); if (index > -1) { obj.str = item.substring(0, index); } return { str: obj.str, position, width } }); return list; } /** 清除页头 */ clearPageHeader(obj: { str: string, reg: RegExp | string, replaceText?: string }) { obj.str = obj.str.replaceAll(obj.reg, obj.replaceText || ''); return obj.str; } /** 清除页脚 */ clearPageFooter(obj: { str: string, reg: RegExp | string, replaceText?: string }) { obj.str = obj.str.replaceAll(obj.reg, obj.replaceText || ''); return obj.str; } /** 坐标重排(降序) */ // positionSort(obj: { str: string }) { // // 清除所有标记 // obj.str = obj.str.replaceAll(this.sectionSplitTag, this.contentSplitTag); // obj.str = obj.str.replaceAll(this.contentSectionsplitTag, this.contentSplitTag); // let list = this.positionReset({ str: obj.str }); // // console.log(JSON.parse(JSON.stringify(list // // .sort((a, b) => { // // return b.position[1] - a.position[1]; // // })))); // list = list.sort((a, b) => { // return b.position[1] - a.position[1]; // }) // .sort((a, b) => { // return a.position[0] - b.position[0]; // }) // return obj.str; // } /** 根据坐标范围查找具体数据 */ findInPosition(obj: { str: string, xStartPosition: number, xEndPosition: number, yStartPosition: number, yEndPosition: number }) { let list = this.positionReset({ str: obj.str }); list = list.filter((item) => item.position[0] >= obj.xStartPosition && item.position[0] = obj.yStartPosition && item.position[1] { if (index === 0) { result.push(item); } else { // 相邻数组长度大于2才需要分开，否则会被拼接在一起 if (list.length > 2 && Math.abs(list[index].position[0] - result[result.length - 1].position[0]) 0 ? obj.xSiblingDiff : 5)) { result[result.length - 1].str = result[result.length - 1].str + list[index].str; } else { result.push(item); } } }); return result.map((item) => { return { ...item, str: item.str.trim() } }); } /** 有序表格数据处理（属性在表头）ySiblingDiff：垂直差值，默认为5 */ olTableHandle(obj: { str: string, col: number, xSiblingDiff?: number, ySiblingDiff?: number }) { const result = this.xSiblingHandle({ str: obj.str, xSiblingDiff: obj.xSiblingDiff }); const list = []; // 初始化表格数据 let row = 0; let position = 0; result.forEach((item, index) => { if (index >= obj.col) { if (index === obj.col) { position = item.position[1]; row = 1; } if (item.position[1] !== -1 && Math.abs(item.position[1] - position) > (obj.ySiblingDiff && obj.ySiblingDiff > 0 ? obj.ySiblingDiff : 5)) { position = item.position[1]; row += 1; } } else { list[row] = list[row] ? list[row] : []; list[row].push(item); } }); // 组装表格数据 for (let index = 1; index { list[index] = list[index] ? list[index] : []; list[index].push({ str: '', position: [-1, -1], width: 0 }); }) } row = 0; result.forEach((item, index) => { if (index >= obj.col) { if (index === obj.col) { position = item.position[1]; row = 1; } if (item.position[1] !== -1 && Math.abs(item.position[1] - position) > (obj.ySiblingDiff && obj.ySiblingDiff > 0 ? obj.ySiblingDiff : 5)) { position = item.position[1]; row += 1; } // 初始算法 // const i = list[0].findIndex((item2) => Math.abs(item2.position[0] - item.position[0]) 0 ? obj.ySiblingDiff : 5)); // if (i > -1) { // list[row][i] = item; // } // 算法升级，取区间内的数据进行拼接，不适用于表头属性文字居中或表头分组，因为区间范围无法计算 const spaceList = list[0].map((item2) => item2.position[0]); spaceList.forEach((item2, index2) => { if (index2 !== (spaceList.length - 1) && spaceList[index2] item.position[0] || index2 === (spaceList.length - 1) && spaceList[index2] [item2.position[0], item2.position[0] + item2.position[2]]); // console.log(spaceList1, spaceList2); // spaceList2.forEach((item2, index2) => { // let start = [Math.min(...spaceList1), Math.min(...item2)]; //区间的两个最小值 // let end = [Math.max(...spaceList1), Math.max(...item2)]; //区间的两个最大值 // if (Math.max(...start) { return item.map((item2) => { return item2.str; }) }); } /** 无序表格数据处理（属性在左侧） */ ulTableHandle(obj: { str: string }) { const list = []; let row = -1; obj.str.split(this.contentSplitTag).forEach((item, index) => { if (index % 2 === 0 && item.trim()) { row += 1; list[row] = list[row] ? list[row] : []; } if (index % 2 === 0 && item.trim() || index % 2 === 1 && list[row].length > 0) { list[row].push(this.clearPosition({ str: item }).trim()); } }) return list; } /** 有序列表数据处理 */ olListHandle(obj: { str: string, keyList: string[] }) { const list = []; let row = -1; obj.str.split(this.contentSplitTag).forEach((item, index) => { if (index % obj.keyList.length === 0) { row += 1; } list[row] = list[row] ? list[row] : []; list[row].push(this.clearPosition({ str: item }).trim()); }) return list; } /** oncekeyList 只寻找首次出现的section作为标题 */ sectionHandle(obj: { list: string[], oncekeyList: string[] }) { obj.oncekeyList.forEach((item) => { const arr = obj.list.filter((item2) => item2.startsWith(item)); if (arr.length > 1) { arr.shift(); arr.forEach((item2) => { const index3 = obj.list.findIndex((item3) => item3 === item2); if (index3 > -1) { obj.list[index3] = obj.list[index3].replace(this.contentSectionsplitTag, this.contentSplitTag); // 处理非section后面第一个分割符 obj.list[index3 - 1] = obj.list[index3 - 1] + obj.list[index3]; obj.list.splice(index3, 1); } }); } }); return obj.list; } } 最终数据处理 import { Injectable, Injector } from '@angular/core'; import moment from 'moment'; import { PdfService } from 'src/app/shared/services/pdf.service'; @Injectable({ providedIn: 'root' }) export class HmService { orderNoCollectList = []; productNoCollectList = []; productName = ''; // 产品名称 seasonCollectList = []; // 采购单季节 optionCollectList = []; // 信息表的option分组 noOfPieces = ''; // 每卡支数 miscellaneousStr = ''; // 包材信息 compositionCollectList = []; // 信息表的成分 colorNameCollectList = []; // 颜色名称信息 invoiceAveragePriceCollectList = []; // 平均单价、走货方式 termsDeliveryCollectList = []; // 走货方式详情 colorCollectList = []; // 三维表对应的颜色组 colorTableCollectList = []; // 三维表（颜色、走货方式、数量） timeDeliveryCollectList = []; sizePerColourBreakdownResultList = []; // SizePerColourBreakdown的结果集（Article No、H&M Colour Code、Option No、Quantity） constructor( private injector: Injector ) { } get pdfService() { return this.injector.get(PdfService); } /** Supplementary Product Information.PDF */ handle1(res: string) { res = this.pdfService.clearPageHeader({ str: res, reg: /HLW\\s\\S+-\\S+\\s\\S+\\s\\S+\\s-\\s\\d+-\\d+.*?\\]\\|{0,1}/g }); res = this.pdfService.clearPageFooter({ str: res, reg: /(Created).*?(?=Page)/g }); res = this.pdfService.clearPageFooter({ str: res, reg: /(Page).*?\\]\\|{0,1}/g }); res = res.split(this.pdfService.pageSplitTag).join(this.pdfService.contentSplitTag); // Order NO const orderNoResultList = this.pdfService.findInPosition({ str: res, xStartPosition: 220, xEndPosition: 230, yStartPosition: 530, yEndPosition: 540, }); const orderNoValue = orderNoResultList.length > 0 ? orderNoResultList[0].str.trim() : ''; this.orderNoCollectList.push(orderNoValue); console.log(orderNoValue); // Product No const productNoResultList = this.pdfService.findInPosition({ str: res, xStartPosition: 625, xEndPosition: 635, yStartPosition: 535, yEndPosition: 545, }); const productNoValue = productNoResultList.length > 0 ? productNoResultList[0].str.trim() : ''; this.productNoCollectList.push(productNoValue); console.log(productNoValue); // Product Name const productNameResultList = this.pdfService.findInPosition({ str: res, xStartPosition: 625, xEndPosition: 635, yStartPosition: 520, yEndPosition: 530, }); const productNameValue = productNameResultList.length > 0 ? productNameResultList[0].str.trim() : ''; console.log(productNameValue); this.productName = productNameValue; // Option const optionResultList = (res.match(new RegExp('(? { return this.pdfService.clearPosition({ str: item.replaceAll(this.pdfService.contentSplitTag, '') }).trim(); }); console.log(optionResultList); this.optionCollectList = optionResultList; // Composition const compositionList = (res.match(new RegExp('(? { const tableList = this.pdfService.olTableHandle({ str: item, col: 13 }); if (tableList.length > 0) { const i = tableList[0].findIndex((item2) => item2.indexOf('Composition') > -1); tableList.shift(); return i > -1 ? tableList.map((item2) => item2[i]) : []; } else { return []; } }); console.log(compositionList); this.compositionCollectList = compositionList; // Colour Name const colorNameTableRegList = (res.match(new RegExp(`((? { let list = item.split(this.pdfService.contentSplitTag); list.splice(0, 1); return this.pdfService.delLRSplit({ str: list.join(this.pdfService.contentSplitTag) }); }); let colorNameList = []; colorNameTableRegList.forEach((item) => { let list = this.pdfService.olTableHandle({ str: item, col: 11 }); list.splice(0, 1); colorNameList = colorNameList.concat(list); }); console.log(colorNameList); this.colorNameCollectList = colorNameList; // Miscellaneous const miscellaneousRegList = (res.match(new RegExp('(? 0 ? this.pdfService.olTableHandle({ str: miscellaneousRegList[0], col: 6 }) : []; miscellaneousList.length > 0 && miscellaneousList.shift(); const miscellaneous = miscellaneousList.map((item) => { return item[0]; }).join(','); console.log(miscellaneous); this.miscellaneousStr = miscellaneous; } /** PurchaseOrder.PDF */ handle2(res: string) { // Order NO let orderNoValue = ''; const orderNoResultList = this.pdfService.findInPosition({ str: res, xStartPosition: 95, xEndPosition: 105, yStartPosition: 755, yEndPosition: 765, }); if ([...new Set(orderNoResultList.map((item) => item.str))].length !== 1) { throw new Error('Order NO不一致'); return; } else { orderNoValue = orderNoResultList.length > 0 ? orderNoResultList[0].str : ''; } this.orderNoCollectList.push(orderNoValue); console.log(orderNoValue); // Product No let productNoValue = ''; const productNoResultList = this.pdfService.findInPosition({ str: res, xStartPosition: 335, xEndPosition: 345, yStartPosition: 755, yEndPosition: 765, }); if ([...new Set(productNoResultList.map((item) => item.str))].length !== 1) { throw new Error('Product No不一致'); return; } else { productNoValue = productNoResultList.length > 0 ? productNoResultList[0].str : ''; } this.productNoCollectList.push(productNoValue); console.log(productNoValue); // Season const seasonResultList = this.pdfService.findInPosition({ str: res, xStartPosition: 335, xEndPosition: 345, yStartPosition: 715, yEndPosition: 725, }).map((item) => (item.str)); console.log(seasonResultList); this.seasonCollectList = seasonResultList; // No of Pieces const noOfPiecesResultList = this.pdfService.findInPosition({ str: res, xStartPosition: 335, xEndPosition: 345, yStartPosition: 640, yEndPosition: 650, }).map((item) => (item.str.trim())); console.log(noOfPiecesResultList); this.noOfPieces = noOfPiecesResultList.length > 0 ? noOfPiecesResultList[0] : ''; // Terms of Delivery const termsDeliveryResultList = (res.match(new RegExp('(? { return this.pdfService.delLRSplit({ str: this.pdfService.clearPosition({ str: item }) }).split(this.pdfService.contentSplitTag); }); console.log(termsDeliveryResultList); this.termsDeliveryCollectList = termsDeliveryResultList.length > 0 ? termsDeliveryResultList[0] : []; // Time of Delivery let timeDeliveryResultList = []; const timeDeliveryRegList = (res.match(new RegExp('Time of Delivery((?!Terms of Delivery).)*', 'g')) || []); if (timeDeliveryRegList.length > 0) { timeDeliveryResultList = this.pdfService.olTableHandle({ str: timeDeliveryRegList[0], col: 4 }); timeDeliveryResultList.pop(); } this.timeDeliveryCollectList = timeDeliveryResultList; console.log(timeDeliveryResultList); // Invoice Average Price const invoiceAveragePriceResultList = (res.match(new RegExp('Invoice Average Price((?!By accepting and performing under this Order).)*', 'g')) || []) .map((item) => { return this.pdfService.olTableHandle({ str: item, col: 2 }); }); console.log(invoiceAveragePriceResultList); this.invoiceAveragePriceCollectList = invoiceAveragePriceResultList; } /** SizePerColourBreakdown.PDF */ handle3(res: string) { res = this.pdfService.clearPageHeader({ str: res, reg: /(Page).*?(?=Created)/g, replaceText: this.pdfService.sectionSplitTag }); res = this.pdfService.clearPageFooter({ str: res, reg: /(Created).*?(?=Telephone)/g, replaceText: this.pdfService.sectionSplitTag }); // Order NO let orderNoValue = ''; const orderNoResultList = this.pdfService.findInPosition({ str: res, xStartPosition: 95, xEndPosition: 105, yStartPosition: 760, yEndPosition: 770, }); if ([...new Set(orderNoResultList.map((item) => item.str))].length !== 1) { throw new Error('Order NO不一致'); return; } else { orderNoValue = orderNoResultList.length > 0 ? orderNoResultList[0].str : ''; } this.orderNoCollectList.push(orderNoValue); console.log(orderNoValue); // Product No let productNoValue = ''; const productNoResultList = this.pdfService.findInPosition({ str: res, xStartPosition: 320, xEndPosition: 330, yStartPosition: 760, yEndPosition: 770, }); if ([...new Set(productNoResultList.map((item) => item.str))].length !== 1) { throw new Error('Product No不一致'); return; } else { productNoValue = productNoResultList.length > 0 ? productNoResultList[0].str : ''; } this.productNoCollectList.push(productNoValue); console.log(productNoValue); // Colour / Country Breakdown const colorCountryBreakdownRegList = res.match(/^((?!Colour \\/ Country Breakdown).)*/g) || []; const colorCountryBreakRegStr = colorCountryBreakdownRegList.length > 0 ? colorCountryBreakdownRegList[0] : ''; const colorTableRegList = colorCountryBreakRegStr.match(/(?=Article:).*(?=Total)/g) || []; const colorTableRegStr = colorTableRegList.length > 0 ? colorTableRegList[0] : ''; const colorRegList = colorTableRegStr.match(/(? { return this.pdfService.clearPosition({ str: item }) .split(this.pdfService.contentSplitTag) .map((item2) => item2.trim()); }); console.log(colorList) this.colorCollectList = colorList; // 表格内容数据 const colorRegList2 = colorTableRegStr.match(/Article:(.*?\\|)(.*?\\|)/g) || []; let tableStr = colorTableRegStr; colorRegList2.forEach((item) => { tableStr = tableStr.replace(item, ''); }); const tableList = this.pdfService.olTableHandle({ str: this.pdfService.delLRSplit({ str: tableStr }), col: 3 + colorList.length }); console.log(tableList); this.colorTableCollectList = tableList; } /** TotalCountryBreakdown.PDF */ handle4(res: string) { res = this.pdfService.clearPageHeader({ str: res, reg: /(Page).*?(?=Created)/g, replaceText: this.pdfService.sectionSplitTag }); res = this.pdfService.clearPageFooter({ str: res, reg: /(Created).*?(?=Telephone)/g, replaceText: this.pdfService.sectionSplitTag }); const pageList = res.split(this.pdfService.pageSplitTag); // Order NO let orderNoValue = ''; const orderNoResultList = this.pdfService.findInPosition({ str: res, xStartPosition: 95, xEndPosition: 105, yStartPosition: 760, yEndPosition: 770, }); if ([...new Set(orderNoResultList.map((item) => item.str))].length !== 1) { throw new Error('Order NO不一致'); return; } else { orderNoValue = orderNoResultList.length > 0 ? orderNoResultList[0].str : ''; } this.orderNoCollectList.push(orderNoValue); console.log(orderNoValue); // Product No let productNoValue = ''; const productNoResultList = this.pdfService.findInPosition({ str: res, xStartPosition: 320, xEndPosition: 330, yStartPosition: 760, yEndPosition: 770, }); if ([...new Set(productNoResultList.map((item) => item.str))].length !== 1) { throw new Error('Product No不一致'); return; } else { productNoValue = productNoResultList.length > 0 ? productNoResultList[0].str : ''; } this.productNoCollectList.push(productNoValue); console.log(productNoValue); const countryReg = `(? { const country = item.match(new RegExp(countryReg)) && item.match(new RegExp(countryReg))[0] || ''; const articleNo = item.match(new RegExp(articleNoReg)) && item.match(new RegExp(articleNoReg))[0] || ''; const HMColourCode = item.match(new RegExp(HMColourCodeReg)) && item.match(new RegExp(HMColourCodeReg))[0] || ''; const optionNo = item.match(new RegExp(optionNoReg)) && item.match(new RegExp(optionNoReg))[0] || ''; const quantity = item.match(new RegExp(quantityReg)) && item.match(new RegExp(quantityReg))[0] || ''; const list = []; if (country) { list.push(this.pdfService.clearPosition({ str: country })); } if (articleNo) { list.push( this.pdfService.clearPosition({ str: articleNo }) .split(this.pdfService.contentSplitTag) .map((item2) => (item2.trim())) ); } else { list.push([]) } if (HMColourCode) { list.push( this.pdfService.clearPosition({ str: HMColourCode }) .split(this.pdfService.contentSplitTag) .map((item2) => (item2.trim())) ); } else { list.push([]) } if (optionNo) { list.push( this.pdfService.clearPosition({ str: optionNo }) .split(this.pdfService.contentSplitTag) .map((item2) => (item2.trim())) ); } else { list.push([]) } if (quantity) { list.push( this.pdfService.clearPosition({ str: quantity }) .split(this.pdfService.contentSplitTag) .map((item2) => (item2.trim())) ); } else { list.push([]) } resultList.push(list); }); this.sizePerColourBreakdownResultList = resultList; console.log(resultList); } mergeHandle(obj: { pdfUrl1: string, sectionList1?: string[], pdfUrl2: string, sectionList2?: string[], pdfUrl3: string, sectionList3?: string[], pdfUrl4: string, sectionList4?: string[] }) { return Promise.all([ // this.pdfService.getText({ pdfUrl: 'http://localhost:4200/assets/pdf/hm/Supplementary Product Information.pdf', sectionList: obj.sectionList1 }), // this.pdfService.getText({ pdfUrl: 'http://localhost:4200/assets/pdf/hm/PurchaseOrder.PDF', sectionList: obj.sectionList2 }), // this.pdfService.getText({ pdfUrl: 'http://localhost:4200/assets/pdf/hm/TotalCountryBreakdown.PDF', sectionList: obj.sectionList3 }), // this.pdfService.getText({ pdfUrl: 'http://localhost:4200/assets/pdf/hm/SizePerColourBreakdown.PDF', sectionList: obj.sectionList4 }) this.pdfService.getText({ pdfUrl: obj.pdfUrl1, sectionList: obj.sectionList1 }), this.pdfService.getText({ pdfUrl: obj.pdfUrl2, sectionList: obj.sectionList2 }), this.pdfService.getText({ pdfUrl: obj.pdfUrl3, sectionList: obj.sectionList3 }), this.pdfService.getText({ pdfUrl: obj.pdfUrl4, sectionList: obj.sectionList4 }) ]).then((res) => { // 数据处理及校验 res.forEach((item, index) => { switch (index + 1) { case 1: this.handle1(item); break; case 2: this.handle2(item); break; case 3: this.handle3(item); break; case 4: this.handle4(item); break; } console.log('----------------------------'); }) let orderNo = ''; let productNo = ''; let orderNoList = [...new Set(this.orderNoCollectList)]; let productNoList = [...new Set(this.productNoCollectList)]; if (orderNoList.length !== 1) { throw new Error('Order No不一致'); } orderNo = orderNoList[0]; if (productNoList.length !== 1) { throw new Error('Product No不一致'); } productNo = productNoList[0]; console.log('数据组装------------------'); const colorList = this.colorCollectList.map((item) => { return { colorNo: item.length > 1 ? item[1] : '' } }) let resultList = []; this.sizePerColourBreakdownResultList.forEach((item1, index1) => { if (item1[0]) { item1[1].forEach((item2, index2) => { const planningMarkets = item1[0].match(/(? item3.length > 3 && item3[1] === item1[2][index2]); // 数量匹配 const country = planningMarkets.match(/(? (item3[1])).findIndex((item3) => item3.indexOf(country) > -1); const colorIndex = colorList.findIndex((item3) => item3.colorNo === item1[2][index2]); // 走货方式详情 const countryShort = planningMarkets.match(/.+(?=\\s\\()/g) ? planningMarkets.match(/.+(?=\\s\\()/g)[0] : ''; const trimsOfDelivery = this.termsDeliveryCollectList.filter((item3, index3) => index3 % 2 === 0).join(','); resultList.push({ SoId: '', MatId: '', orderNo, // 客户订单号 productNo, // 客户产品编号 productName: this.productName, // 产品名称 season: '', // 季节 colorNo: item1[2][index2], // 颜色编号 colorName: colorNameIndex > -1 ? this.colorNameCollectList[colorNameIndex][2] : '', // 颜色名称 optionNo: item1[3][index2], // 分组号 composition: '', // 成分 price: '', // 单价 costType: '', // 币种 invoiceAveragePrice: '', // 平均单价 timeDelivery: '', // 交期 planningMarkets: planningMarkets ? planningMarkets.replace(/\\s+\\(.*?\\)/g, '') : '', // 走货国家 noOfPieces: this.noOfPieces, // 每卡支数 termsOfDelivery: trimsOfDelivery.indexOf(countryShort) > -1 ? this.termsDeliveryCollectList.join(' ') : '', // 走货方式 qty: countryIndex > -1 && colorIndex > -1 ? this.colorTableCollectList[countryIndex][3 + colorIndex] : '', // 走货数量 quantity: item1[4][index2], // 入袋数 labelCode: this.miscellaneousStr // 包材信息 }); }); } }) this.timeDeliveryCollectList.shift(); resultList = resultList.map((item) => { // 获取分组索引 const i = this.optionCollectList.findIndex((item2) => item2.startsWith(item.optionNo)); let season = ''; let composition = ''; let price = ''; let costType = ''; let invoiceAveragePrice = this.invoiceAveragePriceCollectList.length > 0 && this.invoiceAveragePriceCollectList[0].length > 0 && this.invoiceAveragePriceCollectList[0][1].length > 0 ? this.invoiceAveragePriceCollectList[0][1][0] : ''; let timeDelivery = ''; if (i > -1 && this.seasonCollectList.length >= i) { season = this.seasonCollectList[i] || ''; } if (i > -1 && this.compositionCollectList.length >= i) { composition = this.compositionCollectList[i].length > 0 ? this.compositionCollectList[i][0] : '' } if (invoiceAveragePrice) { price = invoiceAveragePrice.match(/.+(?=\\s)/g) ? invoiceAveragePrice.match(/.+(?=\\s)/g)[0] : ''; costType = invoiceAveragePrice.match(/(? { const i = this.timeDeliveryCollectList.map((item2) => (item2[1])).findIndex((item2) => item.planningMarkets.match(/(? -1 : false); item.timeDelivery = i > -1 ? this.timeDeliveryCollectList[i][0] : ''; return { ...item, timeDelivery: moment(new Date(item.timeDelivery)).subtract('3', 'days').format('YYYY/MM/DD') }; }); console.log(resultList); return Promise.resolve(resultList); }).catch((error) => { // 上传失败 // throw new Error(error); console.log(error); }); } } Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-09-19 09:41:21 "},"shared/webcomponent及angular的变化检测机制.html":{"url":"shared/webcomponent及angular的变化检测机制.html","title":"webcomponent及angular的变化检测机制","keywords":"","body":"webcomponent 、angular的变化检测机制 webcomponent（网页组件） 参考文档： https://developer.mozilla.org/en-US/docs/Web/Web_Components Web Components 入门实例教程 - 阮一峰的网络日志 (ruanyifeng.com) 1.概念 Web Components 是一套不同的技术，允许您创建可重用的自定义元素——它们的功能被封装在你的代码的其余部分之外——并在你的 Web 应用程序中使用它们。 Web Components旨在解决这些问题 — 它由三项主要技术组成，它们可以一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。 Custom elements（自定义元素）：一组JavaScript API，允许您定义custom elements及其行为，然后可以在您的用户界面中按照需要使用它们。 Shadow DOM（影子DOM）：一组JavaScript API，用于将封装的“影子”DOM树附加到元素（与主文档DOM分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。 HTML templates（HTML模板）： 和 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用 实现web component的基本方法通常如下所示： 创建一个类或函数来指定web组件的功能，如果使用类，请使用 ECMAScript 2015 的类语法(参阅类获取更多信息)。 使用 CustomElementRegistry.define() 方法注册您的新自定义元素 ，并向其传递要定义的元素名称、指定元素功能的类、以及可选的其所继承自的元素。 如果需要的话，使用Element.attachShadow() 方法将一个shadow DOM附加到自定义元素上。使用通常的DOM方法向shadow DOM中添加子元素、事件监听器等等。 如果需要的话，使用 定义一个HTML模板。再次使用常规DOM方法克隆模板并将其附加到您的shadow DOM中。 在页面任何您喜欢的位置使用自定义元素，就像使用常规HTML元素那样。 2.元素注册器 CustomElementRegistry：CustomElementRegistry接口提供注册自定义元素和查询已注册元素的方法。要获取它的实例，请使用 window.customElements属性。 3.语法 customElements.define(name, constructor, options); 4.生命周期回调 定义在自定义元素的类定义中的特殊回调函数，影响其行为： connectedCallback: 当自定义元素第一次被连接到文档DOM时被调用。 disconnectedCallback: 当自定义元素与文档DOM断开连接时被调用。 adoptedCallback: 当自定义元素被移动到新文档时被调用。 attributeChangedCallback: 当自定义元素的一个属性被增加、移除或更改时被调用。 5.Shadow DOM Web components 的一个重要属性是封装——可以将标记结构、样式和行为隐藏起来，并与页面上的其他代码相隔离，保证不同的部分不会混在一起，可使代码更加干净、整洁。其中，Shadow DOM 接口是关键所在，它可以将一个隐藏的、独立的 DOM 附加到一个元素上。 ShadowRoot 表示shadow DOM子树的根节点。 Element extensions 与shadow DOM有关的Element 接口的扩展: Element.attachShadow() 方法将shadow DOM树附加给特定元素。 Element.shadowRoot 属性返回附加给特定元素的shadow root，或者 null 如果没有shadow root被附加。 Node 相关拓展 与 shadow DOM 相关的 Node 接口的拓展: Node.getRootNode() 方法返回上下文对象的根，可以选择包含shadow root，如果可用的话。 Node.isConnected 属性返回一个布尔值表示节点是否连接（直接或间接）到上下文对象。例如，在普通DOM的情况下为Document 对象，或者在shadow DOM的情况下为 ShadowRoot Event 拓展 与shadow DOM相关的Event 接口的扩展： Event.composed: 返回 Boolean 它表明事件是否会通过shadow DOM边界传播到标准DOM。 返回事件的路径（侦听器将被调用的对象）。如果shadow root是使用ShadowRoot.mode为closed创建的，则不包括shadow树中的节点。 6.HTML templates 包含一个HTML片段，不会在文档初始化时渲染。但是可以在运行时使用JavaScript显示。主要用作自定义元素结构的基础。关联的DOM接口是HTMLTemplateElement。 HTML 内容模板（）元素是一种用于保存客户端内容机制，该内容在加载页面时不会呈现，但随后可以 (原文为 may be) 在运行时使用 JavaScript 实例化。 web component中的一个占位符，你可以填充自己的标记，这样你就可以创建单独的DOM树并将它们呈现在一起。关联的DOM接口是HTMLSlotElement。 HTML 元素 ，作为 Web Components 技术套件的一部分，是Web 组件内的一个占位符。该占位符可以在后期使用自己的标记语言填充，这样您就可以创建单独的 DOM 树，并将它与其它的组件组合在一起。 7.示例 class ElementA extends HTMLElement { constructor() { // 必须首先调用 super 方法 super(); // 元素的功能代码写在这里 // ... } /** 生命周期 */ connectedCallback() { // 自定义元素首次插入文档dom时调用 // 相较于constructor只会执行一次，这个生命周期每次将节点连接到dom时都会调用 // 可能会执行多次(比如同一个自定义元素remove, append多次) } disconnectedCallback() { // 自定义元素从文档中删除时，调用 } adoptedCallback() { // 自定义元素移动到新的文档 // 比如使用 adoptNode 方法在多iframe下移动元素 } attributeChangedCallback(name, oldVal, newVal) { // 属性变更时调用：三个参数对应属性名，旧值，新值 } } customElements.define(name, ElementA); 8.实战 class CodeFront extends HTMLElement { constructor() { super(); const shadow = this.attachShadow({ mode: 'open' }); const span = document.createElement('span'); span.setAttribute('class', 'code-front-text'); setTimeout(() => { span.textContent = this.getAttribute('text') || '默认内容'; }, 10); const style = document.createElement('style'); style.textContent = ` .code-front-text { font-family: 微软雅黑; font-weight: 400; font-size: 80px; margin: 0 auto; color: rgba(255, 255, 255, 0.1); background: #ed8080; background: linear-gradient(to right, #ed8080 0%, #2a77d6 16%, #5eb524 32%, #eacd25 48%, #ed8080 64%, #2a77d6 80%, #5eb524 100%); filter: progid: DXImageTransform.Microsoft.gradient(startColorstr='#ed8080', endColorstr='#5eb524', GradientType=1); background-size: 300% 300%; -webkit-background-clip: text; background-clip: text; animation: shimmer infinite 3s linear; -webkit-animation: shimmer infinite 3s linear; background-repeat: no-repeat; background-position: top left; background-color: #222; } @keyframes shimmer { 0% { background-position: top left; } 100% { background-position: top right; } } `; shadow.appendChild(style); shadow.appendChild(span); } } // Define the new element customElements.define('code-front', CodeFront); // class CodeFront extends HTMLElement { // constructor() { // // Always call super first in constructor // super(); // // Create a shadow root // // open：shadow root元素可以从js外部访问根节点 // // closed：拒绝从js外部访问关闭的shadow root节点 // const shadow = this.attachShadow({ // mode: 'open' // }); // // Create div // const wrapper = document.createElement('div'); // wrapper.setAttribute('class', 'wrapper'); // // Create input // const input = document.createElement('input'); // // Define Attribute // const placeholder = this.getAttribute('placeholder'); // input.placeholder = placeholder || '暂无提示'; // // Create some CSS to apply to the shadow dom // const style = document.createElement('style'); // style.textContent = ` // .wrapper{ // display: inline-block; // } // `; // wrapper.appendChild(input); // shadow.appendChild(style); // shadow.appendChild(wrapper); // } // } // // Define the new element // customElements.define('code-front', CodeFront); angular的变化检测机制 参考： https://blog.csdn.net/zyxzp2012/article/details/90208489 什么是变更检测 变更检测的基本任务是获得程序的内部状态并使之在用户界面可见。这个状态可以是任意的数据类型。 引起变更原因 异步（Event、xhr、定时器）操作改变了程序的状态，导致视图的更新。 Angular 内的处理 Angular 有着自己的zone，称为NgZone。Angular源码的某个地方，有一个东西叫做ApplicationRef，它监听NgZones的onTurnDone事件。只要这个事件发生了，它就执行tick()函数，这个函数执行变更检测 // 真实源码的非常简化版本。 class ApplicationRef { changeDetectorRefs:ChangeDetectorRef[] = []; constructor(private zone: NgZone) { this.zone.onTurnDone.subscribe(() => this.zone.run(() => this.tick()); } tick() { this.changeDetectorRefs .forEach((ref) => ref.detectChanges()); } } 变更检测 在 Angular 中，每个组件都有它自己的 change detector (变更检测器) ChangeDetectorRef Angular 各种视图的基础类，提供变更检测功能。 变更检测树会收集要检查的所有视图。 使用这些方法从树中添加或移除视图、初始化变更检测并显式地把这些视图标记为脏的，意思是它们变了、需要重新渲染。 OnPush 的两种状态：https://angular.cn/api/core/ChangeDetectionStrategy 主要方法： abstract markForCheck(): void abstract detach(): void abstract detectChanges(): void abstract checkNoChanges(): void abstract reattach(): void 变更监听值变化及自定义变更： ngOnChanges：检测监听值的变更 ngDoCheck：检测和处理 Angular 自己没有捕捉到的变化，可自定义变更检测逻辑 组件注入 ChangeDetectorRef，并调用 markForCheck 方法，会告诉Angular，标记整条路径，从这个组件到根组件都需要被checked，一旦变更检测结束，它就会恢复为整棵树恢复OnPush状态 示例 app.conponent.ts import { ChangeDetectionStrategy, Component } from '@angular/core'; @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'], changeDetection: ChangeDetectionStrategy.OnPush }) export class AppComponent { text = ''; constructor() { } ngOnInit(): void { } } app.conponent.html app-child.ts import { ChangeDetectionStrategy, Component, EventEmitter, Input, OnInit, Output, SimpleChanges } from '@angular/core'; @Component({ selector: 'app-child', templateUrl: './child.component.html', styleUrls: ['./child.component.scss'], changeDetection: ChangeDetectionStrategy.OnPush }) export class ChildComponent implements OnInit { @Input() text = ''; @Output() textChange = new EventEmitter(); obj = { currentValue: '', previousValue: '' } constructor() { } ngOnInit(): void { } ngOnChanges(changes: SimpleChanges): void { console.log(changes); this.obj.currentValue = changes['text'].currentValue; this.obj.previousValue = changes['text'].previousValue; } change() { this.textChange.emit(this.text); } } app-child.html currentValue： previousValue： Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-08-04 10:34:07 "},"shared/内嵌视图与宿主视图.html":{"url":"shared/内嵌视图与宿主视图.html","title":"内嵌视图与宿主视图","keywords":"","body":"内嵌视图与宿主视图 内嵌视图 - 连接到模板的嵌入视图，在组件模板元素中添加模板(DOM元素、DOM元素组) 宿主视图 - 连接到组件的嵌入视图，在组件元素中添加别的组件 ElementRef - 单个HTML元素；用于获取DOM元素； TemplateRef - 一组HTML元素；可以用来创建ViewRef类型的视图(TemplateRef元素实例.createEmbeddedView(null)，也可以作为TemplateRef对象插入到ViewContainerRef实例中； ViewContainerRef - 视图容器，任何DOM元素都可以作为视图容器使用; 它可以用来创建和管理内嵌视图； 内嵌视图： 我是容器 我是模板 好无聊~ 卷起来！！！ export class MainComponent implements AfterViewInit { constructor() { } @ViewChild('container', { read: ViewContainerRef }) container: ViewContainerRef; @ViewChild('tmpl', { static: false }) temp: TemplateRef; ngAfterViewInit() { // 创建内嵌视图 - 以下任意一种方法都可以,insert方法需要一个ViewRef类型的视图 this.container.insert(this.temp.createEmbeddedView(null)); // 添加内嵌视图 // this.container.createEmbeddedView(this.temp); // 创建内嵌视图 } } 宿主视图： // 组件切换链接 home list detail // 动态组件容器 import { Component, ComponentFactoryResolver, OnInit, Type, ViewChild, ViewContainerRef } from '@angular/core'; import { DetailComponent } from 'src/app/detail/detail.component'; import { HomeComponent } from 'src/app/home/home.component'; import { ListComponent } from 'src/app/list/list.component'; @Component({ selector: 'app-main', templateUrl: './main.component.html', styleUrls: ['./main.component.scss'] }) export class MainComponent implements OnInit { @ViewChild('container', { read: ViewContainerRef }) container: ViewContainerRef; data = { 'home': HomeComponent, 'list': ListComponent, 'detail': DetailComponent }; constructor( private componentFactoryResolver: ComponentFactoryResolver ) { } ngOnInit(): void { } ngAfterViewInit(): void { this.loadComponent(this.data.home); } loadComponent(compoennt: Type) { const com = this.componentFactoryResolver.resolveComponentFactory(compoennt); this.container.clear(); this.container.createComponent(com); } load(name: string) { this.loadComponent(this.data[name]); } } ng13开始，废弃 ComponentFactoryResolver https://angular.cn/api/core/ComponentFactoryResolver https://angular.cn/api/core/ViewContainerRef @Directive({ … }) export class MyDirective { constructor( private viewContainerRef: ViewContainerRef, private componentFactoryResolver: ComponentFactoryResolver ) {} createMyComponent() { const componentFactory = this.componentFactoryResolver.resolveComponentFactory(MyComponent); this.viewContainerRef.createComponent(componentFactory); } } @Directive({ … }) export class MyDirective { constructor(private viewContainerRef: ViewContainerRef) {} createMyComponent() { this.viewContainerRef.createComponent(MyComponent); } } Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-11-29 16:39:21 "},"shared/技术选型及代码规范.html":{"url":"shared/技术选型及代码规范.html","title":"技术选型及代码规范","keywords":"","body":"概述 本期演讲内容包含: 技术选型 项目架构及框架对比 模块化分析 Less 与 Scss 相关技术演示 技术选型 前端三剑客：Angular、Vue、React UI库(或框架)：ng-zorro-antd、ng-zorro-mobile、IONIC、Boopstrap 5.0.0-alpha1等 UI(或代码)规范：antd规范、网易代码规范 中后台解决方案：ng-alain、antd-vue-pro 项目管理：git、svn 接口规范：RESTful API规范、swagger 附：ng-zorro-antd 官方群：320404326 ng-alain 官方群：316911865 前端在线调试工具：https://stackblitz.com/ git 简易视频教程：https://www.bilibili.com/video/BV1BE411g7SV 什么是Swagger？ Swagger 是一个规范且完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。 Swagger 的目标是对 REST API 定义一个标准且和语言无关的接口，可以让人和计算机拥有无须访问源码、文档或网络流量监测就可以发现和理解服务的能力。当通过 Swagger 进行正确定义，用户可以理解远程服务并使用最少实现逻辑与远程服务进行交互。与为底层编程所实现的接口类似，Swagger 消除了调用服务时可能会有的猜测。 Swagger 有什么优势？ 支持 API 自动生成同步的在线文档：使用 Swagger 后可以直接通过代码生成文档，不再需要自己手动编写接口文档了，对程序员来说非常方便，可以节约写文档的时间去学习新技术。 提供 Web 页面在线测试 API：光有文档还不够，Swagger 生成的文档还支持在线测试。参数和格式都定好了，直接在界面上输入参数对应的值即可在线测试接口。 项目架构及框架对比 目前：PC端 使用：angular+ng-zorro-antd 移动端 使用：angular+IONIC 静态单页面可使用：bootstrap 针对不同的业务需求，选择相应的技术栈。 附：静态项目可使用CDN加速链接：https://www.bootcdn.cn/ 模块化分析 模块化分为 CMD、AMD、CommonJs AMD 是RequireJS在推广过程中对模块定义的规范化产出，通过define()函数定义，第一个参数是一个数组，里面定义一些需要依赖的包，第二个参数是一个回调函数，代表：RequireJS CMD 是SeaJS在推广过程中对模块定义的规范化产出，是一个同步模块定义，是SeaJS的一个标准，SeaJS是CMD概念的一个实现，SeaJS是淘宝团队提供的一个模块开发的js框架，代表：SeaJS CommonJS 是通过module.exports定义的，在前端浏览器里面并不支持module.exports，通过node.js后端使用的。Nodejs端是使用CommonJS规范的，前端浏览器一般使用AMD、CMD、ES6等定义模块化开发，写法有：module export 和 exports.xx(参数)两种， 代表：CommonJS 模块化及组件化 模块化（按功能） -> 汽车组装 = 车架+车门+车轮+发动机等 组件化（按最小元部件）-> 车轮 = 橡胶轮胎+轮轴+轮架子等 Less 与 Scss Less中文官网：http://lesscss.cn/ 简述： Sass和Less都属于Css预处理器，Css预处理器定义了一种新的语言，其基本思想是用一种专门的编程语言，为Css增加一些编程的特性，将Css作为目标生成文件，然后开发者使用这种语言进行Css编码工作(用一种专门的编程语言，进行Web网页样式设计，再通过编译器转化为正常的Css文件，以供项目使用)。写法大体相同。 其中Scss分2种：1.Sass：格式严谨，写法类同python。2.Scss：可与普通写法嵌套 共同点： 混合(Mixins):将一个定义好的classA引入到另一个classB中，从而简单实现classB继承了classA的所有属性； 参数混合(Parametric):可以像函数一样传递参数的class 嵌套规则：class中嵌套class,从而减少重复的代码 运算：css中的数学计算 颜色功能：可以编辑你的颜色 命名空间：样式分组，从而方便被调用 作用域：局部修改样式 JavaScript表达式：在css样式中使用javaScript表达式赋值 附：css、less、scss相互转换工具：http://koala-app.com/ Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-11-29 10:58:27 "},"shared/模块化 AMD、CommonJS、ES6.html":{"url":"shared/模块化 AMD、CommonJS、ES6.html","title":"模块化 AMD、CommonJS、ES6","keywords":"","body":"前端模块化发展历史 (CommonJS、AMD、CMD、UMD、ES6) 参考： https://zhuanlan.zhihu.com/p/337946057 https://blog.51cto.com/lengyuexin/4960989** https://juejin.cn/post/6844903927104667662** https://zhuanlan.zhihu.com/p/55407719 https://www.cnblogs.com/dolphinX/p/4381855.html https://juejin.cn/post/6844903848511799303 模块化起源 JavaScript发展之初，只是为了解决基础的表单验证问题，以及基础的页面交互，代码非常简单，不存在模块化的概念和问题。但是随着ajax的发展，web进入2.0时代，JavaScript成为一门应用非常广泛的语言。 这个时候js作为一门嵌入型语言，劣势就展示出来了，没有一个权威的规范，问题总是要解决，在前端发展的这几十年，也就顺势而为的产生了很多的js规范。 模块化规范是什么 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起，完成指定工作。 能做什么 能帮助我们更好的管理各个js文件，处理不同模块间的依赖关系。 早期模块化三种方式： 1.函数 在最早的js中，想要实现分模块开发，最简单的就是函数，因为函数能形成一个相对封闭的空间，通过函数来实现简单的模块化也是最早的解决方案 function model1 = { } function model2 = { } 缺点 1、污染全局作用域 2、维护成本高（命名容易冲突） 3、依赖关系不明显 2.对象 对象里面可以包含属性和方法，就相当于一个容器了，我们可以把每个模块的代码写到一个对象里面，从而实现模块化的目的 var model1 = { age: 11, say() { console.log(age) } } var model2 = { age: 15, say() { console.log(age) } } 缺点 外部可以修改模块内部状态，可以随意修改每个模块的某个属性，有相当的安全隐患 3.自执行函数 IIFE(immediately invoked function expression)，也就是我们说的自执行函数，通过定义一个匿名函数，创建了一个“私有”的命名空间，该命名空间的变量和方法，不会破坏全局的命名空间 var module = (function(){ 　　var age = 11 var say = function(){ console.log(age) } return {say}; })(); module.say(); //11 console.log(module.age) //undefined 缺点 外部无法访问内部私有变量 三种模块化规范： 1.CommonJS（代表：node.js） 前端真正提出模块化的概念，就是从commonJs的诞生开始的， 因为js作为一门嵌入型语言，处理页面逻辑和交互，即使没有模块化也能运行，并不会出什么问题，但是服务端却必须要有模块的概念。所以commonJs的发扬光大和nodejs相关，尤其是近几年nodejs的应用越来越广泛，npm统治整个前端以后，commonJs规范因此被大家熟知。 定义模块 根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性 模块输出 模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象 加载模块 加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象 // model1.js var age = 11 function say(){ console.log(age); } module.exports = { say } // index.html var wu = require('./index.js'); console.log(wu.say) 优点 解决了依赖、全局变量污染的问题 缺点 1.同步加载 CommonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，CommonJS不适合浏览器端模块加载，合理的方案是使用异步加载。 2.浏览器不能用 2.AMD（代表：RequireJS） AMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。 AMD规范使用依赖注入的模式，所有当前模块依赖的模块，都要通过异步来调用，执行语句放在回调函数里面。不依赖其他模块的语句，就不要放在回调函数里面，不干扰其他模块的运行。 CommonJS 规范主要是为服务器端的 NodeJS 服务，服务器端加载模块文件无延时，但是在浏览器上就大不相同了。AMD 即是为了在浏览器宿主环境中实现模块化方案的规范之一。 由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。 下载地址：https://requirejs.org/docs/release/2.3.6/comments/require.js AngularJS+RequireJS是符合AMD规范的。 引入依赖 模块定义 由 define 方法来定义，在 define API 中： id：模块名称，或者模块加载器请求的指定脚本的名字； dependencies：是个定义中模块所依赖模块的数组，默认为 [“require”, “exports”, “module”] factory：为模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值； // hello.js define('hello', function (x, y){ var add = function (x,y){ console.log(x, y) // 1, 2 　 return x+y; 　}; return { 　 add: add 　}; }); 模块引入 require()函数接受两个参数 第一个参数是一个数组，表示所依赖的模块 第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块 // main.js require.config({ 'baseUrl': './js', 'paths': { 'hello': './hello' } }) define('main', function() { require(['hello'], function(hello) { console.log(hello.add(1, 2)) // 3 }) }) require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。 3.CMD（代表：Sea.js） CMD 全称为 Common Module Definition，是 Sea.js 所推广的一个模块化方案的输出。 在 CMD define 的入参中，虽然也支持包含 id, deps 以及 factory 三个参数的形式，但推荐的是接受 factory 一个入参，然后在入参执行时，填入三个参数 require、exports 和 module： 模块定义 require是可以把其他模块导入进来的一个参数; 而exports是可以把模块内的一些属性和方法导出的; module 是一个对象，上面存储了与当前模块相关联的一些属性和方法。 define(function(require, exports, module) { // 每个函数单独导出 exports.add = function(x, y) { return x + y; } }); 引用模块 define(function(require, exports, module) { var hello = require('hello'); console.log(hello.add(2,3)); // 单独导出 exports.init = function init() { console.log('init'); } }); html调用 seajs.config({ base: './js', // 后续引用基于此路径 alias: { // 别名，可以用一个名称 替代路径（基于base路径） hello: './js/hello.js' }, }); // 加载入口模块 seajs.use(\"./main.js\", function(main) { main.init(); // init }); AMD和CMD的区别 关于这两种的区别网上有很多版本，大体意思差不多： AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 CMD推崇就近依赖，只有在用到某个模块的时候再去require 所以从这一点上来看，两者在性能上并没有太多差异。因为最影响页面渲染速度的当然是资源的加载速度，既然都是预加载，那么加载模块资源的耗时是一样的（网络情况相同时）。 UMD UMD，全称 Universal Module Definition，即通用模块规范。 既然 CommonJs 和 AMD 风格一样流行，那么需要一个可以统一浏览器端以及非浏览器端的模块化方案的规范。 现在主流框架的源码都是用的UMD规范，因为它既可以兼容浏览器端又可以兼容node。 UMD的实现： 先判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块； 再判断是否支持 Node.js 模块格式（exports 是否存在），存在则使用 Node.js 模块格式； 前两个都不存在，则将模块公开到全局（window 或 global）； Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-12-02 09:14:13 "},"typescript/进阶及高级用法.html":{"url":"typescript/进阶及高级用法.html","title":"进阶及高级用法","keywords":"","body":"参考：https://zhuanlan.zhihu.com/p/503812618 TS 是一种静态类型检测，并不会执行你的代码 泛型（type） 把明确类型的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型，简单点来讲我们可以将泛型理解成为把类型当作参数一样去传递 接口泛型位置不同，效果也会不同。 泛型约束 所谓泛型约束，通俗点来讲就是约束泛型需要满足的格式。 解决泛型约束方法，使用extends 关键字 。 extends extends 关键字在声明泛型时约束泛型需要满足的条件 keyof 运算符 运算符采用keyof对象类型并生成其键的字符串或数字文字联合 is（关键字） is 关键字其实更多用在函数的返回值上，用来表示对于函数返回值的类型保护 | （条件类型或分发） type isString = T extends string ? true : false; // a 的类型为 true let a: isString // b 的类型为 false let b: isString; 循环 interface IProps { name: string; age: number; highSchool: string; university: string; } // IPropsKey类型为 // type IPropsKey = { // name: boolean; // age: boolean; // highSchool: boolean; // university: boolean; // } type IPropsKey = { [K in keyof IProps]: boolean }; Exclude（类型排除） type TypeA = string | number | boolean | symbol; // ExcludeSymbolType 类型为 string | number | boolean，排除了symbol类型 type ExcludeSymbolType = Exclude; 类型兼容性（多的可以赋给少的） 分发的参数类型多的可赋给少的，但方法只能是参数类型少的赋值给多的 infer（待推断类型） infer 代表待推断类型，它的必须和 extends 条件约束类型一起使用 type Flatten = Type extends Array ? Item : Type; 逆变（少的可以赋给多的，与类型兼容性相反） 函数的参数的方式被称为逆变。 let fn1!: (a: string, b: number) => void; let fn2!: (a: string, b: number, c: boolean) => void; fn1 = fn2; // TS Error: 不能将fn2的类型赋值给fn1 let fn1!: (a: string, b: number) => void; let fn2!: (a: string, b: number, c: boolean) => void; fn2 = fn1; // 正确，被允许 unknown & any（任意类型） 对于以后并不确定类型的变量尽量使用更多的 unknown 来代替 any 让你的代码更加强壮 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-04-28 15:46:00 "},"vue/devtools.html":{"url":"vue/devtools.html","title":"devtools","keywords":"","body":"Devtools 安装及使用 克隆官方项目 git clone https://github.com/vuejs/devtools.git 安装依赖 # 官方使用的是 yarn，所以使用 yarn 进行安装，否则会报错 yarn install 打包 yarn run build 使用 chrome 更多工具 -> 扩展程序 -> 启用开发者模式 -> 加载已解压的扩展程序，把项目的 packages/shell-chrome 文件夹导入即可。 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-05-04 14:07:15 "},"vue/vue3.0.html":{"url":"vue/vue3.0.html","title":"vue3","keywords":"","body":"Vue 3.0 官网：https://v3.cn.vuejs.org/guide/migration/introduction.html 冷启动/热启动 冷启动 当启动应用时，后台没有该应用的进程，这时系统会重新创建一个新的进程分配给该应用，这个启动方式就是冷启动。 热启动 当启动应用时，后台已有该应用的进程（例：按home键回到桌面，但是该应用的进程是依然会保留在后台，可进入任务列表查看），所以在已有进程的情况下，这种启动会从已有的进程中来启动应用，这个方式叫热启动。 vite 介绍 参考地址：https://baijiahao.baidu.com/s?id=1684779666333900793&wfr=spider&for=pc Vite是Vue的作者尤雨溪开发的Web开发构建工具，它是一个基于浏览器原生ES模块导入的开发服务器，在开发环境下，利用浏览器去解析import，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随启随用。同时不仅对Vue文件提供了支持，还支持热更新，而且热更新的速度不会随着模块增多而变慢。在生产环境下使用Rollup打包。 vite 特点 1.快速的冷启动 2.即时热模块更新（HMR，Hot Module Replacement） 3.真正按需编译 Vite是在推出Vue 3的时候开发的，目前仅支持Vue 3.x，这意味着与Vue 3不兼容的库也不能与Vite一起使用。 安装/起步 通过脚手架 Vite npm init @vitejs/app hello-vue3 # OR yarn create @vitejs/app hello-vue3 通过脚手架 vue-cli npm install -g @vue/cli # 或 yarn global add @vue/cli vue create hello-vue3 新特性 组合式 API Teleport 片段 触发组件选项 来自 @vue/runtime-core 的 createRenderer API 创建自定义渲染器 单文件组件组合式 API 语法糖 () 单文件组件状态驱动的 CSS 变量 () 单文件组件 `` 现在可以包含全局规则或只针对插槽内容的规则 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2021-11-18 15:05:29 "},"vue/vue3.0开发事项.html":{"url":"vue/vue3.0开发事项.html","title":"vue3","keywords":"","body":"找不到模块“@/xxx”或其相应的类型声明 https://www.cnblogs.com/JasmineHan/p/13673560.html Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2021-11-18 15:06:00 "},"vue/vue细节处理.html":{"url":"vue/vue细节处理.html","title":"vue细节处理","keywords":"","body":"Vue细节处理 语法糖 v-bind: : // 绑定属性，如果属性有大写，需使用kebab-case方式绑定 v-on: @ // 绑定事件 v-slot: # // 指定插槽名称，默认为#default，必须带参 组件名大小写（2种） kebab-case(短横线隔开式) PascalCase(驼峰式) v-model基本原理 等价于： 将原生事件绑定到组件 .native可直接监听原生事件 eg: 注意：在app、小程序端和h5端表现不一致，h5端获取到的是浏览器原生事件 子组件数据同步更新到父组件 当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定。 .sync 它会被扩展为一个自动更新父组件属性的 v-on 监听器 eg： 插槽（匿名插槽、具名插槽、作用于插槽） 子组件 template 中没有包含一个 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃（即：子组件内容会被丢弃） 一个不带 name 的 出口会带有隐含的名字 “default” Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-04-28 16:56:31 "},"workflow/drone.html":{"url":"workflow/drone.html","title":"drone","keywords":"","body":"Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-05-13 15:11:46 "}}