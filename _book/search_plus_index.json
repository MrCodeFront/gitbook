{"./":{"url":"./","title":"前言","keywords":"","body":"前言 欢迎阅读 CodeFront 笔记 我们的口号是：日积月累，提升自我！ 作者正在内卷中... Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-03-30 13:26:32 "},"android/Android学习.html":{"url":"android/Android学习.html","title":"Android学习","keywords":"","body":"Android 学习 词汇 AVD（安卓虚拟设备） 应用组件(共4种) 1.Activity 2.服务 3.广播接收器 4.内容提供程序 https://developer.android.google.cn/guide/components/fundamentals Activity 是与用户交互的入口点。它表示拥有界面的单个屏幕. 服务 是一个通用入口点，用于因各种原因使应用在后台保持运行状态。它是一种在后台运行的组件，用于执行长时间运行的操作或为远程进程执行作业。服务不提供界面。 借助广播接收器组件，系统能够在常规用户流之外向应用传递事件，从而允许应用响应系统范围内的广播通知。 内容提供程序 管理一组共享的应用数据，您可以将这些数据存储在文件系统、SQLite 数据库、网络中或者您的应用可访问的任何其他持久化存储位置。 在 Android 系统启动应用组件之前，系统必须通过读取应用的清单文件 (AndroidManifest.xml) 确认组件存在。您的应用必须在此文件中声明其所有组件，该文件必须位于应用项目目录的根目录中。 Android API https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element#ApiLevels 什么是API级别 API 级别是对 Android 平台版本提供的框架 API 修订版进行唯一标识的整数值。 Android 平台提供一种框架 API，应用可利用它与底层 Android 系统进行交互。该框架 API 由以下部分组成： 一组核心软件包和类 一组用于声明清单文件的 XML 元素和属性 一组用于声明和访问资源的 XML 元素和属性 一组 Intent 一组应用可请求的权限，以及系统中包括的权限强制执行 Android 平台的每个后续版本均可包括其提供的 Android 应用框架 API 的更新。 框架 API 更新的设计用途是使新 API 与早期版本的 API 保持兼容。换言之，大多数 API 更改都是新增更改，并且会引入新功能或替代功能。在 API 的某些部分得到升级时，系统会弃用经替换的旧版部分，但不会将其移除，以便其仍可供现有应用使用。在极少数情况下，系统可能会修改或移除 API 的某些部分，但通常只有在为确保 API 稳健性以及应用或系统安全性时，才需要进行此类更改。所有其他来自早期修订版的 API 部分都将继续保留，不做任何修改。 Android 平台提供的框架 API 使用称为“API 级别”的整数标识符指定。每个 Android 平台版本恰好支持一个 API 级别，但隐含对所有早期 API 级别（低至 API 级别 1）的支持。Android 平台初始版本提供的是 API 级别 1，后续版本的 API 级别则依次增加。 Android Studio 与 逍遥模拟器 连接 查看Microvirt\\MEmu\\MemuHyperv VMs\\MEmu目录下MEmu.memu的端口号。cmd 到逍遥模拟器Microvirt\\MEmu目录下，运行:adb.exe connect 127.0.0.1 看见 connected to 127.0.0.1:21503 表示连接成功 官方demo讲解: https://www.it610.com/article/1297923636153360384.htm Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2021-11-18 15:08:38 "},"android/打包.html":{"url":"android/打包.html","title":"打包","keywords":"","body":"Android 打包 自定义apk名称 路径：app/build.gradle android { android.applicationVariants.all { variant -> variant.outputs.all { //在这里修改apk文件名 outputFileName = \"01-cutting-supermarket-v${new String(variant.versionName).replace('.','')}.apk\" } } } 修改版本号 路径：app/build.gradle versionName 路径：app/build/generated/source/buildConfig/debug/io/ionic/starter/BuildConfig.java VERSION_NAME Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-03-30 13:26:32 "},"android/环境搭建.html":{"url":"android/环境搭建.html","title":"环境搭建","keywords":"","body":"Android开发环境配置 参考：https://www.jianshu.com/p/c3a8a158edf4 gradle各版本快速下载地址大全：https://blog.csdn.net/ii950606/article/details/109105402 java环境配置 1、下载安装jdk 官网下载：https://www.oracle.com/java/technologies/javase-downloads.html 百度云网盘：https://pan.baidu.com/s/1VXwMXlgqYCzBPUKjWDev6g 提取码：i4yr 2、配置环境变量 在系统变量里新建，变量名随便取，变量值是你安装的路径，到bin目录的上一层。如下图： 增加java环境变量 然后，在系统变量中找到Path，双击或者点击编辑，然后点击新建，输入%设定的变量名%\\bin,点击确定即可，如下图： 编辑Path 在系统路径中添加jdk安装路径 至此，你就完成了java的环境配置，下面可以打开命令行进行验证： 查看jdk版本 adb环境配置 1、下载安装Android studio 官网下载：https://developer.android.google.cn/studio/ 官网下载速度挺快的，就不贴网盘了，取官网下载安装即可。 2、配置adb环境 安装好Android studio后，可以在File->Project Structure->SDK Location中查看Android sdk位置，adb就在sdk目录下，找到目录下platform-tools和tools两个文件夹，如图： sdk路径 sdk目录 然后，打开系统环境变量，新建一个变量，变量名随便取，变量值取sdk目录路径，取到platform-tools和tools两个文件夹的上一级目录，如图： 新建Android_home 之后，找到Path，将ANDROID_HOME加到系统环境变量中，如图： 加到系统变量 至此就完成了adb的环境配置，可以在命令行输入adb验证，如图： cmd中验证adb 注：如在Android Studio的Terminal下输入adb提示不是内部命令，关掉重新打开软件即可。 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-05-16 11:20:29 "},"angular/ag-grid开发问题.html":{"url":"angular/ag-grid开发问题.html","title":"ag-grid开发问题","keywords":"","body":"ag-grid 开发问题 表头过滤日期过滤器及单元格日期选择格式不对会导致过滤失效、单元格数据编辑后被清空等问题 问题参考： https://plnkr.co/edit/RBknsEaK857lDlbu?open=index.jsx https://plnkr.co/edit/RBknsEaK857lDlbu?open=index.jsx 具体解决： Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 14:55:05 "},"angular/ag-grid表格.html":{"url":"angular/ag-grid表格.html","title":"ag-grid表格","keywords":"","body":"官网：https://www.ag-grid.com/ 中文网：https://www.itxst.com/ag-grid/tutorial.html 参考： https://blog.csdn.net/Jane_2160/article/details/128468734 https://www.mianshigee.com/project/www.ag-grid.com AgGrid使用经验汇总 问题收集： https://www.likecs.com/ask-4156049.html https://blog.csdn.net/WQearl/article/details/120273977（设置行高） 列表头 https://www.ag-grid.com/angular-data-grid/column-headers/ // Group columns this.groupHeaderHeight = 75; // Label columns this.headerHeight = 150; // Floating filter this.floatingFiltersHeight = 50; // Pivoting, requires turning on pivot mode. Label columns this.pivotHeaderHeight = 100; // Pivoting, requires turning on pivot mode. Group columns this.pivotGroupHeaderHeight = 50; 列分组 https://www.ag-grid.com/angular-data-grid/column-groups/ 对于可展开组，要保持打开/关闭状态，需要在列组定义中指定groupId。 this.columnDefs = [ { headerName: 'Athlete Details', children: [ { field: 'athlete' }, { field: 'age' }, { field: 'country' }, ] }, { headerName: 'Sports Results', groupId: 'Sports Results', children: [ { field: 'sport' }, { field: 'total', columnGroupShow: 'closed' }, { field: 'gold', columnGroupShow: 'open' }, { field: 'silver', columnGroupShow: 'open' }, { field: 'bronze', columnGroupShow: 'open' }, ] } ]; 列固定 https://www.ag-grid.com/angular-data-grid/column-pinning/ this.columnDefs = [ { field: 'athlete', pinned: 'left' } ]; 列拖拽 https://www.ag-grid.com/angular-data-grid/column-moving/ 行标识 https://www.ag-grid.com/angular-data-grid/row-ids/ // assumes each data item provided by the application has the ID stored in an attribute called id this.getRowId = params => params.data.id; null vs undefined https://www.ag-grid.com/angular-data-grid/column-state/#null-vs-undefined null与undefined对于所有的状态属性，undefine表示“不应用此属性”，null表示“清除此属性”。 例如，设置sort=null将清除列上的排序，而设置sort=undefined将保留当前存在的任何排序（如果有的话）。 唯一的例外是关于列宽。对于宽度，undefined和null都将跳过该属性。这是因为宽度是强制性的——不存在没有宽度的列。 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-16 11:16:29 "},"angular/ag-grid表格配置及属性描述.html":{"url":"angular/ag-grid表格配置及属性描述.html","title":"ag-grid表格配置及属性描述","keywords":"","body":"内置表单控件 1.Text Field（文本输入框）：用于接收文本输入。 2.Numeric Text Field（数字输入框）：用于接收数字输入。 3.Text Area（文本域）：用于接收多行文本输入。 4.Select (Dropdown)（下拉选择框）：用于从预定义选项中选择一个值。 5.Checkbox（复选框）：用于表示二进制选项的状态。 6.Radio Button（单选按钮）：用于从一组选项中选择一个值。 7.Date Picker（日期选择器）：用于选择日期。 8.Range Slider（范围滑块）：用于通过滑动选择数值范围。 agTextCellEditor // 输入框 agNumericCellEditor // 数字输入框 agLargeTextCellEditor // 多行文本框 agSelectCellEditor // 下拉选择框 agCheckboxCellEditor // 复选框 agRadioCellEditor // 单选 agDateCellEditor // 日期选择框 agRangeCellEditor // 开关 // example // 输入框 { headerName: 'Name', field: 'name', cellEditor: 'agTextCellEditor', editable: true }, // 数字输入框 { headerName: 'Age', field: 'age', cellEditor: 'agNumericCellEditor', editable: true }, // 多行文本框 { headerName: 'Description', field: 'description', cellEditor: 'agLargeTextCellEditor', editable: true }, // 下拉选择框 { headerName: 'Status', field: 'status', cellEditor: 'agSelectCellEditor', cellEditorParams: { values: ['Active', 'Inactive'] }, editable: true }, // 复选框 { headerName: 'Completed', field: 'completed', cellEditor: 'agCheckboxCellEditor', editable: true }, // 单选 { headerName: 'Gender', field: 'gender', cellEditor: 'agRadioCellEditor', cellEditorParams: { values: ['Male', 'Female'] }, editable: true }, // 日期选择框 { headerName: 'DOB', field: 'dob', cellEditor: 'agDateCellEditor', editable: true }, // 开关 { headerName: 'Salary Range', field: 'salary', cellEditor: 'agRangeCellEditor', editable: true }, Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-08-28 13:58:08 "},"angular/i18n（国际化方案）.html":{"url":"angular/i18n（国际化方案）.html","title":"i18n（国际化方案）","keywords":"","body":"i18n（国际化方案） 参考： https://www.cnblogs.com/dawnwill/p/11045801.html https://www.jianshu.com/p/dae17d7d44e3 引言 i18n（其来源是英文单词 internationalization的首末字符i和n，18为中间的字符数）是“国际化”的简称。在资讯领域，国际化(i18n)指让产品（出版物，软件，硬件等）无需做大的改变就能够适应不同的语言和地区的需要。对程序来说，在不修改内部代码的情况下，能根据不同语言及地区显示相应的界面。 在全球化的时代，国际化尤为重要，因为产品的潜在用户可能来自世界的各个角落。通常与i18n相关的还有L10n（“本地化”的简称）。 Angular 将使用 @ngx-translate/core 和 @ngx-translate/http-loader实现国际化方案。 安装 根据Angular 版本选择好对应的版本号 npm install @ngx-translate/core@9.1.1 --save npm install @ngx-translate/http-loader@2.0.1 --save 在app.module.ts配置 // app.module.ts import {BrowserModule} from '@angular/platform-browser'; import {BrowserAnimationsModule} from '@angular/platform-browser/animations'; import {NgModule} from '@angular/core'; import {AppRoutingModule} from './app-routing.module'; import {FormsModule} from '@angular/forms'; import {HttpClient, HttpClientModule} from '@angular/common/http'; import {TranslateHttpLoader} from '@ngx-translate/http-loader'; import {TranslateLoader, TranslateModule} from '@ngx-translate/core'; // 这里配置 export function createTranslateHttpLoader(http: HttpClient) { return new TranslateHttpLoader(http, './assets/i18n/', '.json'); } @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, AppRoutingModule, FormsModule, HttpClientModule, BrowserAnimationsModule, // 在这里配置 TranslateModule.forRoot({ loader: { provide: TranslateLoader, useFactory: (createTranslateHttpLoader), deps: [HttpClient] } }) ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } 新建json文件 在assets 新建文件夹 i18n,在i18n文件下下新建zh.json 和 en.json 文件，分别表示中文和英文。 // zh.json 不要在json文件写注释，会报错 { \"hello\": \"你好\", \"header\": { \"author\": \"早上好\" } } // en.json 不要在json文件写注释，会报错 { \"hello\": \"Hello\", \"header\": { \"author\": \"Good morning\" } } 获取浏览器默认语言 app.component.ts 文件获取浏览器默认语言，如果不是英语和中文，就默认设置为中文。 import {Component, OnInit} from '@angular/core'; import {TranslateService} from '@ngx-translate/core'; @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css'] }) export class AppComponent implements OnInit { title = 'app'; constructor(public translateService: TranslateService) { } ngOnInit() { /* --- set i18n begin ---*/ this.translateService.addLangs(['zh', 'en']); this.translateService.setDefaultLang('zh'); const browserLang = this.translateService.getBrowserLang(); this.translateService.use(browserLang.match(/zh|en/) ? browserLang : 'zh'); /* --- set i18n end ---*/ } } 通过以上配置，即可根据浏览器语言设置来加载国际化语言 // {{'hello' | translate}} // {{'header.author' | translate}} // 嵌套的这样书写 手动选择语言 languageBtn; language; constructor(public translateService: TranslateService) { } ngOnInit() { const browserLang = this.translateService.getBrowserLang(); this.settingBtn(browserLang); } /*设置btn的文字和需要传递的参数*/ settingBtn(language: string) { if (language === 'zh') { this.languageBtn = 'English'; this.language = 'en'; } else { this.languageBtn = '中文'; this.language = 'zh'; } } /*切换语言*/ changeLanguage(lang: string) { console.log(lang); this.translateService.use(lang); this.settingBtn(lang); } Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-23 17:17:03 "},"angular/Overlay遮罩.html":{"url":"angular/Overlay遮罩.html","title":"Overlay遮罩","keywords":"","body":"Overlay 遮罩 参考： https://zhuanlan.zhihu.com/p/146943731 github：https://github.com/angular/components/tree/7cd78ffc59c1975012b4a7913f147cedc9c97ae0/src/cdk/overlay OverlayContainer OverlayContainer 在 body 元素的最后创建了一个元素，用于包裹全部的浮层元素。之后我们会称该元素为 container element。 该元素会在 getContainerElement 方法第一次被调用的时候创建（惰性实例化）。 注意这个服务是全局的。 Overlay Overlay 是一个服务，通过它的 create 方法可以创建一个新的浮层，这个过程中主要做了以下几件事： 创建一个 host element 和一个 pane element，然后将 pane element 作为 PortalOutlet 的挂载点，而这里 PortalOutlet 的类型就是我在之前一篇文章中讲过的 DomPortalOutlet，它将会被用来挂在组件内容。 创建一个 OverlayConfig 对象，OverlayConfig 的构造方法仅仅是把 plain object 上面的非 undefined 属性转移到新创建的 OverlayConfig 对象上。 创建一个 OverlayRef 并返回，值得注意的是第一步中创建的 PortalOutlet 会被传递给 OverlayRef 的构造方法。 OverlayRef 类非常重要，它负责了浮层机制的绝大部分逻辑，并且是暴露给组件开发者操纵浮层的接口对象。 OverlayRef OverlayRef 的构造方法确定了该浮层的 scroll strategy 和 position strategy，这部分我们之后来谈。 组件开发者在新创建的浮层上添加组件时，应该调用 OverlayRef 的 attach 方法，参数应该是一个 Portal 对象。这个方法做了如下几件事情： 将 Portal attach 到 DomPortalOutlet 上，这一步会动态创建组件开发者定义的内容 启用 position strategy 通过 _updateStackingOrder 方法更新 host element 在 container element 中的位置，最新创建的浮层应该在 DOM 树的最上方 通过 _updateElementSize 方法更新 pane element 元素的样式 启用 scroll strategy 在 Angular zone 稳定之后（一般是组件 DOM 已经创建）调整浮层的位置 打开浮层的鼠标事件支持 根据配置创建 backdrop（之后再讲） 根据配置修改 pane element 的 CSS 类 派发 attach 事件 将自己注册到 KeyboardDispatcher 中（之后再讲） OverlayRef 类还有以下几个重要的方法： detach，卸载当前浮层添加的组件。 dispose，销毁当前浮层。 PositionStrategy attach 方法的第二步是启用 position strategy，这里我们先来讲解比较简单的 GlobalPositionStrategy，也是 BottomSheet 组件所使用的。 position strategy 就是定位策略，提供了一组定位浮层内元素的方法。 GlobalPositionStrategy 实现了 PositionStrategy 接口，用户也可以通过实现该接口自定义一个 position strategy。 attach 方法在浮层启用 position strategy 时被调用。对于 GlobalPositionStrategy 而言，主要是对 host element 增加了 cdk-global-overlay-wrapper CSS 类。 .cdk-global-overlay-wrapper { display: flex; position: absolute; z-index: 1000; pointer-events: none; top: 0; left: 0; height: 100%; width: 100%; } apply 方法在需要调整浮层元素位置时被调用。该方法通过修改 host element 和 pane element 的样式来控制浮层元素的位置。 还有如下方法比较重要： dispose，在 position strategy 被销毁（比如跟随浮层被销毁，或者浮层切换了 position strategy）的时候做回复操作。 其他方法都是暴露出来修改定位的，这里就不 cover 了。 辅助机制 Backdrop 有些浮层需要有一个后置的全屏图层，来凸显浮层内容，同时作为 MouseEvent 的 target，支持“点击浮层外关闭”这样的功能。 Backdrop 由 _attachBackdrop 方法所创建，实质上是创建了这样一个元素 并把它插入到 host element 之前，保持图层叠加的顺序。 同时在浮层上绑定了一个 click 事件的 handler，通过此 handle 派发 _backdropClick 事件。 KeyboardDispatcher KeyboardDispatcher 负责将键盘事件分派给最近打开的浮层。 之前讲到浮层 attach 的时候会调用 KeyboardDispatcher 的 add 方法，该方法会将调用此方法的 overlay 注册在 _attachedOverlays 数组的最后，且会第一个 overlay 注册的时候在 document 上绑定 keydown 事件的 handler，而该 handler 会从数组尾部开始逆序查找监听了 keydown 事件的 overlay，并对它派发 keydown 事件。 KeyboardDispatcher 使得最近一个打开的 overlay 才能监听键盘事件，一种常见的使用场景就是支持按 esc 键时有序地关闭 overlay。 ScrollStrategy scroll strategy 确定了在浮层展开时，原文档应当如何滚动。任意的 scroll strategy 都需要实现 ScrollStrategy 接口。 我们以 CDK 提供的 CloseScrollStrategy 为例，这种 strategy 会在页面内容滚动时关闭浮层。 在 OverlayRef 初始化时会调用 attach 方法，而 Overlay 的 attach 方法会调用 enable 方法，这个方法会监听全局滚动事件，并根据滚动范围和设置的门限调用 _detach 方法，最终是调用 OverlayRef 的 detach 方法卸载浮层内容。 例子 下面以 BottomSheet 组件为例，看一下 overlay 是如何使用的。 用户用 open 方法创建一个新的 BottomSheet 组件，这个方法会通过 _createOverlay 创建一个新的浮层，该方法的全部代码如下： /** * Creates a new overlay and places it in the correct location. * @param config The user-specified bottom sheet config. */ private _createOverlay(config: MatBottomSheetConfig): OverlayRef { const overlayConfig = new OverlayConfig({ direction: config.direction, hasBackdrop: config.hasBackdrop, disposeOnNavigation: config.closeOnNavigation, maxWidth: '100%', scrollStrategy: config.scrollStrategy || this._overlay.scrollStrategies.block(), positionStrategy: this._overlay.position().global().centerHorizontally().bottom('0') }); if (config.backdropClass) { overlayConfig.backdropClass = config.backdropClass; } return this._overlay.create(overlayConfig); } 可以看到默认使用的是 BlockScrollStrategy 和 GlobalPositionStrategy。 实际上是通过工厂类 OverlayPositionBuilder 和 ScrollStrategyOptions 创建的。 个人觉得这不是个好设计，会导致没用到的 Strategy 没法被 tree shake 掉。 然后 _attachContainer 方法就会将 BottomSheep 组件内容 attach 到 portal 上了。 const containerRef: ComponentRef = overlayRef.attach( containerPortal ) Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-04-18 11:17:03 "},"angular/zorro弹框拖拽.html":{"url":"angular/zorro弹框拖拽.html","title":"zorro弹框拖拽","keywords":"","body":"弹框拖拽 参考：https://www.jianshu.com/p/deb0b018b2ee 1创建拖拽服务 import {Injectable, RendererFactory2} from '@angular/core' @Injectable({ providedIn: 'root' }) export class ModalDragService { constructor( private rendererFactory2: RendererFactory2, ){} enableModalDrag(refModal) { const render = this.rendererFactory2.createRenderer(null, null); const modalBackground = refModal.elementRef.nativeElement; const modalElement = refModal.elementRef.nativeElement.querySelector('.ant-modal-content'); const modalTitleElement = this.createModalTitleElement(render, modalElement); this.dragListen(render, modalTitleElement, modalElement, modalBackground); } createModalTitleElement(render, modalElement) { let element = document.createElement('div') as any; render.setStyle(element, 'width', '100%'); render.setStyle(element, 'height', '54px'); render.setStyle(element, 'position', 'absolute'); render.setStyle(element, 'top', '0'); render.setStyle(element, 'left', '0'); render.setStyle(element, 'cursor', 'move'); render.setStyle(element, '-moz-user-select', 'none'); render.setStyle(element, '-webkit-user-select', 'none'); render.setStyle(element, '-ms-user-select', 'none'); render.setStyle(element, '-khtml-user-select', 'none'); render.setStyle(element, 'user-select', 'none'); render.appendChild(modalElement, element); return element; } dragListen(render, modalTitleElement, modalElement, modalBackground) { render.listen(modalTitleElement, 'mousedown', function(event){ this.mouseDownX = event.clientX; this.mouseDownY = event.clientY; this.modalX = modalElement.offsetLeft; this.modalY = modalElement.offsetTop; render.setStyle(modalElement, 'left', `${this.modalX}px`); render.setStyle(modalElement, 'top', `${this.modalY}px`); this.canMove = true; }.bind(this)); render.listen(modalTitleElement, 'mouseup', function(event){ this.canMove = false; }.bind(this)); render.listen(modalBackground, 'mousemove', function(event){ if (this.canMove){ let moveX = event.clientX - this.mouseDownX; let moveY = event.clientY - this.mouseDownY; let newModalX = this.modalX + moveX; let newModalY = this.modalY + moveY; render.setStyle(modalElement, 'left', `${newModalX}px`); render.setStyle(modalElement, 'top', `${newModalY}px`); } }.bind(this)); } } 2.创建modal之后, 使用enableModalDrag方法激活 const modal = this.modalService.create({ nzTitle: '添加', nzContent: FormComponent, nzComponentParams: { }, nzWidth:700, nzFooter:null, }); // 设置窗口可拖动 this.modalDragService.enableModalDrag(modal); Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-05-20 10:17:46 "},"angular/内嵌视图、宿主视图.html":{"url":"angular/内嵌视图、宿主视图.html","title":"内嵌视图、宿主视图","keywords":"","body":"Angular 内嵌视图、宿主视图 - Zero_追梦 - 博客园 (cnblogs.com) https://www.cnblogs.com/zero-zm/p/9860253.html ng-content不能动态绑定select属性 https://blog.csdn.net/s_y_w123/article/details/123270765 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 14:55:05 "},"angular/动画.html":{"url":"angular/动画.html","title":"动画","keywords":"","body":"https://www.jianshu.com/p/86b298b2c23a Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-26 13:18:45 "},"angular/工作区.html":{"url":"angular/工作区.html","title":"工作区","keywords":"","body":"工作区（多项目、多库） 参考 如何用微前端让 Angular 更具前途？：https://baijiahao.baidu.com/s?id=1761711025706339475&wfr=spider&for=pc Angular Libary 系列之 不用先初始化工作区就来创建Angular Library：https://zhuanlan.zhihu.com/p/54075580 angular工作区： 多应用程序项目(翻译)：https://zhuanlan.zhihu.com/p/157205769 Angular 14微前端项目构建：https://blog.csdn.net/lvxinaidou/article/details/125856927 angular 开发中常用快捷命令总结：https://www.cnblogs.com/zmmboy/p/16339767.html 怎么在Angular中部署一个多模块项目：https://www.yisu.com/zixun/154953.html 将Angular单项目升级为多项目的全过程：https://www.jb51.net/article/226957.htm Angular创建自己的库发布到npm上使用：https://blog.csdn.net/lvxinaidou/article/details/129652639 创建一个不包含初始化应用的 Angular 工作区 不包含 projects 配置项的 Angular 配置文件 单独ng build 或者 ng serve不会生效 ng new 工作区名 --no-create-application 创建库项目 ng generate library 库名 --prefix=库前缀 创建应用 ng generate application 应用名 创建组件、服务 # ng g component 服务名 --project 应用名 # ng g service 服务名 --project 应用名 构建 ng build 应用名|库名 # ng build 应用名 --configuration production --base-href ./ # npm run build:应用名 运行 ng serve 应用名|库名 # npm run start:应用名 测试 ng test 应用名|库名 实践 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 14:55:05 "},"angular/常用命令.html":{"url":"angular/常用命令.html","title":"常用命令","keywords":"","body":"版本升级 ng update @angular/cli @angular/core --allow-dirty --force 创建 ng generate c ng generate service ng generate pipe ng generate directive ng serve -o ... Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 09:29:26 "},"angular/开发问题.html":{"url":"angular/开发问题.html","title":"开发问题","keywords":"","body":"nz-zorro table 数据无法更新（使用深拷贝） 参考：https://www.jianshu.com/p/135e2e97708f 问题原因是，NG-ZORRO从 7.0 版本开始，NG-ZORRO 组件默认在 OnPush 模式下工作，OnPush 意味着只有在输入发生变化时才运行组件的变化检测，并且当输入发生变化时，它们的整个对象实例必须发生变化。如果对象实例引用不变，则不会运行变化检测。对象实例的引用没有发生变化，于是从 Angular 的视角看来，也就没有什么需要报告的变化了。如上所述，在使用 Table 组件时，如果对源数据数组进行 array.push/splice 操作，这并不会更改对象实例的引用，所以页面并不会发生更新。 // push concat 可用 this.tableList.push(res.data); this.tableList = [...this.tableList]; // 添加这行代码 // 使用 lodash 的 cloneDeep npm install lodash @types/lodash import * as _ from 'lodash'; this.tableList = _.cloneDeep(this.tableList); // html 中使用原始数据进行渲染 // 指定服务器端渲染(shiy) [nzFrontPagination]='false' input自定义指令修改value与ngModel绑定数据不一致 https://blog.csdn.net/rushichunqiu/article/details/79161076 http绕过自定义拦截器 https://angular.cn/api/common/http/HttpHandler HttpHandler 是可注入的。当被注入时，该处理器的实例会把请求派发给拦截器链中的第一个拦截器，第一个拦截器会再派发给第二个拦截器，以此类推。 最终抵达 HttpBackend。 ```typescript constructor( public httpBackend: HttpBackend, ){} const http = new HttpClient(this.httpBackend); http.get(https://api.ipify.org/?format=json).subscribe((res: any) => { console.log(res) }) Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-10-12 11:09:50 "},"angular/权限控制组件.html":{"url":"angular/权限控制组件.html","title":"权限控制组件","keywords":"","body":"权限控制组件 1.可根据权限类型、控制方式、是否启用来控制组件、文字及其他操作权限 2.可配合权限功能使用 3.可根据实际情况自行扩展 组件定义 使用示例 1.获取价格显示、编辑权限 2.控制价格显示 3.控制价格显示、编辑 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 14:55:05 "},"angular/标签区域配置.html":{"url":"angular/标签区域配置.html","title":"标签区域配置","keywords":"","body":"标签区域配置 ts html Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 16:22:05 "},"angular/样式.html":{"url":"angular/样式.html","title":"样式","keywords":"","body":":host、::ng-deep 区别与使用 https://blog.csdn.net/KenkoTech/article/details/122213516 :host 在前面加了个本组件的动态属性的属性选择器，确保样式只生效于本组件和他的子组件。 ::ng-deep 把选择器后面的属性选择器去掉了，这样就能作用别的组件了。 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-07-18 13:39:29 "},"angular/相关资料.html":{"url":"angular/相关资料.html","title":"相关资料","keywords":"","body":"版本升级地址 https://update.angular.io/ v13新功能及优化 https://zhuanlan.zhihu.com/p/429724953 常用管道 https://zhuanlan.zhihu.com/p/212204583 AOT编译出现内存溢出瓶颈 https://www.infoq.cn/article/2017/08/compile-project-memory-bottlenec/ Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-06-09 10:06:42 "},"angular/系统权限.html":{"url":"angular/系统权限.html","title":"系统权限","keywords":"","body":"系统权限 可全局使用，菜单权限逐步迁移到服务中进行配置。 auth.service.ts 权限服务中添加权限配置项，只有再服务中配置后，使用的时候才会生效。具体配置请看例子 auth-name.ts 权限名称配置，为能在服务中方便查阅 具体使用： Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-11-24 17:53:32 "},"angular/自定义指令.html":{"url":"angular/自定义指令.html","title":"自定义指令","keywords":"","body":"自定义指令传参 通过 @Input() 进行传参 模板： private 私有属性 = 值; @Input() set 属性名称(值) { this.私有属性 = 值; } 示例： import { Directive, HostListener, Input } from '@angular/core'; @Directive({ selector: '[inputNumber]', }) export class InputNumberDirective { constructor() { } @HostListener('input', ['$event.target']) inputChange(event) { let str = ''; if (this.dotNum > 0) { str = `\\\\d*(\\\\.{0,1}\\\\d{0,${this.dotNum}})?`; } else { str = `\\\\d*`; } const reg = new RegExp(str); event.value = !isNaN(value) ? value.match(reg) ? value.match(reg)[0] : '' : ''; } private dotNum = 2; // 小数位 @Input() set inputNumber(obj: { dotNum?: number }) { this.dotNum = !isNaN(obj.dotNum) && obj.dotNum >= 0 ? obj.dotNum : 2; } } Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-04-01 10:28:49 "},"angular/路由复用及自定义钩子方法.html":{"url":"angular/路由复用及自定义钩子方法.html","title":"路由复用及自定义钩子方法","keywords":"","body":"路由复用 实现 %accordion%ts%accordion% import { Component, OnInit } from '@angular/core'; import { ActivatedRoute, NavigationEnd, Router } from '@angular/router'; import { NzContextMenuService, NzDropdownMenuComponent } from 'ng-zorro-antd/dropdown'; import { Subscription } from 'rxjs'; import { filter, map } from 'rxjs/operators'; import { SettingService, TAB } from '../../services/setting.service'; import { CloseType } from './reuse-tab.interfaces'; import { ReuseTabService } from './reuse-tab.service'; @Component({ selector: 'reuse-tab', templateUrl: './reuse-tab.component.html', styleUrls: ['./reuse-tab.component.scss'] }) export class ReuseTabComponent implements OnInit { subscript: Subscription; constructor( public router: Router, public activatedRoute: ActivatedRoute, public settingService: SettingService, public reuseTabService: ReuseTabService, public nzContextMenuService: NzContextMenuService ) { this.subscript = this.router.events.pipe( filter(event => event instanceof NavigationEnd), map(() => this.activatedRoute), map(route => { while (route.firstChild) { route = route.firstChild; } return route; }), filter(route => route.outlet === 'primary') ).subscribe((res: any) => { const obj: TAB = { title: res.data.value.title, module: res.data.value.module, routerLink: res._routerState.snapshot.url.split('?')[0], queryParams: res.queryParams.value, disabled: false, close: true, delrouterurl: res._routerState.snapshot.url.replace(/\\//g, '_') + '_' + (res.routeConfig.loadChildren || res.routeConfig.component.toString().split('(')[0].split(' ')[1]) }; if (obj.routerLink === '/dashboard/home') { obj.disabled = true; obj.close = false; } if (obj.routerLink.endsWith('working/ww')) { obj.title = '成品加工单'; } else if (obj.routerLink.endsWith('working/pur')) { obj.title = '成品采购单'; } else if (obj.routerLink.endsWith('working/wp')) { obj.title = '工艺加工单'; } else if (obj.routerLink.endsWith('working/ww/detail')) { obj.title = '成品加工单详情'; } else if (obj.routerLink.endsWith('working/pur/detail')) { obj.title = '成品采购单详情'; } else if (obj.routerLink.endsWith('working/wp/detail')) { obj.title = '工艺加工单详情'; } //判断是否存在相同路由，如果不存在新增，如果存在则修改 if (this.settingService.tabList.every((item: any) => item.routerLink !== obj.routerLink)) { //判断标题是否重复; //obj['no'] = 1; //obj['newTitle'] = res.data.value.title; // if (this.settingService.tabList.some((item: any) => item.title === `${res.data.value.title}`)) { // const maxNo = Math.max(...this.settingService.tabList.filter((item: any) => item.title === `${res.data.value.title}`).map((item: any) => (item.no))); // obj['no'] = maxNo + 1; // obj['newTitle'] = `${obj.title}(${obj['no']})`; // } // 新增tab并跳转 this.settingService.setTab(obj); this.reuseTabService.selectedIndex = this.settingService.tabList.length; } else { //存在，改变路由参数和看板 模块标题 this.settingService.tabList.forEach((item: any, index: number) => { if (item.routerLink == obj.routerLink) { this.settingService.tabList[index].queryParams = obj.queryParams; this.reuseTabService.selectedIndex = index; } }); } }); } ngOnInit(): void { } toPage(item: { routerLink: string, queryParams: object }) { this.router.navigate([item.routerLink], { queryParams: item.queryParams }); } /** 菜单操作 */ doneMenu(e: any, type: CloseType) { switch (type) { case 'clear': this.reuseTabService.clear(); break; case 'close': this.reuseTabService.close(); break; case 'closeOther': this.reuseTabService.closeOther(); break; case 'closeRight': this.reuseTabService.closeRight(); break; } } /** 关闭当前标签 */ close(e: Event, item: object, index: number) { e.stopPropagation(); this.reuseTabService.reuseItem = { ...item, index } this.reuseTabService.close(); } /** 创建菜单 */ contextMenu($event: MouseEvent, menu: NzDropdownMenuComponent): void { this.nzContextMenuService.close(); if (!this.reuseTabService.reuseItem.disabled) { this.nzContextMenuService.create($event, menu); } } ngOnDestroy(): void { this.subscript.unsubscribe(); } } %/accordion% %accordion%html%accordion% 关闭 关闭右侧标签页 2)\">关闭其他标签页 1)\">关闭所有标签页 %/accordion% %accordion%scss%accordion% .main-tabset-card { border: 0; ::ng-deep .ant-tabs-tab { background: rgba(250, 250, 250, .5); .icon-close { font-size: 14px; padding: 2px; margin: 0 0 0 12px; &:hover { color: rgba(0, 0, 0, 0.85); background: rgba(0, 0, 0, .15); border-radius: 100%; } } &:hover { color: rgba(0, 0, 0, 0.85); background-color: #ffffff; span, i { color: rgba(0, 0, 0, 0.85); } } &.ant-tabs-tab-active { color: #ffffff; background-color: rgb(0, 183, 150); span, i { color: #ffffff; } .icon-close { font-size: 14px; padding: 2px; margin: 0 0 0 12px; color: #ffffff; &:hover { background: rgba(0, 0, 0, .15); border-radius: 100%; } } } } ::ng-deep .ant-tabs-nav { margin: 0; } } .context-menu { position: relative; top: 0; left: 0; width: 100%; height: 100%; } %/accordion% %accordion%directive%accordion% import { Directive, Input } from '@angular/core'; import { NzContextMenuService, NzDropdownMenuComponent } from 'ng-zorro-antd/dropdown'; import { ReuseTabService } from './reuse-tab.service'; @Directive({ selector: '[reuse-tab-context-menu]', exportAs: 'reuseTabContextMenu', host: { '(nzContextmenu)': '_onContextMenu($event)' } }) export class ReuseTabContextDirective { private reuseItem = null; @Input('reuse-tab-context-menu') set obj(obj: { item: any, index: number }) { this.reuseItem = { ...obj.item, index: obj.index }; }; constructor( public nzContextMenuService: NzContextMenuService, public reuseTabService: ReuseTabService ) { } _onContextMenu(event: MouseEvent, menu: NzDropdownMenuComponent): void { this.reuseTabService.reuseItem = this.reuseItem; event.preventDefault(); event.stopPropagation(); } } %/accordion% %accordion%interface%accordion% export type CloseType = 'clear' | 'close' | 'closeOther' | 'closeRight' | 'custom' | 'refresh' | null; export type ReuseHookTypes = 'onReuseInit' | 'onReuseDestroy'; export type ReuseHookOnReuseInitType = 'init' | 'reflash'; export interface ReuseComponentHandle { componentRef: ReuseComponentRef; } export interface ReuseComponentRef { instance: ReuseComponentInstance; } export interface ReuseComponentInstance { onReuseInit: (type: ReuseHookOnReuseInitType) => void; onReuseDestroy: () => void; } %/accordion% %accordion%service%accordion% import { Injectable, Injector } from '@angular/core'; import { ActivatedRouteSnapshot } from '@angular/router'; import { NzSafeAny } from 'ng-zorro-antd/core/types'; import { timer } from 'rxjs'; import { CommonService } from '../../services/common.service'; import { SettingService } from '../../services/setting.service'; import { ReuseComponentHandle, ReuseComponentRef, ReuseHookOnReuseInitType, ReuseHookTypes } from './reuse-tab.interfaces'; interface IRouteConfigData { keep: boolean; } interface ICachedRoute { handle: ReuseComponentHandle; data: IRouteConfigData; } @Injectable({ providedIn: 'root' }) export class ReuseTabService { selectedIndex = 0; reuseItem = null; // reuseItem 数据 public static routeCache = new Map(); private static waitDelete: string; // 当前页未进行存储时需要删除 private static currentDelete: string; // 当前页存储过时需要删除 constructor( private injector: Injector, private settingService: SettingService ) { } /** 进入路由触发，判断是否是同一路由 */ shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean { return future.routeConfig === curr.routeConfig && JSON.stringify(future.params) == JSON.stringify(curr.params); } /** 表示对所有路由允许复用 如果你有路由不想利用可以在这加一些业务逻辑判断，这里判断是否有data数据判断是否复用 */ shouldDetach(route: ActivatedRouteSnapshot): boolean { if (this.getRouteData(route)) { return true; } return false; } /** 当路由离开时会触发。按path作为key存储路由快照&组件当前实例对象 */ store(route: ActivatedRouteSnapshot, handle: NzSafeAny): void { const url = this.getRouteUrl(route); const data = this.getRouteData(route); if (ReuseTabService.waitDelete && ReuseTabService.waitDelete === url) { // 如果待删除是当前路由，且未存储过则不存储快照 ReuseTabService.waitDelete = null; return null; } else { // 如果待删除是当前路由，且存储过则不存储快照 if (ReuseTabService.currentDelete && ReuseTabService.currentDelete === url) { ReuseTabService.currentDelete = null; return null; } else { if (handle) { ReuseTabService.routeCache.set(url, { handle, data }); this.addRedirectsRecursively(route); } else { console.log('routeCache：', ReuseTabService.routeCache); console.log(url); console.log(ReuseTabService.routeCache.get(url)); // 路由复用后触发自定义初始化钩子 const componentRef = ReuseTabService.routeCache.get(url).handle?.componentRef; timer(100).subscribe(() => this.runHook('onReuseInit', componentRef)); } } } if (handle && handle.componentRef) { // 路由复用后触发自定义销毁钩子 this.runHook('onReuseDestroy', handle.componentRef); } } /** 若 path 在缓存中有的都认为允许还原路由 */ shouldAttach(route: ActivatedRouteSnapshot): boolean { const url = this.getRouteUrl(route); const handle = ReuseTabService.routeCache.has(url) ? ReuseTabService.routeCache.get(url).handle : null; const data = this.getRouteData(route); return data && ReuseTabService.routeCache.has(url) && handle != null; } /** 从缓存中获取快照，若无则返回nul */ retrieve(route: ActivatedRouteSnapshot): NzSafeAny | null { const url = this.getRouteUrl(route); const data = this.getRouteData(route); return data && ReuseTabService.routeCache.has(url) ? ReuseTabService.routeCache.get(url).handle : null; } private addRedirectsRecursively(route: ActivatedRouteSnapshot): void { const config = route.routeConfig; if (config) { if (!config.loadChildren) { const routeFirstChild = route.firstChild; const routeFirstChildUrl = routeFirstChild ? this.getRouteUrlPaths(routeFirstChild).join('/') : ''; const childConfigs = config.children; if (childConfigs) { const childConfigWithRedirect = childConfigs.find( c => c.path === '' && !!c.redirectTo ); if (childConfigWithRedirect) { childConfigWithRedirect.redirectTo = routeFirstChildUrl; } } } route.children.forEach(childRoute => { this.addRedirectsRecursively(childRoute); }); } } private getRouteUrl(route: ActivatedRouteSnapshot) { return ( route['_routerState'].url.replace(/\\//g, '_') + '_' + (route.routeConfig.loadChildren || route.routeConfig.component .toString() .split('(')[0] .split(' ')[1]) ); } private getRouteUrlPaths(route: ActivatedRouteSnapshot): string[] { return route.url.map(urlSegment => urlSegment.path); } private getRouteData(route: ActivatedRouteSnapshot): IRouteConfigData { return ( route.routeConfig && (route.routeConfig.data as IRouteConfigData) && route.routeConfig.data.keep ); } /** 用于删除路由快照*/ deleteRouteSnapshot(url: string): void { if (url[0] === '/') { url = url.substring(1); } url = url.replace('/', '_'); // console.log(\"del-url\",url); // console.log('routeCache',ReuseTabService .routeCache); if (ReuseTabService.routeCache.has(url)) { // console.log(\"del-url-OK\",url); ReuseTabService.routeCache.delete(url); ReuseTabService.currentDelete = url; } else { ReuseTabService.waitDelete = url; } } clear() { ReuseTabService.routeCache.clear(); } clearExcept(list) { if (!list || !ReuseTabService.routeCache) return; try { let waitDelete = []; ReuseTabService.routeCache.forEach((value: ICachedRoute, key) => { let handle: any = value.handle; let url = handle.route.value._routerState.snapshot.url; if (list.indexOf(url) { ReuseTabService.routeCache.delete(item); }); } catch (error) { console.log('clearExcept error', error); } } /** 执行钩子 */ runHook( method: ReuseHookTypes, componentRef: ReuseComponentRef | undefined, type: ReuseHookOnReuseInitType = 'init' ): void { if (componentRef == null || !componentRef.instance) { return; } const componentThis = componentRef.instance; const fn = componentThis[method]; if (typeof fn !== 'function') { return; } if (method === 'onReuseInit') { fn.call(componentThis, type); } else { (fn as () => void).call(componentThis); } } /** 关闭所有标签 */ closeAll() { this.settingService.tabList = [this.settingService.tabList.shift()]; localStorage.setItem('tabList', JSON.stringify(this.settingService.tabList)); this.clear(); this.injector.get(CommonService).toPage({ url: this.settingService.tabList[0].routerLink }); } /** 关闭当前标签 */ close() { if (this.reuseItem) { // 关闭 tab 同时移除菜单中隐藏的 非menu 项 const i = this.settingService.menuList.findIndex((item: any) => item.path === this.settingService.tabList[this.reuseItem.index].routerLink && item.hasOwnProperty('isExtra') && item.isExtra); if (i > -1) { this.settingService.menuList.splice(i, 1); } // 删除当前page页面路由复用 this.deleteRouteSnapshot(this.settingService.tabList[this.reuseItem.index].delrouterurl); this.settingService.tabList.splice(this.reuseItem.index, 1); localStorage.setItem('tabList', JSON.stringify(this.settingService.tabList)); if (this.selectedIndex >= this.reuseItem.index && this.settingService.tabList.length > 0) { this.selectedIndex -= 1; this.injector.get(CommonService).toPage({ url: this.settingService.tabList[this.selectedIndex].routerLink, params: this.settingService.tabList[this.selectedIndex].queryParams }); } } } /** 关闭其他标签 */ closeOther() { if (this.reuseItem) { const list = []; list.push(this.settingService.tabList[0]); const index = this.settingService.tabList.findIndex((item: any) => item.routerLink === this.reuseItem.routerLink); if (index > -1) { list.push(this.settingService.tabList[index]); } this.clearExcept([this.settingService.tabList[0].routerLink, this.reuseItem.routerLink]); this.settingService.tabList = [...list]; localStorage.setItem('tabList', JSON.stringify(this.settingService.tabList)); if (index > -1 && index !== this.selectedIndex && this.settingService.tabList.length > 0) { this.injector.get(CommonService).toPage({ url: this.settingService.tabList[this.settingService.tabList.length - 1].routerLink, params: this.settingService.tabList[this.settingService.tabList.length - 1].queryParams }); } } } /** 关闭右边标签 */ closeRight() { if (this.reuseItem) { const index = this.settingService.tabList.findIndex((item: any) => item.routerLink === this.reuseItem.routerLink); this.settingService.tabList.forEach((item: any, i: number) => { if (i > index) { this.deleteRouteSnapshot(this.settingService.tabList[i].delrouterurl); } }) this.settingService.tabList = this.settingService.tabList.splice(0, index + 1); localStorage.setItem('tabList', JSON.stringify(this.settingService.tabList)); if (index > -1 && index 0) { this.injector.get(CommonService).toPage({ url: this.settingService.tabList[this.settingService.tabList.length - 1].routerLink, params: this.settingService.tabList[this.settingService.tabList.length - 1].queryParams }); } } } } %/accordion% 路由复用自定义钩子 描述 1.自定义钩子属于组件实例方法。 2.使用了路由复用后可根据触发机制进行相应触发，无需删除路由快照，也无需进行路由跳转，只需要添加复用钩子，对需要刷新的数据进行相应处理即可。 3.还可根据需求添加其他自定义钩子函数，默认添加了onReuseInit和onReuseDestroy2个钩子方法。 具体使用方式参考以下示例： 用法 export class xxxComponent implements OnInit { ngOnInit(): void { } ... /** 路由复用后触发钩子（可局部刷新数据） */ onReuseInit(): void { // 需要刷新的数据或请求 } /** 路由复用后销毁钩子 */ onReuseDestroy(): void { } } Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-12-11 12:34:53 "},"antd/栅格.html":{"url":"antd/栅格.html","title":"栅格","keywords":"","body":"栅格布局 一行6列 col： nzXXl='4' nzXl=\"6\" nzLg=\"8\" nzMd=\"8\" nzSm=\"12\" nzXs=\"24\" form-label： [nzSpan]=\"8\" form-content： [nzSpan]=\"16\" // 开始结束日期、备注等较长表单组件 col： nzXXl='8' nzXl=\"12\" nzLg=\"16\" nzMd=\"16\" nzSm=\"12\" nzXs=\"24\" form-label： [nzSpan]=\"4\" form-content： [nzSpan]=\"20\" 一行4列 col： nzXXl='6' nzXl=\"6\" nzLg=\"8\" nzMd=\"8\" nzSm=\"12\" nzXs=\"24\" form-label： [nzSpan]=\"8\" form-content： [nzSpan]=\"16\" // 开始结束日期、备注等较长表单组件 col： nzXXl='6' nzXl=\"12\" nzLg=\"16\" nzMd=\"16\" nzSm=\"12\" nzXs=\"24\" form-label： nzXXl='8' nzXl=\"4\" nzLg=\"4\" nzMd=\"4\" nzSm=\"4\" nzXs=\"4\" form-content： nzXXl='16' nzXl=\"20\" nzLg=\"20\" nzMd=\"20\" nzSm=\"20\" nzXs=\"20\" Demo ... ... ... ... 搜索 重置 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-04-01 10:38:22 "},"antd/栅格布局组件排序及显示方案.html":{"url":"antd/栅格布局组件排序及显示方案.html","title":"栅格布局组件排序及显示方案","keywords":"","body":"栅格布局组件排序及显示方案 通过插槽原理，对指定模板进行渲染 ng-template 定义插槽名称 ng-container 指定渲染模板名称 优点： 1.可灵活定义模板插入位置，无需关注模板定义位置 2.无需写for循环一个个匹对，减少if和switch多层匹配，渲染性能更好 用法： 示例： 实战： import { ChangeDetectorRef, Component, NgZone, TemplateRef, ViewChild } from '@angular/core'; @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'] }) export class AppComponent { @ViewChild('Stylist1Temp', { static: false }) Stylist1Temp!: TemplateRef; @ViewChild('Stylist2Temp', { static: false }) Stylist2Temp!: TemplateRef; list: any[] = [ { FieldCustTitle: 'FieldCustTitle1', FieldName: 'Stylist1', Visibled: true }, { FieldCustTitle: 'FieldCustTitle2', FieldName: 'Stylist2', Visibled: true } ]; constructor( public cdr: ChangeDetectorRef ) { } ngOnInit(): void { } ngAfterViewInit(): void { this.list = this.list.map((item: any) => { let temp = null; switch (item.FieldName) { case 'Stylist1': temp = this.Stylist1Temp; break; case 'Stylist2': temp = this.Stylist2Temp; break; } return { ...item, temp } }); // 视图检测变更 this.cdr.markForCheck(); this.cdr.detectChanges(); } } 当前索引： FieldCustTitle： FieldName： 当前索引： FieldCustTitle： FieldName： Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-04-06 13:56:30 "},"antd/菜单.html":{"url":"antd/菜单.html","title":"菜单","keywords":"","body":"菜单 0 else noChildren\"> Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-23 17:20:45 "},"antd/虚拟滚动与拖拽排序.html":{"url":"antd/虚拟滚动与拖拽排序.html","title":"虚拟滚动与拖拽排序","keywords":"","body":"https://ithelp.ithome.com.tw/articles/10214406 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-10 09:38:00 "},"antd/表格勾选.html":{"url":"antd/表格勾选.html","title":"表格勾选","keywords":"","body":"表格勾选 非分组 allChecked = false; indeterminate = false; setOfCheckedId = new Set(); /** 更新勾选状态设置 */ updateCheckedSet(index: number, checked: boolean): void { if (checked) { this.setOfCheckedId.add(index); } else { this.setOfCheckedId.delete(index); } } /** 全选 */ allCheckedChange(value: boolean) { this.tableList.forEach((item: any, index: number) => this.updateCheckedSet(index, value)); this.refreshCheckedStatus(); } /** 单选 */ singleCheckedChange(index: number, checked: boolean) { this.updateCheckedSet(index, checked); this.refreshCheckedStatus(); } /** 更新勾选状态 */ refreshCheckedStatus(): void { this.allChecked = this.tableList.every((item: any, index: number) => this.setOfCheckedId.has(index)); this.indeterminate = this.tableList.some((item: any, index: number) => this.setOfCheckedId.has(index)) && !this.allChecked; } 普通分组 /** 更新勾选状态设置 */ updateCheckedSet(index: number, checked: boolean): void { if (checked) { this.setOfCheckedId.add(index); } else { this.setOfCheckedId.delete(index); } } /** 全选 */ allCheckedChange(value: boolean) { if (this.tabIndex === 0 || this.tabIndex === 1) { this.tableList1.forEach((item: any, index: number) => this.updateCheckedSet(index, value)); } else if (this.tabIndex === 2 || this.tabIndex === 3) { this.tableList2.forEach((item: any, index: number) => { item.groupList.forEach((item2: any, index2: number) => { this.updateCheckedSet(index * 10 + index2, value); }); }); } this.refreshCheckedStatus(); } /** 单选 */ singleCheckedChange(index: number, checked: boolean) { this.updateCheckedSet(index, checked); this.refreshCheckedStatus(); } /** 更新勾选状态 */ refreshCheckedStatus(): void { this.allChecked = this.tableList.every((item: any, index: number) => this.setOfCheckedId.has(index)); this.indeterminate = this.tableList.some((item: any, index: number) => this.setOfCheckedId.has(index)) && !this.allChecked; } 含tab切换分组 /** 更新勾选状态设置 */ updateCheckedSet(index: number, checked: boolean): void { if (checked) { this.setOfCheckedId.add(index); } else { this.setOfCheckedId.delete(index); } } /** 全选 */ allCheckedChange(value: boolean) { this.tableList.forEach((item: any, index: number) => this.updateCheckedSet(index, value)); this.refreshCheckedStatus(); } /** 单选 */ singleCheckedChange(index: number, checked: boolean) { this.updateCheckedSet(index, checked); this.refreshCheckedStatus(); } /** 更新勾选状态 */ refreshCheckedStatus(): void { if (this.tabIndex === 0 || this.tabIndex === 1) { this.allChecked = this.tableList1.every((item: any, index: number) => this.setOfCheckedId.has(index)); this.indeterminate = this.tableList1.some((item: any, index: number) => this.setOfCheckedId.has(index)) && !this.allChecked; } else if (this.tabIndex === 2 || this.tabIndex === 3) { const allCheckedList = []; const indeterminateList = []; this.tableList2.forEach((item: any, index: number) => { item.groupList.forEach((item2: any, index2: number) => { allCheckedList.push(this.setOfCheckedId.has(index * 10 + index2)); indeterminateList.push(this.setOfCheckedId.has(index * 10 + index2)); }); }); this.allChecked = allCheckedList.every((item: any) => item === true); this.indeterminate = allCheckedList.some((item: any) => item === true) && !this.allChecked; } } Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-01-13 15:26:35 "},"cordova/cordova.html":{"url":"cordova/cordova.html","title":"cordova","keywords":"","body":"CORDOVA 官网：https://cordova.apache.org/ 安装 npm install -g cordova 创建项目 cordova create [项目名] 平台(browser/android/ios) # 查看平台 cordova platform ls # 安装平台 cordova platform add [平台名] # 移除平台 cordova platform rm [平台名] 运行 cordova run [平台名] 插件 # 查看插件 cordova plugin ls # 添加插件 cordova plugin add [插件名] # 移除插件 cordova plugin rm [插件名] 打包 cordova build android/ios Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-06-07 13:53:09 "},"cordova/开发问题.html":{"url":"cordova/开发问题.html","title":"开发问题","keywords":"","body":"打包后应用首次启动异常（客户内网无法访问外网，需检查且注释外网请求） Ionic 打包后的应用在启动时一般不需要请求外网。打包后的应用通常是一个独立的包含所有必需文件的静态应用程序，它们不再需要依赖外部服务器或外网连接。 当您在本地使用 ionic serve 命令运行应用时，应用会在本地开发服务器上运行，并且可能会与外部服务器进行通信，例如获取数据或加载资源。但是，一旦应用被打包为原生应用（如 Android 或 iOS），它将不再与外部服务器进行交互，而是运行在设备本地。 打包后的应用将包含所有必需的文件，包括 HTML、CSS、JavaScript 和资源文件等，以便应用能够独立运行。当用户启动应用时，应用会加载这些文件并在设备上运行，而无需与外部服务器进行通信。 但请注意，具体情况可能因您的应用需求而有所不同。如果您的应用需要与外部服务器进行通信（例如获取实时数据或进行身份验证等），那么在启动时可能需要请求外网。这种情况下，您需要确保设备可以访问外网，并在应用中正确配置相关的网络请求。 总而言之，通常情况下，在打包后的应用启动时不需要请求外网。但如果您的应用需要与外部服务器进行通信，那么需要确保设备可以访问外网并配置应用相应的网络请求。 打包失败处理 1.gradle 安装 7.1.1 2.将 corodva 版本降到 10 版本 npm uninstall -g cordova npm install -g cordova@10 3.android studio 移除高版本的 sdk tools，安装低版本的 sdk tools Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 14:55:05 "},"cordova/插件.html":{"url":"cordova/插件.html","title":"插件","keywords":"","body":"app自动更新 npm install @ionic-native/device @ionic-native/app-version cordova plugin add cordova-plugin-appversion cordova-plugin-app-update 手持高频扫码枪 npm install --save @ionic-native/broadcaster@4 cordova plugin add cordova-plugin-broadcaster 注意事项： import android.support.v4.content.LocalBroadcastManager找不到，需要对broadcaster相关代码进行修改。 参考：https://blog.csdn.net/pecke/article/details/108321888 github：https://github1s.com/bsorrentino/ionic-broadcaster-sample/blob/HEAD/angular-app/android-assets/src/io/ionic/starter/MainActivity.java build.gradle： dependencies{ classpath 'androidx.legacy:legacy-support-v4:1.0.0' } CDVBroadcaster.java: import android.support.v4.content.LocalBroadcastManage 改为： import androidx.localbroadcastmanager.content.LocalBroadcastManager; 移动端扫描 https://www.npmjs.com/package/cordova-plugin-qrbar PDA讯飞语音插件 https://www.ishare5.com/9490439/ 下载地址：https://os-android.liqucn.com/rj/120294.shtml Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-10-29 09:48:35 "},"cordova/软键盘监听及操作.html":{"url":"cordova/软键盘监听及操作.html","title":"软键盘监听及操作","keywords":"","body":"Ionic Cordova实现软键盘的监听 以及操作大全 参考：https://blog.csdn.net/sean_css/article/details/70243893 首先需要添加插件： cordova plugin add ionic-plugin-keyboard --save 软键盘显示监听 window.addEventListener('native.keyboardshow', function (e) { // todo 进行键盘可用时操作 //e.keyboardHeight 表示软件盘显示的时候的高度 }); 软键盘隐藏监听 window.addEventListener('native.keyboardhide', function (e) { // todo 进行键盘不可用时操作 }); 打开软键盘 cordova.plugins.Keyboard.show(); 关闭软键盘 cordova.plugins.Keyboard.close(); 判断软键盘是否可用 cordova.plugins.Keyboard.isVisible 注意，这个不是方法，是一个属性。 显示隐藏键盘附件栏 cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true); cordova.plugins.Keyboard.hideKeyboardAccessoryBar(false); 禁止和允许滑动 cordova.plugins.Keyboard.disableScroll(true); cordova.plugins.Keyboard.disableScroll(false); Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-05-16 09:34:39 "},"css/工具.html":{"url":"css/工具.html","title":"工具","keywords":"","body":"配色表 http://www.puhuajia.com/tool/webcolor/ Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-03-16 14:37:50 "},"css/常用代码.html":{"url":"css/常用代码.html","title":"常用代码","keywords":"","body":"超出隐藏 // 单行文本超出隐藏 white-space: nowrap; text-overflow:ellipsis; white-space:nowrap; // 多行文本超出隐藏 overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 1; Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-22 11:12:40 "},"css/常见问题.html":{"url":"css/常见问题.html","title":"常见问题","keywords":"","body":"子元素位置影响父元素，如margin等 https://blog.51cto.com/u_15082403/3439560 原理：margin折叠 在css2.1盒模型仲规定的内容 因为嵌套也属于毗邻，所以在样式表中优先级更高子元素的margin会覆盖外层父元素定义的margin。 父元素的第一个子元素的上边距margin-top如果碰不到有效的border或者padding.就会不断一层一层的找自己 “领导”(父元素，祖先元素)的麻烦。只要给领导设置个有效的 border或者padding就可以有效的管制这个目无领导的margin防止它越级，假传圣旨，把自己的margin当领导的margin执行。 解决办法： 1、父元素或者子元素使用浮动或者绝对定位。 2、父级设置overflow:hidden 3、父级设置padding（破坏非空白的折叠条件） 4、父级设置border 元素之间默认出现空白问题 https://blog.csdn.net/bidang3275/article/details/121603878 产生间隙的原因 元素被当成行内元素排版的时候，元素之间的空白符（空格、回车换行等）都会被浏览器处理，根据 white-space 的处理方式（默认是 normal ，合并多余空白），所以元素之间就出现了空隙。并且行内元素之间的间距会随着字体的大小而变化，当行内元素 font-size:16px 时，Chrome 浏览器的间距为 8px 。 解决方法【7个】 1、行内元素写在一行 2、行内元素之间加上空白注释 3、父元素的 font-size 设置为 0，子元素单独设置 font-size 4、【不推荐】给行内元素设置【负 margin 】抵消元素间的空白，该方法不通用，因为不同浏览器之间行内元素间隙大小不统一 5、让行内块浮动起来 6、父元素开启 flex 或 grid 布局 7、给父元素设置【负字符间距】 或 【负单词间距】，行内子元素再设置为 0 flex内容溢出问题 https://blog.csdn.net/Y_G_G/article/details/108405514 解决方式： 1、设置width属性，一般设置为width: 0 2、min-width来限制， 一般也是min-width: 0; 3、设置overflow:hidden Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-03-06 11:17:15 "},"daily work/app打包及上传.html":{"url":"daily work/app打包及上传.html","title":"app打包及上传","keywords":"","body":"参考：http://markdown.rossai.cn/r/jdrfucjix4ev0nslep0k nestapi.rossai.cn/rossapp // 获取所有app应用信息 nestapi.rossai.cn/rossapp // 添加新应用 id: number; app_version: string; app_logo_addr: string; platform_type: string; app_status: number; download_urls: string; app_name: string; used_customers: string; app_device_type: string; package_name: string; remark: string; create_time: Date; update_time: Date; nestapi.rossai.cn/rossapp/update/:id // 更改app应用信息 app_version:x.x.x download_urls:http://cloudpf.weunit.cn/app_download/apk/app仓库名称.apk app_name app_logo_addr ftp上传apk 站点：cloudpf.weunit.cn 用户名：www-data 密码：Ross_ftp 文件路径：/mnt/nfs-020/yly_docker/www/public/app_download/apk 裁片超市 app对应id：9 文件名：01-cutting-supermarket.apk xml：cp_version.xml 打包环境：caipian-build-env 裁片超市(天守) app对应id：58 文件名：01-cutting-supermarket.apk xml：cp_TianShou_version.xml 打包环境：caipian-build-env 扫码app（scan-app） app对应id：54 文件名：01-scan-app.apk xml：scan_version.xml 打包环境：cordova直接打包，版本修改在config.xml中 wms app对应id：56 文件名：02-pdawms-new.apk xml：wms_version.xml 打包环境：wms-build-env 上线平板 app对应id：46 文件名：02-onlinearrange.apk xml：oa_version.xml 打包环境：cordova直接打包，版本修改在config.xml中 aql app对应id：38 文件名：01-AQL.apk xml：aql_version.xml 打包环境：AQL-build-env Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-03-07 14:01:53 "},"daily work/app条码.html":{"url":"daily work/app条码.html","title":"app条码","keywords":"","body":"WMS 物料收料 i7nbgpmmo 6tzrdwef9s dctmifob4 ojhsilah7 zdkzvx8i3 2soo56d0ln 执料出库 2kwcn5w2cb HBCDPIL2NEWDXKYX 一般出库 I21122300001 R22011900009 R22011900008 R22011900008 R22011900008 R22011900010 OutMatioid 出库单号 ReqMatioid 领料通知单 WwMatioid 生产通知单 库位调整 测试环境： B1-20 的 PD22032408273 调到 G00001 A1-1 的 PD22032408273 调到 A1-2 裁片超市 扫码计件 00100003595 00100003594 0010000330302 0010000330202 0010000330102 0010000330002 00100003759 00100003760 00100003761 00100003762 00100003766 样衣app W20220623136-01 W20220621526-01 W20220624949-01 接口地址http://237i9.rossai.cn:40080 账号密码:1007/123456 版单号:ban663322 款号:A-00020003 版单条码:test123456 卡号 12345678901234567890 123456 123 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-02-09 13:40:24 "},"daily work/公司分享.html":{"url":"daily work/公司分享.html","title":"公司分享","keywords":"","body":"网页调试分享 http://markdown.rossai.cn/r/sxquh8xlctetmlnepokb Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-22 09:53:43 "},"daily work/周报模板.html":{"url":"daily work/周报模板.html","title":"周报模板","keywords":"","body":"周报模板 每周一前发送到赖总和东哥的邮箱 https://qiye.aliyun.com/ 赖总邮箱：lai0001@ross.com.cn 东哥邮箱：ent@ross.com.cn 张总邮箱：zhang0002@ross.com.cn 侯慧莹邮箱：hou0603@ross.com.cn 李文霞邮箱：li0310@ross.com.cn 每周周报要求的内容 本周工作 1.客户项目： 2.软件产品名称： 3.软件版本号 4.开发内容列表和重点技术点 5.相关文档：直接写链接 6.修改发布不同的版本 7.沟通事宜 例子： 一.部门：技术部 二.汇报人：陈柏霖 三.软件产品名称（客户项目）：衣链云 四.软件版本号：R1.20200229 五.开发内容列表 1.新增商城，防疫专区，内衣专区 2.订单微信推送，下单成功后，给管理员或者商家负责人推送信息，给买家推送支付成功信息； 3.订单列表页面，新增取消订单，删除订单，确认收货，查询快递等 4.防疫入口首页修改和底部菜单修改，会员中心跳转路由修改（用于微信菜单增加会员中心，方便在这里进行商家入驻） 6.企业二维码改成个人分享二维码 7.商家后台订单列表修改（类似俏丹娜） 8.新增货到付款，上门自提等快递插件 9.会员中心，增加会员清单（会员中心的我的粉丝，一级粉丝和二级粉丝）； 增加分成清单（会员中心的推广收益）； 个人信息，增加会员角色：店长/会员； 10.商品页面，增加分享利益的浮动提示（接口开发）； 11.下单，付款后，按照分钱模式进行分钱。 12.企业入驻，增加买手/业务经理 13.解决实施反馈的问题 六.重点技术点 分享收益浮动提示采用ion-fab标签 七.沟通事宜 开发细节已和赖总，东哥，刘工等沟通确认 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-06-17 12:21:33 "},"daily work/工作信息.html":{"url":"daily work/工作信息.html","title":"工作信息","keywords":"","body":"日常工作文档 http://markdown.rossai.cn/login?redirect=http%3A%2F%2Fmarkdown.rossai.cn%2Fmember%2Fdoc 账号：广州-罗斯-新手 密码：123456 或 账号：webteam 密码：Ross0000 我的公司邮箱 http://mail.ross.com.cn/alimail/ 账号：liang0608@ross.com.cn 初始密码：Ross1234 禅道(问题跟踪) http://zentao.rossai.cn:38080/index.php http://192.168.1.197:38080/index.php 账号：ross007 密码：ross123456 ross智能库dokuwiki跟工单系统redmine 内网配置： 将doku.ross.210写入hosts文件里 C盘 - > Windows - > System32 - > drivers-> etc - > hosts http://doku.ross.210 外网地址：http://59.41.187.98:10083/ 90ftp 地址:192.168.2.90 账号：0web 密码：0web 许总原型图 https://2yozsg.axshare.com 密码：Rossrandy812 样衣 https://37eg2i.axshare.com 密码：Rossrandy812 app前端上传操作文档 http://markdown.rossai.cn/r/jg0azufpdq7orkn997vw 访问地址：192.168.1.166 密码：Ross_ftp 上传地址：/home/www-data/k8s/237/master/front 外网地址：http://237i9.rossai.cn:1414/项目名 内网地址：http://192.168.1.166:1414/项目名 飞鹅打印机默认配置 账号：2183558705@qq.com 密钥：ZpeSxTBgSCm6yYkJ 编号：960205439 运程 59.41.187.99:6789 账号：administrator 281340353 Ross0000 远程密码：Ross_ftp 周报 http://markdown.rossai.cn/r/6y7uoz9y2gd8g1ddhlgr git 日志 实时推送到线上 http://192.168.2.208:10081/xrayly/06-yilianyun2018 账号：xrayly 密码：123456 所有项目地址 http://192.168.2.208:3000/xrayly 账号：xrayly 密码：123456 线上仓库 http://zentao.rossai.cn:30001 账号：ross 密码：test1234 本地看板 http://192.168.2.208:3000/xrayly/03-bigDataKanban.git 账号：lkf 密码：111222 开发文档 http://markdown.rossai.cn/r/g2cmdbmrnwdtsv7lesos#12.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE swagger http://cloudpf.weunit.cn:30004/ i9项目 237外网访问地址： http://237i9.rossai.cn:414/i9scm http://237i9.rossai.cn:414/i9mes 内部访问地址： http://192.168.1.237:414/i9scm 内部测试地址： http://192.168.1.115:414/i9scm 220打包地址：http://192.168.1.242:30080 用户名：xrayly 密码：123456 scm升ng14测试地址 http://weunit.rossai.cn/i9scm/ 对应仓库： http://192.168.1.220:3000/xrayly/05-webscm.git 线上看板 http://zentao.rossai.cn:30001/ross/03-bigDataKanban 账号：ross 密码：test1234 智能化数字工厂看板系统 https://www.kdocs.cn/l/ch4aAY0CRjvp http://cloudpf.weunit.cn/cloudpf/KanBanApp/getKanbanList?taxpayerid=91440116726790339T&password=123456&equipment_id=001 企业纳税号：91440116726790339T 企业密码：123456 设备号：001 衣链云项目 本地地址：http://yilianyun2018.test.com/index.php/Admin/Index/index.html 线上地址：http://cloudpf.weunit.cn/index.php/Admin/Index/index.html 账号：admin 密码：111222 产销通 http://markdown.rossai.cn/r/r8nndzarlaw9duwwg1rl http://markdown.rossai.cn/r/nybgfhfohspigoylnevg swagger地址：http://cloudpf.weunit.cn:30004/ 线上地址：http://cloudpf.weunit.cn/productsale/index/ token: d2a0714d8da2160952a21eaba0b05341 apiHost: http://cloudpf.weunit.cn 竞品效果图：http://markdown.rossai.cn/r/8akixzjxr9txwueyljgk 生产排期字段描述：http://markdown.rossai.cn/r/ibjg2fvfaemeg8hrdnpg 验布 http://cloudpf.weunit.cn/erpapp/yanbu/index/login 验布APP使用流程文档：http://markdown.rossai.cn/r/0svzjlmcqphmvgx2klmu#%E7%99%BB%E5%BD%95%E9%A1%B5 衣链云： ip地址：cloudpf.weunit.cn 端口号：80 账号：13503090926 密码：123456 ip地址：cloudpf.weunit.cn 端口号：80 账号：1007 密码：123456 溢丰达： ip地址：59.33.34.118 端口号：50080 账号：系统管理员 密码：9009 面辅料 https://lanhuapp.com/url/4PKN0 APP 打包流程 http://markdown.rossai.cn/r/jdrfucjix4ev0nslep0k 账号：www-data 密码：Ross_ftp 账号：user205 密码：654321 所有 APK 下载 http://cloudpf.weunit.cn/apk/#/ Swagger 与 OpenAPI 文档 https://www.breakyizhan.com/swagger/2994.html IONIC项目测试 账号：13662992256 密码：111222 开发问题分享 http://markdown.rossai.cn/r/qv4t5gjibbuzhqhzrr90 聊天：https://jchat.im.jiguang.cn/#/main https://github.com/jpush/cordova-plugin-jcore 翻墙工具： https://github.com/Alvin9999/new-pac/wiki/ss%E5%85%8D%E8%B4%B9%E8%B4%A6%E5%8F%B7 二哈（公众号管理后台） http://test.rossai.cn/admin/login/index.html 账号：admin 密码：Ross0000 多公众号相关账号说明 http://markdown.rossai.cn/r/4zkufoscgqlqcfrjdvmw 多公众号云工厂说明文档 http://markdown.rossai.cn/r/od5iguobkdwc29rtngej 开发账号及配置 俏丹娜 柏林： 账号：13662992256 密码：111222 谭工： 账号：18102816288 密码：123456 公众号：娜生活 NA LIFE 网页地址：http://kangduoebao.com/sellerapp 衣链云dev 账号：13662992256 密码：111222 上线平板 测试服务器连接地址：r7test.gloria.com.cn:5414 正式服务器环境地址：r7weblogic.gloria.com.cn:5414 咖啡吧数据库：59.41.187.99:6790 李伟建地址：192.168.1.88:8001 工作组：001 用户名：001 员工卡：0001760333 工票卡：0011487460 000000000101 000000000102 000000000103 000000000104 单号：2022040101 Scan.onRocardEvent({cardNo:''}); ip：237i9.rossai.cn:40080 工作组：033 用户名：002 员工卡：0012616174 工票卡：0001581246 咖啡吧 工作组：001 用户名：001 员工卡：0001760333 工票卡：0010861747 拉布APP 配置接口IP：r7test.gloria.com.cn:5414 PO备注：0002575088 咖啡吧：59.41.187.99:6790 卡号：0000080276 拉布操作和接口 http://markdown.rossai.cn/r/zruwteqqke4rq8gemets http://markdown.rossai.cn/r/gxuxjbslaurhelcgmlyl 拉布说明 1.填写备注后点击标题登录 2.如果是刷唛架那些，就不调刷卡登录，刷卡登录是全局的 o2o-sellerapp 账号：13662992256 密码：111222 测试地址：http://o2o.weunit.cn/sellerapp/ 公众号：锵锵服装 o2o-mall 请求地址加”?store_id=2“ 账号：19175888020 密码：111222 上线平板、广告机，拉布不用管 交接地址：http://markdown.rossai.cn/r/hfgujv5ttkaex4oh9mmm PDA型号：ax 6737 65 n PDA WMS 移动仓库 ip：59.41.187.99 端口：6791 账号：RFID 密码： 返工号：0002390914 歌莉娅正式环境： ip：formgly.rossai.cn 端口：8803 账号：吴真 密码：123456 歌莉娅测试环境： ip：testgly.rossai.cn 端口：8889 账号：IT 密码：123456 PC端测试地址： 咖啡吧测试地址：http://59.41.187.99:6789/wmsnew 1段网络直连梁工电脑：http://192.168.2.71/02-pdawms-new/www PDA 天守 MES 裁片超市 ip：59.41.187.99 端口：6790 账号：系统管理员 密码：0000 PC端测试地址： 咖啡吧测试地址：http://59.41.187.99:6789/caipiannew 2段网络直连梁工电脑：http://192.168.2.71/01-cutting-supermarket/www PDA 天守 MES 裁片超市（客户配置） ip：211.143.202.8 端口：5414 账号：系统管理员 密码：0000 返工登记卡号：0002246779 测试账号：罗斯测试 测试密码：0000 PDA 天守 MES 裁片超市（新端口） ip：47.106.144.103 端口：8001 ip:cloudpf.weunit.cn 端口：80 ip:61.142.88.249 端口：5414 50080 账号：系统管理员 密码：0000 演示环境：http://ross.rossai.cn/i9mes 对应ip：http://rossapi.rossai.cn 对应端口：80 验收环境：http://rd.rossai.cn/i9mes 对应ip：http://cloudpf.weunit.cn 对应端口：80 验布（dev） ip：59.33.34.118 端口：50080 账号：系统管理员 密码：9009 收料单号：IN2203-0076 PC端测试地址： 咖啡吧测试地址：http://59.41.187.99:6789/yanbu 2段网络直连梁工电脑：http://192.168.2.71/02-yanbu/www QC巡检（polling） ip：120.238.147.132 端口：5416 账号：rfid 密码： 返工登记卡号：0002246779 ip：cloudpf.weunit.cn 端口：80 账号：罗斯测试 密码：0000 返工登记卡号：0005427105 // lwj ip：192.168.1.88 端口：8001 账号：000857857 密码：123456 MES工位机 工作组：001 用户名：Ross 密码：sa 服务器连接地址：59.41.187.99:6790 解锁密码：710289 辉鹏 地址：http://www.rossai.com.cn:6789/www 账号：13662992256 密码：111222 AQL 账号：1007 密码：123456 板房app 接口文档：https://kdocs.cn/l/cv13kIjxNlYY 接口地址：http://237i9.rossai.cn:40080 账号密码：1007/123456 版单号：ban663322 款号：A-00020003 版单条码：test123456 卡号 12345678901234567890 123456 123 SCM 佛山丽妍 http://fsly.rossai.cn/i9scm 系统管理员：fslyadmin 密码：777888 测试用户：谭诗 密码：123456 依爱夫 http://121.196.234.127:8081/i9scm 系统管理员：yafadmin 密码：777888 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-01-31 16:29:34 "},"daily work/开发对照表.html":{"url":"daily work/开发对照表.html","title":"开发对照表","keywords":"","body":"i9和app默认跟进人列表 运维相关 1.公众号,企业微信，钉钉申请和配置 赖经理 2.项目部署 乐天和东哥 3.数据库配置和初步测试 吴鹏海 4.i9打印报错 原因：没有更新打印插件和权限问题 负责人：东哥,乐天 5.SQL调试功能无法使用 原因：没有更新最新的内核和配置权限 负责人：东哥,乐天 6.i9和app数据库升级 负责人:吴鹏海 7.移动端打印-飞鹅打印机 负责人:陈柏霖 8.看板app-设备选型 电视盒子，安卓版本5.1以上 负责人:陈柏霖 9.app打包 负责人:乐天 10.系统卡死，无法登陆 负责人:东哥,乐天, 陈柏霖 11.其他疑难问题解决，卡慢问题 负责人:陈柏霖，梁云 开发相关 1、企划任务/拍照上传/产品墙/成本计价： 前端叶锐林，后端:颜平 2、产品工艺单/样板工艺单/生产订单/加工BOM： 前端焦工,后端:蔡贤龙,Linda 3、计划排单，成品加工，成品采购，工艺加工：实裁数汇报，外发进度报数，比价批价，板房工作任务，制单工作任务 前端：梁坤峰，后端：陈柏霖，linda 3.1供应商档案 前端：梁坤峰，后端：黄海斌 4、物料计划： 前端：张丞源，后端：张平 5、采购单: 前端：韦泽南，后端：朱立合 5、收料单: 前端：何梓贤，后端：张平 6、入库单: 前端：何梓贤，后端：黄海斌 7、采购结算单: 前端：韦泽南，后端：黄海斌，梁云 8、加工收货: 前端：叶锐林，后端：朱立合 9、加工入库: 前端：叶锐林，后端：朱立合 10、加工结算: 前端：韦泽南，后端：黄海斌，梁云 11、领料通知: 前端：叶锐林，后端：杨磊 12、领料出库: 前端：叶锐林，后端：杨磊 13、原料加工单: 前端：韦泽南，后端：杨磊 14、原料加工领料: 前端：叶锐林，后端：杨磊 15、原料加工收料: 前端：张丞源，后端：颜平 16、原料加工入库: 前端：张丞源，后端：颜平 17、原料加工结算: 前端：韦泽南，后端：梁云 18、主料检验: 前端：何梓贤，后端：吴燕兵 19、辅料检验: 前端：何梓贤，后端：吴燕兵 20、一般入库: 前端：张丞源，后端：杨磊 21、开发进度: 前端：谢存镕，后端：吴燕兵 22、生产排期: 前端：谢存镕，后端：吴燕兵 23、生产协同: 前端：韦泽南，后端：吴燕兵 24、一般出库: 前端：张丞源，后端：张平 25、物料调拨: 前端：张丞源，后端：杨磊 26、销售出库: 前端：叶锐林，后端：张平,李振兴 27、销售结算: 前端：韦泽南，后端：黄海斌，梁云 28、备料计划: 前端：叶锐林，后端：杨磊 29、请购单: 前端：韦泽南，后端：黄海斌 30、i9微信推送: 前端：梁坤峰，何梓贤 后端：黄海波，梁云 31、主料档案、辅料档案: 前端：韦泽南，后端：黄海波 32、自定义报表平台 前端：叶锐林，后端：李振兴 33、自定义菜单 前端：梁坤峰，后端：李振兴 34、成品调拨 前端：张丞源，后端：黄海波 35、加工登记: 前端：叶锐林，后端：李伟健 36、应收管理 前端：张丞源，后端：杨磊 37、应付管理 前端：严世奇，后端：黄海斌 38、跟单成本核算 前端：张丞源 后端：黄海斌 39、板房APP、样衣APP 前端：梁坤峰 后端：陈柏霖 40、WMS 前端：梁坤峰/谢纯镕/陈俊宇 后端：朱立合 41、物料库存 前端：谢纯镕 后端：吴燕兵 42、表单设计器 前端：叶锐林 后端：黄海波 43、加工工序 前端：谢永福 后端：朱立合 44、外发组别 前端：谢永福 后端：杨磊 45、跟单组别 前端：谢永福 后端：杨磊 46、供应商类型 前端：谢永福 后端：黄海斌 47、供应商选择组件 前端：谢永福 后端：黄海斌 48、币种档案 前端：谢永福 后端：杨磊 49、备注档案 前端：谢永福 后端：杨磊 50、币种档案 前端：后端：杨磊 51、样板类型 前端：谢永福 后端：杨磊 52、i9注册 前端：谢永福 后端：李伟健 53、区域档案 前端：谢永福 后端：杨磊 54、工序档案 前端：谢永福 后端：李伟健 55、请购类型 前端：谢永福 后端：黄海斌 56、人事档案 前端：叶锐林 后端：李伟健 57、票据类型 前端：谢永福 后端：黄海斌 58、科目代码 前端：谢永福 后端：朱立合 59、库位档案 前端：谢永福 后端：杨磊 60、图片档案 前端：谢永福 后端：杨磊 61、费用档案 前端：谢永福 后端：朱立合 62、核算类别 前端：谢永福 后端：朱立合 63、图片分类 前端：谢永福 后端：杨磊 64、仓库档案 前端：谢永福 后端：杨磊 65、成品颜色档案 前端：谢永福 后端：杨磊 66、出库类型 前端：谢永福 后端：杨磊 67、入库类型 前端：谢永福 后端：杨磊 68、物料颜色分类 前端：谢永福 后端：杨磊 69、审批设置 前端：谢纯榕 后端：张平 70、加工类型 前端：谢永福 后端：朱立合 71、单位档案 前端：谢永福 后端：杨磊 72、价格类型 前端：谢永福 后端：杨磊 73、多单位转换 前端：谢永福 后端：杨磊 74、集团机构档案 前端：谢永福 后端：朱立合 75、规格档案 前端：谢永福 后端：朱立合 76、汇率设置 前端：谢永福 后端：朱立合 77、操作员档案 前端：谢永福 后端：朱立合 78、工作组档案 前端：谢永福 后端：朱立合 79、价格审批 前端：张丞源 后端：张平 80、企划综合分析 前端：何梓贤 后端：颜平 81、订单统计报表 前端：何梓贤 后端：颜平 82、订单发货预报 前端：何梓贤 后端：颜平 83、加工回货预报 前端：何梓贤 后端：陈柏霖 84、生产进度统计报表 前端：何梓贤 后端：钟坚 85、采购进度报表 前端：何梓贤 后端：张平 86、进出日报表 前端：何梓贤 后端：杨磊 87、进出日报表 前端：何梓贤 后端：黄海斌 88、进出日报表 前端：何梓贤 后端：颜平 89、条码打印单 前端：张丞源 后端：杨磊 90、物料销售订单 前端：张丞源 后端：杨磊 91、异常处理单（物料） 前端：谢永福 后端：张平 92、异常处理单（成品） 前端：谢永福 后端：张平 93、款号档案 前端：焦工 后端：张平 94、AQL/供应商APP/加工厂 前端：梁坤锋 后端：陈柏霖 99、i9打印 前端：梁坤锋 后端：陈柏霖 梁云 100、云mes 前端：陈俊宇 后端：李伟健 101、裁片超市 前端：梁坤锋 后端：李伟健 102、扫码计件APP 前端：陈俊宇 后端：李伟健 103.i9看板 前端：陆同乐 后端：蔡贤龙/黄海波 104.看板APP 前端：梁坤峰 后端：陈柏霖 105.i9mes 指派给梁彬，统一安排处理 前端:焦工，陆工 后端:蔡工，李伟健，钟坚 106.QC平板 前端:陆同乐 后端:钟坚 107.平板工位机（制造执行系统） 前端：陈俊宇 后端：李伟健 108.客户订单 前端：焦建华 后端：颜平 109.成品库存 前端:谢纯榕 后端：吴燕兵 110.openbi看板，可视化看板系统 前端:陆同乐 后端：陈柏霖 111.制单工序 前端陆同乐,后端:蔡贤龙,Linda 112.客户档案 前端:何梓贤 后端:黄海波 113.实验室 前端:何梓贤 后端:黄海波 114.拉布平板 前端:陈俊宇 后端:李伟健 115.菜单和权限 前端:梁坤锋 后端:李振兴 116.物料订单 前端是 张承源 后端 杨磊 117.公共管理 前端是何子贤 后端是梁云 118物料出库 前端张丞源 后端:杨磊 119.产能确认 前端:梁坤锋 后端黄海斌 120.看板数据同步 黄海波 121.批发订单 后端：颜平 前端：韦泽南 122.成品一般入库 前端叶锐林，后端李振兴 123.松布app和验布app 前端:何梓贤 松布app后端:吴桃利 验布app后端:黄海波 124.装箱模块 前端是谢永福，后端是颜平 125.用户管理，登陆注册 后端:蔡贤龙 前端：焦工，梁坤锋 136.用户审批 后端:李伟建 前端：陈俊宇 137.款工序 前端是陆同乐 后端是蔡贤龙 138.仓库月结 后端：黄海斌 前端：焦建华 139.报关管理 后端梁云，前端张嘉乐 140.生产入库 后端杨磊、前端张丞源 141.盘点单 后端朱立合 前端张嘉乐 142.工艺尺寸档案 前端：张嘉乐 后端： 144.进销存月报表 后端杨磊 前端何梓贤 145.款式档案 后端是张平 前端严世其 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-06-09 10:38:22 "},"daily work/微信推送.html":{"url":"daily work/微信推送.html","title":"微信推送","keywords":"","body":"微信推送 test.rossai.cn/weapp/Wechat/getPushMessageDetail：企业微信端获取详情接口。 test.rossai.cn/mp/MultipleWechat/getPushMessageDetail：微信公众号端获取详情接口。 id:1300 token:3877151c4f6e58e923fd3be2928f8d41 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-10-11 10:11:49 "},"daily work/项目推送.html":{"url":"daily work/项目推送.html","title":"项目推送","keywords":"","body":"前后端一起(所有项目列表) ssh user209@192.168.1.209 bash /home/user209/mnt/rsync_menu.sh 测试到生产的命令 密码：123456 0 -- 到沙箱 1.2.3 到客户 如果不选123，就客户自动拉 --后端 ssh user209@192.168.1.209 bash /home/user209/mnt/rsync_backend.sh 密码：123456 0 -- 到沙箱 1.2.3 到客户 如果不选123，就客户自动拉 # 推送 ssh user209@192.168.1.209 bash /home/user209/mnt/rsync_tongyi.sh 密码123456 http://weunitscm.rossai.cn/i9 ylyadmin 111222 # 中山同益 http://14.118.134.30:8081/i9scm 数据库：i9fs， 账套：发饰事业部 tyfsadmin 111222 # 姐妹花 http://61.142.130.137:4033/i9scm jmhadmin 444555 # 奥特 http://zzaote.rossai.cn/i9scm/ zzatadmin 777888 # 晨风（只有mes） http://jschenfeng.rossai.cn:58081/i9mes jscfadmin 777888 # 湖北晨瑞 http://hbcr.rossai.cn/i9scm hbcradmin 112233 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-03-24 21:09:11 "},"git/常用命令.html":{"url":"git/常用命令.html","title":"常用命令","keywords":"","body":"全局信息配置 git config --global user.name \"\" git config --global user.email \"\" 局部信息配置 git config user.name \"\" git config user.email \"\" 查看设置 git config --list 或 git config --system --list # 查看系统配置 git config --global --list # 查看全局配置 git config --local --list # 查看本地仓库配置 删除本地缓存 git rm -r --cached . 查看分支 git branch -a 查看所有分支 git branch -r 查看远程分支 git branch 查看本地分支 拉取所有分支 git branch -r | grep -v '\\->' | while read remote; do git branch --track \"${remote#origin/}\" \"$remote\"; done 设置全局时间 # 小写 # %a 星期（缩写）：Sat # %b 月份（缩写）：Apri # %c 格式化输出日期时间 月/日/年 时:分:秒：04/25/20 18:21:01 # %d 日期：25 # %j 一年的第几天：116 # %m 月份数字：04 # %p 上下午：AM/PM # %w 星期几（0-6）：6 # %x 格式化输出短日期：04/25/20 # %y 年份：20 # %z 时区：+0800 # 大写 # %A 星期（全写）：Saturday # %B 月份（全写）：April # %H 24小时制：18 # %I 12小时制：06 # %M 分钟：21 # %S 秒：01 # %U 一年的第几周（星期日作为每周的第一天）：16 # %W 一年的第几周（星期一作为每周的第一天）：16 # %X 格式化输出短时间：18:21:01 # %Y 年份：2020 # %Z 时区：+0800 # 设置全局时间输出 YYYY-MM-DD HH:mm:ss git config --global log.date iso # git log --author CodeFront --pretty=format:\"%h %cd %cr %s\" --date=iso 格式化日志 git log --pretty=oneline git log --pretty=format:\"%h - %an, %ar : %s\" git log --pretty=format:\"%an %ae %ad %cn %ce %cd %cr %s\" # git log --author lkf --pretty=format:\"%cr %s\" 查看提交内容 git show [commitid] 以theirs方式合并指定分支 git merge --strategy-option=theirs origin/xxx 取消合并 git merge --abort 撤销合并 git reset --soft: 将分支回退到指定提交，工作区维持现状不变,暂存区会在现有基础上增加该commit之后的提交。 git reset --mixed: （默认操作）将分支回退到指定提交，暂存区也被同步为该指定提交，工作区保持不变。 git reset --hard: 将分支回退到指定分支，暂存区和工作区都会被同步为该指定的提交。 合并指定的提交内容 git cherry-pick [commitid] ... # 可合并多个提交的id 拉取远程指定分支 git clone -b 远程分支名 远程地址 push 远程指定分支（未创建） git push --set-upstream origin xxx 强推并覆盖远程分支（提交记录会被清掉） git push origin xxx --force 拉取一条本地不存在的分支，并关联起来 git checkout -b 本地分支名 origin/远程分支名 删除本地分支 git branch -D xxx 恢复本地分支 git checkout -b 删除的分支名 删除的commitid 删除远程分支 1.查看远程分支 git branch -a 2.切换到查看到的远程分支（remotes/origin/HEAD -> origin/master） git checkout master 3.执行删除 git push origin --delete 远程分支 回滚指定版本并覆盖远程 git reset --hard xxx git push --force # 强制覆盖到远程，会将日志重置到指定版本 强制拉取覆盖本地： git fetch --all git reset --hard origin/master git pull 分支覆盖：（将 dev 覆盖到 master 分支） git checkout master git reset --hard origin/dev git push -f 添加钩子 git remote add origin [git地址] git push -u origin master git 切换到远程分支（remote后需要关联到指定分支操作） git branch xxx git checkout xxx 切换到第二个分支 git branch --set-upstream-to origin/xxx 关联到第二个分支 git log --graph --decorate --oneline --simplify-by-decoration --all 显示分支图，找到远程分支的开始节点 git reset --hard *** 切换到远程分支 xxx 的工作目录，这时候就可以正常使用了 将其他分支所有日志与当前分支合并 参考： https://www.cnblogs.com/coderxx/p/11544550.html git checkout dev git merge dev_add --no-ff Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-05-16 09:23:42 "},"git/常见问题.html":{"url":"git/常见问题.html","title":"常见问题","keywords":"","body":"代码丢失或被覆盖修复方式 方式1： 1.通过“git log --author [用户名] --oneline”查找自己本地的提交日志，提交日志存在，则代码已被覆盖 2.通过“git reflog --date=iso”查找到你丢失代码最后提交的commitid 3.使用“git reset --hard [commitid]”回滚到当前节点，拷贝相关代码或文件自行覆盖 方式2： 1.通过“git log --author [用户名] --oneline”查找自己本地的提交日志，提交日志不存在，则代码已被回滚 2.通过“git reflog --date=iso”查找到你丢失代码最后提交的commitid 3.使用“git reset --hard [commitid]”回滚到当前节点，拷贝相关代码或文件自行覆盖；或者使用“git cherry-pick [commitid]”进行代码合并。 git代码评审，可设置管理者进行代码合并，减少代码丢失、误改问题： https://help.gitee.com/enterprise/code-manage/%E4%BB%A3%E7%A0%81%E8%AF%84%E5%AE%A1/Pull%20Request/%E5%BC%80%E5%8F%91%E5%8D%8F%E4%BD%9C/%E4%BD%BF%E7%94%A8%20Pull%20Request%20%E5%8A%9F%E8%83%BD%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 14:55:05 "},"git/里程碑.html":{"url":"git/里程碑.html","title":"里程碑","keywords":"","body":"里程碑(tags) 描述 里程碑就是Git中的tag，tag是与某个具体的提交（commit）关联的，使用里程碑的好处在于可以直观的看到版本的演变历史，而不是简单生硬的commit id。里程碑的命令是git tag，可以创建、删除和查看里程碑。 查看标签 git ls-remote --tags origin # 查看远程所有标签 git tag -l # 查看本地所有标签 创建标签 # 方式一: 默认 `HEAD` 指向的版本 git tag 标签名 # 方式二: 指定 `commit_id` 表示的版本 git tag 标签名 [] # 方式三: 指定 `commit_id` 表示的版本,同时创建标签说明信息 git tag -a 标签名 -m 提交信息 [] 删除标签 远程： git push origin :refs/tags/标签名 # 推送并删除远程标签，只能单个删除 git push origin -d tag 标签名 # git v1.7.0 之后支持该写法，可同时推送并删除多个tag 本地： git tag -d 标签名 推送标签 git push origin --tags # 推送所有标签 git push origin 标签名 # 推送单个标签 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-03-30 13:26:32 "},"ionic/ionic.html":{"url":"ionic/ionic.html","title":"ionic","keywords":"","body":"ionic（移动端UI） 官网地址：https://ionicframework.com/ 兼容 ios|android(md) 系统 安装 npm install -g @ionic/cli 创建项目 ionic start --list ionic start 项目名称 ionic start 项目名称 blank ionic start 项目名称 tabs --cordova ionic start 项目名称 tabs --capacitor ionic start 项目名称 super --type=ionic-angular ionic start 项目名称 blank --type=ionic1 路由返回并销毁页面 import { NavController } from '@ionic/angular'; constructor(){ public navController: NavController, } /** 返回 */ back() { this.navController.navigateBack('home'); } 页面创建 // 非app路径下，无法生成module且无法合并到指定的module ionic g page 页面路径 -m app // app路径下，自动创建module ionic g page 页面路径 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-02-08 10:12:39 "},"ionic/开发问题.html":{"url":"ionic/开发问题.html","title":"开发问题","keywords":"","body":"打包apk，页面被上移 http://www.wjhsh.net/share901124-p-7645324.html ionic5升级最新的版本后，date日期选择组件变化过大 https://blog.csdn.net/ch_weni/article/details/122210297 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-10-09 14:40:26 "},"ionic/技巧.html":{"url":"ionic/技巧.html","title":"技巧","keywords":"","body":"ion-item button：设置为按钮模式，带有跳转箭头 herf：设置跳转链接，带有跳转箭头 routLink：设置跳转链接，带有跳转箭头 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-08-18 17:00:56 "},"javascript/BroadcastChannel通信.html":{"url":"javascript/BroadcastChannel通信.html","title":"BroadcastChannel通信","keywords":"","body":"BroadcastChannel 通信 BroadcastChannel是一个HTML5 API，它提供了一种方法来在同源的多个浏览器窗口、标签页或Frame之间进行实时通信。这意味着您可以创建一个“频道”，并在这个频道上发布消息，所有订阅该频道的窗口都会收到这些消息。与WebSocket不同，BroadcastChannel只能进行单向通信，即只能发布消息，而不能收到回复。BroadcastChannel是一种非常有用的工具，可以用于各种应用程序，例如多个聊天窗口之间的通信，以及在Web应用程序中进行分布式计算等。值得注意的是，使用BroadcastChannel时需要注意安全性，因为未经身份验证的消息可能会被传输到敌对方，并且会破坏应用程序的完整性和机密性。 可以使用这些方法和事件来创建、发布和订阅消息频道，并在不同的浏览器窗口或标签页之间进行实时通信。 BroadcastChannel(name) 构造函数，用于创建一个BroadcastChannel实例。它需要一个字符串参数name，代表频道的名称。该实例可以用来发布和订阅消息。 javascriptCopy Codeconst channel = new BroadcastChannel('myChannel'); postMessage(message) 向该频道发布消息。消息可以是任何JavaScript可序列化的对象。 Codechannel.postMessage('Hello, world!'); close() 关闭该频道，释放相关资源。 Codechannel.close(); onmessage 当订阅该频道的窗口收到一条新消息时，会触发该事件。可以通过监听该事件来处理接收到的消息。 Codechannel.onmessage = function(event) { console.log(event.data); // 输出收到的消息 }; onmessageerror 当尝试解析从其他源发送的消息时遇到错误时，会触发该事件。可以通过监听该事件来进行错误处理。 Codechannel.onmessageerror = function(event) { console.log(event.message); // 输出错误信息 } BroadcastChannel还支持以下属性： name 频道的名称，只读属性。 console.log(channel.name); // 输出 'myChannel' 示例 // 在发送消息的窗口或标签页中 const channel = new BroadcastChannel('myChannel'); channel.postMessage('Hello, world!'); // 在接收消息的窗口或标签页中 const channel = new BroadcastChannel('myChannel'); channel.onmessage = function(event) { console.log(event.data); // 输出收到的消息 }; Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-10-07 09:34:14 "},"javascript/css文件转行内样式.html":{"url":"javascript/css文件转行内样式.html","title":"css文件转行内样式","keywords":"","body":"css文件转行内样式（打印机使用） https://github.com/jonkemp/inline-css var inlineCss = require('inline-css'); var html = ``; inlineCss(html,{url:'/'}).then(function(html) { console.log(html); }); Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-07-13 09:33:12 "},"javascript/DOM对象属性、鼠标事件.html":{"url":"javascript/DOM对象属性、鼠标事件.html","title":"DOM对象属性、鼠标事件","keywords":"","body":"DOM 对象属性 clientWidth、clientHeight clientWidth：width(样式中设置的) + 左右padding - 垂直滚动条宽度 clientHeight：height(样式中设置的) + 上下padding - 水平滚动条宽度 offsetWidth、offsetHeight 只与当前元素有关，与其他元素无关 offsetWidth：width(样式中设置的) + 左右padding + 左右border offsetHeight：height(样式中设置的) + 上下padding + 上下border offsetParent offsetParent属性返回一个对象的引用，这个对象是距离调用offsetParent的元素最近的（在包含层次中最靠近的），并且是已进行过CSS定位的容器元素。 如果这个容器元素未进行CSS定位, 则offsetParent属性的取值为根元素的引用 1、如果当前元素的父级元素没有进行CSS定位（position为absolute或relative），offsetParent为body。 2、如果当前元素的父级元素中有CSS定位（position为absolute或relative），offsetParent取最近的那个父级元素。 offsetTop、offsetLeft 与 offsetWidth 和 offsetHeight不同的是，它们受到 offsetParent 的影响 offsetLeft：(offsetParent的padding-left) + (中间元素的offsetWidth) + (当前元素的margin-left) offsetTop：(offsetParent的padding-top) + (中间元素的offsetHeight) + (当前元素的margin-top) scrollWidth、scrollHeight scrollWidth 可视区域宽度 + 被隐藏区域宽度 scrollHeight 可视区域高度 + 被隐藏区域高度 scrollTop、scrollLeft scrollTop：对象的最顶部到对象在当前窗口显示的范围内的顶边的距离，即在出现了纵向滚动条的情况下，滚动条拉动的距离 scrollLeft：对象的最左边到对象在当前窗口显示的范围内的左边的距离，即在出现了横向滚动条的情况下，滚动条拉动的距离 鼠标事件 示例 onclick 鼠标点击事件 box.onclick = function(e){ console.log(e) } onmousedown 鼠标按下事件 box.onmousedown = function(e){ console.log(e) } onmouseup 鼠标松开事件 box.onmouseup = function(e){ console.log(e) } onmousemove 鼠标移动事件 box.onmousemove = function(e){ console.log(e) } onmouseover 鼠标经过事件 box.onmouseover = function(e){ console.log(e) } onmouseout 鼠标划出事件 box.onmouseout = function(e){ console.log(e) } 一、clientX、clientY 点击位置距离当前body可视区域的x，y坐标 二、pageX、pageY 对于整个页面来说，包括了被卷去的body部分的长度 三、screenX、screenY 点击位置距离当前电脑屏幕的x，y坐标 四、offsetX、offsetY 相对于带有定位的父盒子的x，y坐标 五、x、y 和screenX、screenY一样 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 14:55:05 "},"javascript/excel导出.html":{"url":"javascript/excel导出.html","title":"excel导出","keywords":"","body":"excel导出 官方中文文档：https://github.com/exceljs/exceljs/blob/master/README_zh.md Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-08-04 10:34:07 "},"javascript/html转pdf.html":{"url":"javascript/html转pdf.html","title":"html转pdf","keywords":"","body":"HTML转PDF 参考：https://www.jb51.net/javascript/296466dco.htm cdn 下载：jspdf、html2canvas Document hello world const pdf = jspdf.jsPDF(); pdf.setProperties({ title: '', subject: '', author: '', keywords: '' }); html2canvas(document.querySelector('#test')).then(canvas => { const imgData = canvas.toDataURL('image/png'); pdf.addImage(imgData, 'PNG', 0, 0); pdf.save('aaa.pdf'); }); ES6 安装：jspdf、html2canvas npm install --save jspdf npm install --save html2canvas import jsPDF from 'jspdf'; import html2canvas from 'html2canvas'; const pdf = new jsPDF(); pdf.setProperties({ title: '', subject: '', author: '', keywords: '' }); html2canvas(document.querySelector('#test')).then(canvas => { const imgData = canvas.toDataURL('image/png'); pdf.addImage(imgData, 'PNG', 0, 0); pdf.save('aaa.pdf'); }); Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-01-11 14:50:30 "},"javascript/js写库方法.html":{"url":"javascript/js写库方法.html","title":"js写库方法","keywords":"","body":"javascript 写库方式 参考：https://www.cnblogs.com/lishanyang/p/12379928.html Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-06-07 14:08:29 "},"javascript/pdf文本获取.html":{"url":"javascript/pdf文本获取.html","title":"pdf文本获取","keywords":"","body":"pdf文本获取 参考：https://qa.1r1g.com/sf/ask/2844518561/ work工作区配置：https://www.aciuz.com/tech/PDF-js-workerSrc.html 文字提取顺序问提（pdf Y轴倒序获取、X轴正序获取方法）：https://www.thinbug.com/q/50788543 注：pdf文件必须存放在服务器上，不能获取file://协议文件，会提示跨域。 const pdfUrl = 'http://192.168.1.71/files/c.pdf'; function getText(pdfUrl) { var loadingTask = pdfjsLib.getDocument(pdfUrl); return loadingTask.promise.then((pdf) => { // 获取页数 const pageNum = pdf._pdfInfo.numPages; const countPromises = []; for (let index = 1; index { // 获取文本 const data = res.getTextContent(); return data.then((text) => { return text.items.map((item, i) => { return item.str; }).join(``); }); })); } console.log(countPromises); return Promise.all(countPromises).then((res) => { return res.join(''); }); }); } getText(pdfUrl).then((res) => { console.log(res); }, (err) => { console.log(err); }); Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-06-10 09:52:19 "},"javascript/webwork.html":{"url":"javascript/webwork.html","title":"webwork","keywords":"","body":"WebWorker Web Worker 是JavaScript提供的一种机制，用于在浏览器环境中执行长时间运行的脚本任务，以避免阻塞主线程的影响。它可以在后台运行，并与主线程进行通信。 使用 Web Worker 可以将耗时的计算密集型任务、大量数据处理或网络请求等放在独立的线程中执行，从而提高页面的响应性能和用户体验。 以下是使用 Web Worker 的基本示例： 创建一个 JavaScript 文件（例如 worker.js），它包含要在 Web Worker 中执行的代码逻辑，例如： javascriptCopy Code// worker.js self.addEventListener('message', function(event) { // 接收来自主线程的消息 const message = event.data; // 执行耗时任务 const result = performTask(message); // 将结果发送回主线程 self.postMessage(result); }); function performTask(message) { // 执行耗时任务 // ... return '任务完成'; } 在主线程中创建和使用 Web Worker。例如，在 HTML 文件中添加以下代码： htmlCopy Code Web Worker 示例 执行任务 var worker; function startWorker() { // 创建 Web Worker worker = new Worker('worker.js'); // 监听消息事件 worker.addEventListener('message', function(event) { // 接收来自 Web Worker 的消息 var result = event.data; // 更新页面或进行其他操作 document.getElementById('result').textContent = result; // 终止 Web Worker worker.terminate(); }); // 向 Web Worker 发送消息 worker.postMessage('开始任务'); } 在上述示例中，当用户点击按钮时，startWorker 函数会创建一个 Web Worker 对象，并设置监听事件来接收来自 Web Worker 的消息。然后，通过 postMessage 方法向 Web Worker 发送消息。 Web Worker 中的 performTask 函数执行耗时任务，并将结果使用 postMessage 发送回主线程。主线程中的监听函数接收到消息后，更新页面的内容，并终止Web Worker。 这样，你就可以利用 Web Worker 在后台执行耗时任务，而不会阻塞主线程。请注意，Web Worker 不适用于所有情况，需根据具体需求和场景选择是否使用。 案例： worker.js // worker.js self.addEventListener('message', function(event) { const message = event.data; // 在这里执行耗时任务，可以是计算密集型操作或者网络请求等 // 模拟一个耗时的任务 const result = simulateLongTask(message); // 将结果发送回主线程 self.postMessage(result); }); function simulateLongTask(message) { // 模拟耗时任务，这里延迟2秒钟 const startTime = Date.now(); while (Date.now() - startTime 主线程 Web Worker Demo 执行任务 function executeTask() { // 创建 Web Worker const worker = new Worker('worker.js'); worker.addEventListener('message', function(event) { // 处理来自 Web Worker 的消息 const result = event.data; // 更新页面或进行其他操作 document.getElementById('result').textContent = result; console.log(result) // 终止 Web Worker worker.terminate(); }); // 向 Web Worker 发送任务信息 worker.postMessage('执行耗时任务'); } Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-08-27 14:41:07 "},"javascript/前端实用方法和工具.html":{"url":"javascript/前端实用方法和工具.html","title":"前端实用方法和工具","keywords":"","body":"文件下载 git clone https://github.com/shb190802/front-end-file-download.git cd front-end-file-download npm installnode app.js // 浏览器打开 http://localhost:3000 处理下载跳转问题： https://blog.csdn.net/u013217071/article/details/124348909 获取文件的base64 return new Promise((resolve, reject) => { const render = new FileReader(); reader.readAsDataURL(file); reader.onload = () => resolve(reader.result); reader.onerror = error => reject(error); }) 将base64转换为文件 function dataURLtoFile(base64) { var arr = base64.split(','), bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while (n--) { u8arr[n] = bstr.charCodeAt(n) } let file = { name: String(new Date().getTime()), type: arr[0].match(/:(.*?);/)[1] }; return new File([u8arr], file.name, { type: file.type }) } 生成guid function guid() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) { const r = Math.random() * 16 | 0; const v = c == 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); } 获取浏览器缩放比例 detectZoom() { let ratio = 0; let screen = window.screen; let ua = navigator.userAgent.toLowerCase(); if (window.devicePixelRatio !== undefined) { ratio = window.devicePixelRatio; } else if (~ua.indexOf('msie')) { if (screen['deviceXDPI'] && screen['logicalXDPI']) { ratio = screen['deviceXDPI'] / screen['logicalXDPI']; } } else if (window.outerWidth !== undefined && window.innerWidth !== undefined) { ratio = window.outerWidth / window.innerWidth; } if (ratio) { ratio = Math.round(ratio * 100); } return ratio; }; 终端判断 var u = window.navigator.userAgent; trident: u.indexOf('Trident') > -1, // IE内核 presto: u.indexOf('Presto') > -1, // opera内核 webKit: u.indexOf('AppleWebKit') > -1, // 苹果、谷歌内核 gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, // 火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/) || !!u.match(/AppleWebKit/), // 是否为移动终端 ios: !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/), // ios终端 android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, // android终端或者uc浏览器 iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, // 是否为iPhone或者安卓QQ浏览器 iPad: u.indexOf('iPad') > -1, // 是否为iPad isTablet: /(?:iPad|PlayBook)/.test(u) || (/(?:Android)/.test(u) && !/(?:Mobile)/.test(u)) || (/(?:Firefox)/.test(u) && /(?:Tablet)/.test(u)), //是否为平板 isPc: !(/(?:iPhone)/.test(u) && !(/(?:iPad|PlayBook)/.test(u) || (/(?:Android)/.test(u) && !/(?:Mobile)/.test(u)) || (/(?:Firefox)/.test(u) && /(?:Tablet)/.test(u)))) && !/(?:Android)/.test(u), webApp: u.indexOf('Safari') == -1, // 是否为web应用程序，没有头部与底部 weixin: u.indexOf('MicroMessenger') == -1 // 是否为微信浏览器 好看的看板例子 http://www.ppchart.com/ Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 14:55:05 "},"javascript/浅拷贝与深拷贝.html":{"url":"javascript/浅拷贝与深拷贝.html","title":"浅拷贝与深拷贝","keywords":"","body":"Object.assign和JSON.parse(JSON.stringify())的区别 https://blog.csdn.net/weixin_38687522/article/details/121093720 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-03-11 10:00:51 "},"javascript/粘贴板.html":{"url":"javascript/粘贴板.html","title":"粘贴板","keywords":"","body":"从粘贴板复制图片并自定义上传 参考： https://developer.aliyun.com/article/980183 http://www.deathghost.cn/article/javascript/89 import { Component, EventEmitter, Input, OnInit, Output } from '@angular/core'; import { CommonService } from '../../services/common.service'; @Component({ selector: 'btn-clipboard-upload', template: ` 从剪贴板上传 ` }) export class BtnBoardUploadComponent implements OnInit { //正在上传 @Input() isLoading = false; /** 是否转图片 */ @Input() toFile = false; /** 解析触发事件 */ @Output() pasteChange = new EventEmitter; constructor( private commonService: CommonService ) { } ngOnInit(): void { } getFromClipboard(e) { // 浏览器安全检测 if (window.isSecureContext) { // 查找具体类型状态 window.event ? window.event.cancelBubble = true : e.stopPropagation(); let flag = false; navigator.clipboard.read().then((clipboardItems) => { const reader = new FileReader(); clipboardItems.forEach((clipboardItem: any) => { clipboardItem.types.forEach(async (type: any) => { if (type === 'image/png') { flag = true; const blob = await clipboardItem.getType(type); reader.readAsDataURL(blob); reader.onload = (event) => { const base64Str = event.target.result; this.toFile ? this.pasteChange.emit(this.dataURLtoFile(base64Str)) : base64Str; } } }); }) if (!flag) { this.commonService.notificationInfo({ type: 'info', content: '未获取到粘贴板数据' }) } }).catch((error) => { console.log(error) this.commonService.notificationInfo({ type: 'info', content: '粘贴板数据不符，请重新复制' }) }); } else { this.commonService.notificationInfo({ type: 'info', content: '您的浏览器因安全性问题，禁用了功能，请检查并使用安全性的域名' }) } } /** 将base64转换为文件 */ dataURLtoFile(base64) { var arr = base64.split(','), bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while (n--) { u8arr[n] = bstr.charCodeAt(n) } let file = { name: String(new Date().getTime() + '.png'), type: arr[0].match(/:(.*?);/)[1] }; return new File([u8arr], file.name, { type: file.type }) } } 父组件 /** 粘贴板 */ pasteChange(e: any){ console.log(e); } 浏览器安全问题，无法使用 https://developer.mozilla.org/zh-CN/docs/Web/Security/Secure_Contexts // 浏览器安全检测 if (window.isSecureContext) { ... } 其他代码实现： 可粘贴图片不能使用input、textarea等元素，使用div元素，并添加 contenteditable=true 属性即可。 /** 创建元素 */ // const dom = document.createElement('div'); // dom.setAttribute('contenteditable', 'true'); // dom.style.display = 'none'; // console.log(dom) // /** 添加监听事件 */ // dom.addEventListener('paste', (e: any) => { // const data = e.clipboardData || window['clipboardData']; // const blob = data.items[0].getAsFile(); // // 判断是不是图片，最好通过文件类型判断 // const isImg = (blob && 1) || -1; // const reader = new FileReader(); // if (isImg >= 0) { // reader.readAsDataURL(blob); // reader.onload = (event) => { // const base64Str = event.target.result; // fileList.push(base64Str); // } // } else { // if (!(e.clipboardData && e.clipboardData.items)) { // console.log('没有粘贴到内容') // return; // } // for (let i = 0, len = e.clipboardData.items.length; i { // strList.push(str); // }) // } else if (item.kind === \"file\") { // reader.readAsDataURL(item.getAsFile()); // reader.onload = (event) => { // const base64Str = event.target.result; // fileList.push(base64Str); // } // } // } // } // console.log(222) // document.body.removeChild(dom); // this.pasteChange.emit({ // strList, // fileList // }); // }) // document.body.appendChild(dom); // dom.focus(); // document.execCommand('paste'); Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-10-22 10:10:59 "},"javascript/输入框输入控制.html":{"url":"javascript/输入框输入控制.html","title":"输入框输入控制","keywords":"","body":"只能输入数字 只能输入数字且和小数点，且最大位数为2 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-05-20 09:25:08 "},"javascript/页面渲染性能优化.html":{"url":"javascript/页面渲染性能优化.html","title":"页面渲染性能优化","keywords":"","body":"渲染大量数据（列表、内容） 参考： element表格el-table组件实现虚拟滚动，解决数据量大渲染DOM过多而卡顿问题 https://blog.csdn.net/weixin_40594645/article/details/127126834 「前端进阶」高性能渲染十万条数据(时间分片) https://juejin.cn/post/6844903938894872589 解决方法： 1、时间分片 2、虚拟列表 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-03-14 19:32:48 "},"js特效/特效.html":{"url":"js特效/特效.html","title":"特效","keywords":"","body":"粒子特效 https://github.com/VincentGarreau/particles.js 鼠标点击烟花效果 雪花特效 音乐播放器 离开页面改变title var time; var normar_title=document.title; document.addEventListener('visibilitychange', function () { if (document.visibilityState == 'hidden') { clearTimeout(time); document.title = '又是分手的一天ε=ε=ε=┏(゜ロ゜;)┛'; } else { document.title = '你终于回来了(。・∀・)ノ'; time=setTimeout(function(){ document.title = normar_title; }, 3000); } }); Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-01-04 11:22:10 "},"mysql/mysql学习.html":{"url":"mysql/mysql学习.html","title":"mysql学习","keywords":"","body":"MySQL学习 数据库存储数据的特点 1.将数据放到表中，表再放到库中 2.一个数据库中可以有多个表，每个表都有一个名字，用来标识自己，表明具有唯一性 3.表具有一些特性，这些特性定义了数据在表中如何存储，类似 java 中 ”类“ 的设计 4.表由列组成，我们也成为字段。所有表都由一个或多个列组成的，每一列类似 java 的 ”属性“ 5.表中的数据是按行存储的，每一行类似于 java 的 ”对象“ 下载 https://dev.mysql.com/downloads/mysql 社区版（免费） 企业版（收费） MySQL 8.0 报错解决 参考：https://stackoverflow.com/questions/50093144/mysql-8-0-client-does-not-support-authentication-protocol-requested-by-server express mysql 登录 mysql 并分别执行以下代码： alter user 'root'@'localhost' identified with mysql_native_password by '密码'; flush privileges; 启动和停止 mysql 服务 1.右击计算机 - 管理 - 服务和应用程序 - 服务 2.打开 cmd（管理员身份） 开启：net start [mysql名称] 停止：net stop [mysql名称] 数据库连接和退出 1.连接（cmd方式） -h：主机 -P（必须大写）：端口 -u：用户名 -p 密码 方式一：mysql -h localhost -P 3306 -u root -p 密码 方式二（连本机，默认端口3306）： mysql -u root -p 密码 2.退出 方式一：exit 方式二：按 2 次 ctrl + c MySQL的常见命令 1.查看当前所有的数据库 show databases; 2.打开指定的库 use 库名 3.查看当前库的所有表 show tables; 4.查看其他库的所有表 show tables form 库名； 5.创建表 create table 表名{ 列名 列类型, 列名 列类型, ... }; 6.查看表结构 desc 表名; 7.查看服务器的版本 方式一：登录到mysql服务端 select version(); 方式二：没有登录到mysql服务端 mysql --version 或 mysql --V MySQL的语法规范 1.不区分大小写，建议关键字大写，表名、列名小写 2.每条命令最好用分号结尾 3.每条命令根据需要，可进行缩进或换行 4.注释 单行：#注释文字 单行：-- 注释文字 多行：/* 注释文字 */ DQL语言（数据查询语言） 基础查询 条件查询 排序查询 常见函数 分组函数 分组查询 链接查询 子查询 分页查询 union联合查询 DML语言（数据操作语言） 插入语句 修改语句 删除语句 DDL语言（数据定义语言） 库和表的管理 常见数据类型介绍 常见约束 TCL语言（事务控制语言） 事务和事务处理 SELECT 语法：SELECT 查询列表 FROM 表名; 特点： 1、查询列表可以是：表中的字段、常量值、表达式、函数 2、查询的结果是一个虚拟表格 起别名 1.SELECT 字段名 AS 别名 FROM 表名; 2.使用空格：SELECT 字段名 别名 FROM 表名; 去重(DISTINCT) SELECT DISTINCT 字段名 FROM 表名; 连接(CONCAT) SELECT CONCAT(str1,str2,...) AS 别名 FROM 表名; 判断(IFNULL) SELECT IFNULL(expr1,expr2) AS 别名 FROM 表名; 查看表结构 DESC 表名; 条件查询 语法： SELECT 查询列表 FROM 表名 WHERE 筛选条件; 分类： 一、按条件表达式筛选 > >= 查询第几个字符，使用 \"_\" 通配符 SELECT 查询列表 FROM 表名 WHERE 列名 LIKE '__n_l%'; 查询含有 \"_\" 字符，需转义 SELECT 查询列表 FROM 表名 WHERE 列名 LIKE '_\\_%'; 或者 SELECT 查询列表 FROM 表名 WHERE 列名 LIKE '_$_%' ESCAPE '$'; IN SELECT 查询列表 FROM 表名 WHERE 列名 IN (值1,值2,...); ISNULL、IS NOT NULL SELECT 查询列表 FROM 表名 WHERE ISNULL(列名); SELECT 查询列表 FROM 表名 WHERE 列名 IS NOT NULL; 安全等于 SELECT 列名 FROM 表名 WHERE 列名 值; 排序 语法: SELECT 查询列表 FROM 表名 [WHERE 筛选条件] ORDER BY 排序列表 [ASC|DESC], 排序列表 [ASC|DESC], ...; 特点： 1.ASC 代表升序，DESC 代表降序。不写默认升序。 2.ORDER BY 子句支持单个字段、多个字段、表达式、函数、别名。 3.ORDER BY 子句以一般是放在查询语句的最后，limit 子句除外。 函数 概念：将一组逻辑语句封装在方法体中，对外暴露方法名。 好处： 1.隐藏了实现细节 2.提高代码的重用性 调用：SELECT 函数名(参数列表) [FROM 表名]; 分类： 1.普通函数 字符函数 数学函数 日期函数 其他函数 流程控制函数 2.分组函数 功能：做统计使用，又称为统计函数、聚合函数、组函数 查看字符集： SHOW VARIABLES LIKE '%char%'; 字符函数 -- LENGTH 长度 SELECT LENGTH(str); -- UPPER 转大写 SELECT UPPER(str); -- LOWER 转小写 SELECT LOWER(str); -- CONCAT 拼接 SELECT CONCAT(str,str,...); -- SUBSTR 字符串截取 SELECT SUBSTR(str,start,[end]); -- INSTR 获取字符所在位置 SELECT INSTR(str,str); -- TRIM 去左右字符 SELECT TRIM(str); -- LPAD 左填充 SELECT LPAD(str,填充个数,填充字符); -- RPAD 右填充 SELECT RPAD(str,填充个数,填充字符); -- EPLACE 替换 SELECT EPLACE(str,需要替换的字符,替换后的字符); 数学函数 -- ROUND 四舍五入 SELECT ROUND(数值); SELECT ROUND(数值,保留位数); -- CEIL 向上取整 SELECT CEIL(数值); -- FLOOR 向下取整 SELECT FLOOR(数值); -- TRUNCATE 截断 SELECT TRUNCATE(小数,截断位数); -- MOD 取余 SELECT MOD(被除数,除数); 日期函数 %Y：年（4位） %y：年（2位） %m：月（2位）(01,02...11,12) %c：月（1位）(1,2...11,12) %d：日（2位）(01,02...) %H：小时（24小时制） %h：小时（12小时制） %i：分钟(01,02...) %s：秒(01,02...) -- 返回当前系统日期+时间 SELECT NOW(); -- CURDATE 返回当前系统日期，不包含时间 SELECT CURDATE(); -- CURTIME 返回当前时间，不包含日期 SELECT CURTIME(); -- 获取指定的部分，年月日时分秒 SELECT YEAR(NOW()) 年; SELECT YEAR('1994-9-28') 年; SELECT MONTH(NOW()) 月; -- 英文名 SELECT MONTHNAME(NOW()) 月; -- STR_TO_DATE 将日期格式的字符转换成指定的日期格式 YYYY-MM-DD SELECT STR_TO_DATE('1994-9-28','%Y-%c-%d'); SELECT STR_TO_DATE('9-28 1994','%c-%d %Y'); -- DATE_FORMAT 将日期转换成字符串 SELECT DATE_FORMAT(NOW(),'%Y年%m月%d日'); 其他函数 SELECT VERSION(); // 查看mysql版本 SELECT DATABASE(); // 查看当前数据库 SELECT USER(); // 查看当前库的用户 流程控制函数 -- IF 函数 SELECT IF(10>5,'大','小'); -- CASE 函数 /* 用法一：(类同 switch) case 要判断的字段或表达式 when 常量1 then 要显示的值1或语句1; when 常量2 then 要显示的值2或语句2; ... else 要显示的值n或语句n; end 用法二：（类同 if） case when 条件1 then 要显示的值1或语句1; when 条件2 then 要显示的值2或语句2; ... else 要显示的值n或语句n; end */ SELECT salary,department_id, CASE department_id WHEN 30 THEN salary*1.1 WHEN 40 THEN salary*1.2 WHEN 50 THEN salary*1.3 END AS 新工资 FROM employees; SELECT salary, CASE WHEN salary>20000 THEN 'A' WHEN salary>15000 THEN 'B' WHEN salary>10000 THEN 'C' ELSE 'D' END AS 工资等级 FROM employees; 分组函数 /* 功能：用作统计使用，又称为聚合函数或统计函数或组函数 分类： sum 求和、avg 平均值、max 最大值、min 最小值、count 计算个数 特点： 1、sum、avg 一般用于处理数值型 max、min、count 可以处理任何类型 2、以上文组函数都忽略 null 值 3、可以和 DISTINCT 搭配实现去重 4、count 函数单独介绍 一般使用count(*)用作统计行数 5、和分组函数一同查询的字段要求是 group by 后的字段 */ SELECT SUM(字段名) FROM 表名; SELECT AVG(字段名) FROM 表名; SELECT MIN(字段名) FROM 表名; SELECT MAX(字段名) FROM 表名; SELECT COUNT(字段名) FROM 表名; # 配合 DISTINCT 实现去重 SELECT SUM(DISTINCT 字段名) FROM 表名; SELECT COUNT(DISTINCT 字段名) FROM 表名; # count 函数的详细介绍 # 当前行任意一个属性部位null，则统计当前行，以下效果一样 SELECT COUNT(*) FROM 表名; SELECT COUNT(1) FROM 表名; SELECT COUNT(2) FROM 表名; # 效率 MYISAM 存储引擎下，COUNT(*) 的效率高 INNODB 存储引擎下，COUNT(*) 和 COUNT(1) 的效果差不多，比 COUNT(字段) 要高一些 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-05-13 15:06:17 "},"network/frp学习.html":{"url":"network/frp学习.html","title":"frp学习","keywords":"","body":"frp学习（内网穿透） 参考： https://zhuanlan.zhihu.com/p/379981320 https://blog.csdn.net/cao849861802/article/details/126091218 https://zhuanlan.zhihu.com/p/602363011 官网： https://gofrp.org/docs/ Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-02-28 20:39:53 "},"nginx/nginx学习.html":{"url":"nginx/nginx学习.html","title":"nginx学习","keywords":"","body":"Nignx 学习 参考：https://blog.csdn.net/weixin_45745641/article/details/119223601 查找nginx所在目录 whereis nginx 查找根下所有名字包含nginx的文件 find / -name nginx 删除nignx安装的相关文件 rm -rf 查找出来的路径 启动 ./nginx 或 service nginx start 重启 ./nginx -s reload 或 service nginx restart 停止 ./nginx -s stop 或 service nginx stop 下载nginx包 wget -c http://nginx.org/download/nginx-1.15.8.tar.gz 解压包 tar -zxvf nginx-1.15.8.tar.gz https服务替代 ./configure ./configure --with-http_ssl_module 编译安装 make && make install 查看nginx进程 ps aux|grep nginx Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-02-27 09:20:21 "},"node package manage/npm.html":{"url":"node package manage/npm.html","title":"npm","keywords":"","body":"npm（Node Page Manage） 参考： 如何搭建一个本地/自己服务器私有的管理npm包的仓库：https://blog.csdn.net/weixin_54000091/article/details/125369014 npm包发布到私有npm服务器过程：https://blog.csdn.net/qq_34510843/article/details/125251921 查看全局安装的依赖 npm list -g --depth 0 镜像源（查看/设置） # 查看 npm get registry # 设置 npm set registry http://registry.npmjs.org # npm源 npm set registry http://registry.npm.taobao.org # 淘宝源 查看包所有版本 npm view [包名] versions [--json] 安装pkg npm install (with no args, in package dir) npm install [/] npm install [/]@ npm install [/]@ npm install [/]@ npm install @npm: npm install npm install npm install npm install npm install / aliases: i, isntall, add common options: [--save-prod|--save-dev|--save-optional] [--save-exact] [--no-save] 卸载 npm uninstall [/][@]... [--save-prod|--save-dev|--save-optional] [--no-save] 发布 # 默认到 github npm publish # 发布到本地npm源（私有服务器） npm publish --registry [服务器地址] # npm publish --registry http://localhost:4873 # 安装私有包 npm i --S [包名] --registry [服务器地址] # npm i --S 包名 --registry http://localhost:4873 发布失败请参考：https://blog.51cto.com/kylebing/5430344 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-07-11 14:39:02 "},"node package manage/nvm.html":{"url":"node package manage/nvm.html","title":"nvm","keywords":"","body":"nvm（Node Version Manage） github releases 地址：https://github.com/coreybutler/nvm-windows/releases 注：不同版本对系统安装有影响，例如v1.1.7之后安装后会报错，提示安装路径不能含有空格等。 查看版本 # 查看本地苏所有可用版本 nvm ls # 查看node仓库所有可用版本 nvm ls available 添加/卸载指定版本 nvm install nvm uninstall 使用（切换）版本 nvm use [version] 注：npm 下的全局包区分版本，pnpm 下的全局包不区分版本 解决镜像下载过慢问题 参考：https://blog.csdn.net/qq_32754575/article/details/102412473 where nvm 找到nvm安装路径 找到settings.txt文件, 并添加以下代码 node_mirror: https://npm.taobao.org/mirrors/node/ npm_mirror: https://npm.taobao.org/mirrors/npm/ Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-08-07 11:25:20 "},"node package manage/pnpm.html":{"url":"node package manage/pnpm.html","title":"pnpm","keywords":"","body":"pnpm 官网地址：https://www.pnpm.cn/ 注：请使用@6版本，@7版本全局添加命令异常 npm install -g pnpm@6 pnpm add -g [package] 节省磁盘空间并提升安装速度 快速 比传统方案安装包的速度快了两倍，以下是官方给出的benchmarks，在多种常见情况下，执行install的速度比较。 安装 npm install -g pnpm 注：全局安装的包，在同级包管理器下是共享访问的。 升级 一旦安装完 pnpm 之后，就无需使用其它软件包管理器来更新 pnpm 了。 你可以让 pnpm 自己来更新自己，如下所示： pnpm add -g pnpm 清除缓存 pnpm store prune 兼容性 Node.js pnpm 4 pnpm 5 pnpm 6 pnpm 7 Node.js 10 ✔️ ✔️ ❌ ❌ Node.js 12 ✔️ ✔️ ✔️ ❌ Node.js 14 ✔️ ✔️ ✔️ ✔️ Node.js 16 ?️ ?️ ✔️ ✔️ Node.js 18 ?️ ?️ ✔️ ✔️ Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-07-18 15:19:54 "},"node package manage/其他.html":{"url":"node package manage/其他.html","title":"其他","keywords":"","body":"node所有版本 https://nodejs.org/dist/ npm 包版本号划分 https://juejin.cn/post/7000396951392878628 npm link https://cloud.tencent.com/developer/article/1878795 常见问题 node 18运行项目报错 问题： error:0308010C:digital envelope routines::unsupported 出现这个错误是因为 node.js V17版本中最近发布的OpenSSL3.0, 而OpenSSL3.0对允许算法和密钥大小增加了严格的限制，可能会对生态系统造成一些影响. 解决方法： linux:： export NODE_OPTIONS=--openssl-legacy-provider windows： set NODE_OPTIONS=--openssl-legacy-provider Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-06-23 17:33:30 "},"node package manage/私有仓库部署.html":{"url":"node package manage/私有仓库部署.html","title":"私有仓库部署","keywords":"","body":"私有NPM仓库-Verdaccio：https://zhuanlan.zhihu.com/p/467227029 npm 私有仓库：https://zhuanlan.zhihu.com/p/487852530 使用Verdaccio搭建私有npm仓库：https://www.jianshu.com/p/a13dd18782cf Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-06-09 17:58:47 "},"pda/broadcast广播.html":{"url":"pda/broadcast广播.html","title":"broadcast广播","keywords":"","body":"broadcast 广播 新pda //刷卡 //注册广播 IntentFilter LfDataIntentFilter = new IntentFilter(); LfDataIntentFilter.addAction(\"ACTION_BAR_LF\"); registerReceiver(mLfDataReceiver, LfDataIntentFilter); //注销广播 unregisterReceiver(mLfDataReceiver); //数据接收 private BroadcastReceiver mScanDataReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub String action = intent.getAction(); if (action.equals(\"ACTION_BAR_SCAN\")) { String str = intent.getStringExtra(\"EXTRA_SCAN_DATA\"); // str : barcode appView.loadUrl(\"javascript:Scan.ScanBar('\"+str+\"',1)\"); } } }; //扫描 //注册广播 IntentFilter scanDataIntentFilter = new IntentFilter(); scanDataIntentFilter.addAction(\"ACTION_BAR_SCAN\"); registerReceiver(mScanDataReceiver, scanDataIntentFilter); //注销广播 unregisterReceiver(mScanDataReceiver); //数据接收 private BroadcastReceiver mScanDataReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub String action = intent.getAction(); if (action.equals(\"ACTION_BAR_SCAN\")) { String str = intent.getStringExtra(\"EXTRA_SCAN_DATA\"); // str : barcode appView.loadUrl(\"javascript:Scan.ScanBar('\"+str+\"',0)\"); } } }; 高频pda //刷卡 //注册广播 IntentFilter LfDataIntentFilter = new IntentFilter(); LfDataIntentFilter.addAction(\"ACTION_BAR_LF\"); registerReceiver(mLfDataReceiver, LfDataIntentFilter); //注销广播 unregisterReceiver(mLfDataReceiver); //数据接收 private BroadcastReceiver mScanDataReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub String action = intent.getAction(); if (action.equals(\"ACTION_BAR_SCAN\")) { String str = intent.getStringExtra(\"EXTRA_SCAN_DATA\"); // str : barcode appView.loadUrl(\"javascript:Scan.ScanBar('\"+str+\"',1)\"); } } }; //扫描 //注册广播 IntentFilter scanDataIntentFilter = new IntentFilter(); scanDataIntentFilter.addAction(\"ACTION_BAR_SCAN\"); registerReceiver(mScanDataReceiver, scanDataIntentFilter); //注销广播 unregisterReceiver(mScanDataReceiver); //数据接收 private BroadcastReceiver mScanDataReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub String action = intent.getAction(); if (action.equals(\"ACTION_BAR_SCAN\")) { String str = intent.getStringExtra(\"EXTRA_SCAN_DATA\"); // str : barcode appView.loadUrl(\"javascript:Scan.ScanBar('\"+str+\"',0)\"); } } }; yfd //扫描 //注册广播 IntentFilter yfdScanDataIntentFilter = new IntentFilter(); yfdScanDataIntentFilter.addAction(\"android.intent.ACTION_DECODE_DATA\"); registerReceiver(yfdScanDataReceiver, yfdScanDataIntentFilter); //注销广播 unregisterReceiver(yfdScanDataIntentFilter); //数据接收 private BroadcastReceiver yfdScanDataReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub String action = intent.getAction(); if (action.equals(\"ACTION_BAR_SCAN\")) { String str = intent.getStringExtra(\"barcode_string\"); // str : barcode appView.loadUrl(\"javascript:Scan.ScanBar('\"+str+\"',0)\"); } } }; mianActivity中添加 import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.os.Bundle; import org.apache.cordova.*; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // enable Cordova apps to be started in the background Bundle extras = getIntent().getExtras(); if (extras != null && extras.getBoolean(\"cdvStartInBackground\", false)) { moveTaskToBack(true); } //注册按键广播接收者 IntentFilter scanDataIntentFilter = new IntentFilter(); scanDataIntentFilter.addAction(\"ACTION_BAR_SCAN\"); registerReceiver(mScanDataReceiver, scanDataIntentFilter); IntentFilter LfDataIntentFilter = new IntentFilter(); LfDataIntentFilter.addAction(\"ACTION_BAR_LF\"); registerReceiver(mLfDataReceiver, LfDataIntentFilter); IntentFilter topScanIntentFilter = new IntentFilter(); topScanIntentFilter.addAction(\"com.android.server.scannerservice.broadcast1\"); registerReceiver(topScanDataReceiver, topScanIntentFilter); IntentFilter topLfIntentFilter = new IntentFilter(); topLfIntentFilter.addAction(\"com.android.server.scannerservice.broadcast2\"); registerReceiver(topLfDataReceiver, topLfIntentFilter); IntentFilter iDataScanIntentFilter = new IntentFilter(); iDataScanIntentFilter.addAction(\"android.intent.action.SCANRESULT\"); registerReceiver(iDataScanDataReceiver, iDataScanIntentFilter); IntentFilter iDataLfIntentFilter = new IntentFilter(); iDataLfIntentFilter.addAction(\"com.idata.uhfdata\"); registerReceiver(iDataLfDataReceiver, iDataLfIntentFilter); // Set by in config.xml loadUrl(launchUrl); } /** * 广播接收器 */ private BroadcastReceiver mScanDataReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub String action = intent.getAction(); if (action.equals(\"ACTION_BAR_SCAN\")) { String str = intent.getStringExtra(\"EXTRA_SCAN_DATA\"); // str : barcode appView.loadUrl(\"javascript:Scan.ScanBar('\"+str+\"',0)\"); } } }; private BroadcastReceiver mLfDataReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub String action = intent.getAction(); if (action.equals(\"ACTION_BAR_LF\")) { String str = intent.getStringExtra(\"EXTRA_LF_DATA\"); // str : ID appView.loadUrl(\"javascript:Scan.ScanBar('\"+str+\"',1)\"); } } }; // 高频枪 private BroadcastReceiver topScanDataReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub String action = intent.getAction(); if (action.equals(\"com.android.server.scannerservice.broadcast1\")) { String str = intent.getStringExtra(\"scannerdata\"); // str : ID appView.loadUrl(\"javascript:Scan.ScanBar('\"+str+\"',0)\"); } } }; private BroadcastReceiver topLfDataReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub String action = intent.getAction(); if (action.equals(\"com.android.server.scannerservice.broadcast2\")) { String str = intent.getStringExtra(\"scannerdata\"); // str : ID appView.loadUrl(\"javascript:Scan.ScanBar('\"+str+\"',1)\"); } } }; // iData private BroadcastReceiver iDataScanDataReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub String action = intent.getAction(); if (action.equals(\"android.intent.action.SCANRESULT\")) { String str = intent.getStringExtra(\"value\"); appView.loadUrl(\"javascript:Scan.ScanBar('\"+str+\"',0)\"); } } }; private BroadcastReceiver iDataLfDataReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub String action = intent.getAction(); if (action.equals(\"com.idata.uhfdata\")) { String str = intent.getStringExtra(\"value\"); appView.loadUrl(\"javascript:Scan.ScanBar('\"+str+\"',1)\"); } } }; @Override public void onDestroy() { //注销广播 unregisterReceiver(mScanDataReceiver); unregisterReceiver(mLfDataReceiver); unregisterReceiver(topScanDataReceiver); unregisterReceiver(topLfDataReceiver); unregisterReceiver(iDataScanDataReceiver); unregisterReceiver(iDataLfDataReceiver); } 旧的广播事件及获取键： 扫码action：android.scanservice.action.UPLOAD_BARCODE_DATA 接收键名：barcode 刷卡action：android.rfid.FUN_KEY 接收键名：data Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-09-20 10:10:26 "},"python/python学习.html":{"url":"python/python学习.html","title":"python学习","keywords":"","body":"Python学习 下载地址 https://www.python.org/downloads/ pycharm下载地址(安装社区版) https://www.jetbrains.com/pycharm/ 注释 # 这是单行注释 \"\"\" 这是多行注释 \"\"\" type查看数据类型 type(123) 类型转换 int(123) float(12.3) str(123) 字符串拼接 注：python中的字符串拼接，不能直接拼接数字类型，需要转成字符类型才能拼接，或者通过 % 占位的方式拼接任意类型 占位类型3个：%s(字符) %d(整数) %f(浮点数) name = \"小明\" age = 123 msg = \"姓名：%s，年龄：%s\" % (name, age) print(msg) *** 姓名：小明，年龄：123 *** 数字精度控制 m.n *** m:控制宽度（设置宽度小于数字自身，不生效） .n:控制小数点精度（会进行小数的四舍五入） *** num1 = 11 num2 = 123.2423 print(\"num1=%1d\" % num1) print(\"num1=%4d\" % num1) print(\"num2=%6.1f\" % num2) print(\"num2=%.3f\" % num2) *** num1=11 num1= 11 num2= 123.2 num2=123.242 *** 快速格式化 f\"{占位}\" 可以是任意类型，不做精度控制，原来怎么样就是怎么样 name = \"小明\" age = 123 msg = f\"姓名：{name}，年龄：{age}\" print(msg) *** 姓名：小明，年龄：123 *** price = \"%.2f\" % ((1 * 1.2) ** 7 * 19.99) msg = f\"值为：{price}\" print(msg) *** 值为：71.63 *** input()获取键盘输入数据 content = input(f\"请输入任意内容：\") print(f\"您输入的内容是：{content}\") *** 请输入任意内容：你好 您输入的内容是：你好 *** bool布尔类型 bool1 = True bool2 = False print(f\"bool1={bool1}\") print(f\"bool2={bool2}\") print(f\"bool1={type(bool1)}\") print(f\"bool2={type(bool2)}\") *** bool1=True bool2=False bool1= bool2= *** 条件判断 *** 基本格式： if 判断的条件： 条件成立时... elif 条件成立时... else: 条件不成立时... 注： 1.条件判断末尾要加冒号 2.归属于if语句的代码块，前面需填充4个空格缩进 *** num = 85 if num > 90: print(f\"秀啊!\") elif num > 80 & num while循环 i = 1 sum = 0 while i for循环 name = \"CodeFront\" num = 0; for item in name: if item == \"o\": num += 1 print(f\"一共有{num}个‘o’\") *** 一共有2个‘o’ *** range生成序列 *** 语法： range(num)：生成0~num(不包含num)的序列 range(num1,num2)：生成num1~num2(不包含num2)的序列 range(num1,num2,step)：生成num1~num2(不包含num2)且步进为step的序列 *** for item in range(10): print(f\"{item} \", end=\"\") print() for item in range(5, 10): print(f\"{item} \", end=\"\") print() for item in range(5, 10, 2): print(f\"{item} \", end=\"\") *** 0 1 2 3 4 5 6 7 8 9 5 6 7 8 9 5 7 9 *** continue、break *** continue：结束当前循环，继续下一次循环 break：结束所有循环 *** 函数 *** def 函数名(传入参数): *** 说明文档 :params 传入参数: :return: *** 函数体 return 返回值 注：默认返回None *** def say(msg): \"\"\" say函数接收一个参数，返回说出的信息 :param msg:形参msg表示所说的内容 :return:返回值是说所的内容 \"\"\" print(f\"{msg}\") say(\"hello CodeFront\") *** hello CodeFront *** 作用域 *** 局部变量：作用域函数内部的变量 全局变量：在函数内及函数外都能使用的变量 注：局部变量通过global关键字可声明为全局变量 *** num = 100 def a(): # 通过global关键字将num声明为全局变量 global num num = 10 print(num) a() *** 10 *** 数组操作 index *** 返回元素在数组中的索引，找不到会报错 语法：数组.index(元素) *** stringList = ['a', 'b', 'c'] index = stringList.index('b') print(index) *** 1 *** insert *** 在指定的下标位置，插入指定元素 语法：数组.insert(索引,元素) *** stringList = ['a', 'b', 'c'] stringList.insert(1, 'd') print(stringList) *** ['a', 'd', 'b', 'c'] *** append *** 在数组末尾追加元素 语法：数组.append(元素) *** stringList = ['a', 'b', 'c'] stringList.append('d') print(stringList) *** ['a', 'b', 'c', 'd'] *** extend *** 在数组末尾追一批元素 语法：数组.extend(元素) *** stringList = ['a', 'b', 'c'] stringList.extend(['d', 'e', 'f']) print(stringList) *** ['a', 'b', 'c', 'd', 'e', 'f'] *** del *** 删除索引元素 语法：del 数组[索引] *** stringList = ['a', 'b', 'c'] del stringList[1] print(stringList) *** ['a', 'c'] *** pop *** 删除索引元素 语法：数组.pop(索引) *** stringList = ['a', 'b', 'c'] element = stringList.pop(2) print(f\"删除后的数据：{stringList}，获取的数据：{element}\") *** 删除后的数据：['a', 'b']，获取的数据：c *** remove *** 删除第一个出现的指定元素 语法：数组.remove(元素) *** stringList = ['a', 'b', 'c'] stringList.remove('b') print(stringList) *** ['a', 'c'] *** clear *** 删除所有元素 语法：数组.clear() *** stringList = ['a', 'b', 'c'] stringList.clear() print(stringList) *** [] *** count *** 统计元素出现的次数 语法：数组.count(元素) *** stringList = ['a', 'b', 'c', 'a', 'e'] count = stringList.count('a') print(count) *** 2 *** len *** 返回数组长度 语法：len(数组) *** stringList = ['a', 'b', 'c'] print(len(stringList)) *** 3 *** 元组 不可修改元素，但拥有数组的操作(除添加、删除) t1 = (1, 2, ['1', '2']) t2 = tuple() print(t1) print(t2) print(type(t1)) print(type(t2)) t1[2][0] = '3' t1[2][1] = '4' print(t1) *** (1, 2, ['1', '2']) () (1, 2, ['3', '4']) *** 字符串 字符串也是不可修改的元组 *** 根据索引获取字符 语法：字符串[索引] *** s = \"Hello CodeFront\" print(f\"{s[2]}\") *** l *** index *** 获取第一个出现的字符索引 语法：字符串.index(字符串) *** s = \"Hello CodeFront\" index = s.index('o') print(f\"{index}\") *** 4 *** replace *** 字符串替换 语法：字符串.replace(字符串1,字符串2) *** s = \"Hello CodeFront\" s = s.replace('F', 'f') print(f\"{s}\") *** Hello Codefront *** split *** 分割字符串 语法：字符串.split(字符串) *** s = \"Hello CodeFront\" my_list = s.split(' ') print(f\"{my_list}\") *** ['Hello', 'CodeFront'] *** strip *** 去除首尾的空格和换行符或自定字符串(不分先后顺序) 语法：字符串.strip(字符串) *** s = \"12Hello CodeFront21\" s = s.strip('12') print(f\"{s}\") *** Hello CodeFront *** count *** 统计字符串内某字符串出现次数 语法：字符串.count(字符串) *** s = \"Hello CodeFront\" count = s.count('o') print(f\"{count}\") *** 3 *** len *** 统计字符串长度 语法：len(字符串) *** s = \"Hello CodeFront\" length = len(s) print(f\"{length}\") *** 15 *** 序列 内容连续、有序、支持下标索引的一类数据容器 如：列表、元组、字符串 切片 *** 语法：序列[起始:结束:步长] 起始可以省略，省略从头开始 结束可以省略，省略到尾结束 步长可以省略，省略步长为1(可以为负数，表示倒序执行) *** a = [0, 1, 2, 3, 4, 5, 6] b = a[1:4] print(b) a = (0, 1, 2, 3, 4, 5, 6) b = a[:] print(b) a = '0123456' b = a[::2] print(b) a = '0123456' b = a[::-1] print(b) a = (0, 1, 2, 3, 4, 5, 6) b = a[::-2] print(b) a = '学Python，来黑马程序员，月薪过万' b = a[::-1] c = b[-10:4:-1] print(b) print(c) *** [1, 2, 3] (0, 1, 2, 3, 4, 5, 6) 0246 6543210 (6, 4, 2, 0) 万过薪月，员序程马黑来，nohtyP学 黑马程序员 *** Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-11-29 16:39:21 "},"shared/cdn加速.html":{"url":"shared/cdn加速.html","title":"cdn加速","keywords":"","body":"CDN加速 使用jsdelivr对资源进行加速 官网地址：https://www.jsdelivr.com/ github地址：https://github.com/jsdelivr/jsdelivr 描述： 类似谷歌托管库，jsDelivr是一个开源[CDN] 6，它允许开发人员举办自己的项目 和任何链接到我们的托管文件，在他们的网站上。 我们提供了一个稳定的CDN，可以在生产中使用，即使与大量流量的热门网站。 有没有带宽限制或高级功能和它的完全自由任何人使用。 所有类型的文件是允许的，包括JavaScript库，jQuery插件，CSS框架，字体等等。 您可以使用此回购协议，使自己的变化和提高jsDelivr的CDN的内容。 随意打开问题和拉请求，如果你觉得有什么应该改变。 该回购协议的所有更改都会同步到CDN。 这可能需要几分钟的变化出现在网站上。 根路径始终是：https://cdn.jsdelivr.net 使用 可加载npm上的任何项目 /npm/package@version/file https://cdn.jsdelivr.net/npm/package@version/file 可精准到版本号或者范围内的版本 /npm/jquery@3.1.0/dist/jquery.min.js /npm/jquery@3/dist/jquery.min.js /npm/jquery@3.1/dist/jquery.min.js https://cdn.jsdelivr.net/npm/jquery@3.1.0/dist/jquery.min.js https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js https://cdn.jsdelivr.net/npm/jquery@3.1/dist/jquery.min.js 加载github资源 加载任何GitHub发布、提交或分支 /gh/user/repo@version/file https://cdn.jsdelivr.net/gh/user/repo@version/file 可精准到版本号或者范围内的版本 /gh/jquery/jquery@3.1.0/dist/jquery.min.js /gh/jquery/jquery@32b00373b3f42e5cdcb709df53f3b08b7184a944/dist/jquery.min.js https://cdn.jsdelivr.net/gh/jquery/jquery@3.1.0/dist/jquery.min.js https://cdn.jsdelivr.net/gh/jquery/jquery@32b00373b3f42e5cdcb709df53f3b08b7184a944/dist/jquery.min.js Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 16:05:31 "},"shared/Excel导入模板.html":{"url":"shared/Excel导入模板.html","title":"Excel导入模板","keywords":"","body":"Excel导入组件 针对不同模块使用不同的Excel模板导入问题进行组件重构，只需传入指定的Excel模板名称即可。 组件名 excel-tmpl 用法 默认返回 { isCover: boolean, // 是否覆盖 dataList: any[] // 导入后的数组 } 使用服务方式调用 确认导入处理 表格配置 在 excel-tmpl\\excel-tmpl-data.ts 中使用最新表格配置，需指定模板名称 添加各模块自定义模板 例如当前模块需要对数据进行特殊处理等 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 16:40:43 "},"shared/git与svn.html":{"url":"shared/git与svn.html","title":"git与svn","keywords":"","body":"Git分享 Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 Git 与 SVN 区别 Git 不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等。 如果你是一个具有使用 SVN 背景的人，你需要做一定的思想转换，来适应 Git 提供的一些概念和特征。 Git 与 SVN 区别点： 1、Git 是分布式的，SVN 不是：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。 2、Git 把内容按元数据方式存储，而 SVN 是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。 3、Git 分支和 SVN 的分支不同：分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。 4、Git 没有一个全局的版本号，而 SVN 有：目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。 5、Git 的内容完整性要优于 SVN：Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 git init git add / git add . git pull git fetch + git merge git fetch git status git commit -m git push --set-upstream origin 远程分支名：创建远程不存在的分支 commitID 只需要前7位即可锁定 版本 git log 显示所有提交过的版本信息 git reflog 可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作） git remote add git push -u origin master git clone git reset --hard --hard：不保存所有变更 --soft：保留变更且变更内容处于 Staged --mixed（默认）：保留变更且变更内容处于 Modified git merge git branch git checkout -b git checkout -b origin ：拉取远程仓库 子分支 commit 记录会继承过来 分支改动与其他分支不再有关系 git rebase 类似于merge，会将2个分支的 commit 记录重写排列 git rebase --continue：解决冲突后，继续下一个节点的 rebase 文件的四种状态： 初始：Untracked 添加：Staged 绿色 文件一致/提交：Unmodified 修改：Modified 红色 用 alias 简写命令 git的config文件中： [alias] ad = add . cmm = commit -m rlg = reflog Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 16:09:47 "},"shared/handsontable.html":{"url":"shared/handsontable.html","title":"handsontable","keywords":"","body":"HandsonTable 表格 官网地址：https://handsontable.com/ what? Handsontable (pronounced \"hands-on-table\") is a JavaScript data grid component that brings the well-known look and feel of spreadsheets to your application. Thousands of business apps depend on Handsontable for entering, editing, validating, and cleansing data that comes from remote sources such as databases and APIs, or from HTML documents, Excel files, Google Sheets, and manual input. 译文： Handontable（发音为“hands-on-table”）是一个JavaScript数据网格组件，它为您的应用程序带来了众所周知的电子表格外观。 成千上万的商业应用程序依赖Handontable来输入、编辑、验证和清理来自数据库和API等远程源或HTML文档、Excel文件、Google Sheets和手动输入的数据。 demo JavaScript demo(opens new window) React demo(opens new window) Angular demo(opens new window) Vue 2 demo(opens new window) TypeScript demo 流行功能 Cell types Formula calculations Column filter Column groups Column summary Row parent-child Context menu 自定义网格 Create a custom renderer Create a custom editor Create a custom validator Create a custom plugin Translate the UI 安装 npm install handsontable @handsontable/angular 导入样式 @import '~handsontable/dist/handsontable.full.css'; 注意：样式文件中含有大量的@charset，而@charset只能在文件头第一行声明，否则会报错。解决方法拷贝样式文件放至assets文件夹下，删除所有@charset，并在文件第一行添加@charset，使用 进行导入即可。 使用 import { HttpClient } from '@angular/common/http'; import { Component, ElementRef, ViewChild } from '@angular/core'; import { HotTableComponent, HotTableModule } from '@handsontable/angular'; import Handsontable from 'handsontable'; import { zhCN } from 'handsontable/i18n'; @Component({ selector: 'app-home', standalone: true, imports: [HotTableModule], templateUrl: './home.component.html', styleUrl: './home.component.scss' }) export class HomeComponent { @ViewChild('hotTable', { static: false }) hotTable!: HotTableComponent; count = 0; hotSettings: Handsontable.GridSettings = { data: [], colHeaders: [], rowHeaders: true, height: 800, rowHeights: 50, // 行高 colWidths: 100, // 列宽 wordWrap: false, // 是否换行 persistentState: true, // 保存操作状态 manualColumnResize: true, // 是否表头修改列宽 manualColumnMove: true, contextMenu: true, columnSorting: true, // 列排序 licenseKey: \"non-commercial-and-evaluation\" } constructor( public http: HttpClient, public el: ElementRef ) { } ngAfterViewInit() { this.getData(); } getData() { const url = '/assets/mock/data.json' this.http.get(url).subscribe((res: any) => { if (Number(res.code) === 1) { const list = res.data; this.count = res.count || 0; if (list.length > 0) { // 需要使用new Handsontable进行初始化,再进行更新 Handsontable.languages.registerLanguageDictionary(zhCN); const hotTable = this.el.nativeElement.querySelector('#hotTable'); const plugin = new Handsontable(hotTable, this.hotSettings); plugin.updateSettings(this.hotSettings); this.hotTable.updateHotTable({ data: list, colHeaders: Object.keys(list[0]), }); } console.log(res) } else { console.log('接口异常') } }, () => { console.log('网络异常'); }) } } 效果 gif效果图 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 16:09:38 "},"shared/IM即时通信.html":{"url":"shared/IM即时通信.html","title":"IM即时通信","keywords":"","body":"IM即时通讯（Instant Messenger） 概念：是一款跨平台（Linux Server，Windows Server），可定制的 P2P 即时通信系统（集成多人视频会议功能），为各行业门户网站和企事业单位提供“一站式”定制解决方案。 功能描述 客户端能随时主动发送数据给服务端。 当客户端关注的内容在发生改变时，服务器能够实时地通知客户端。类比于传统的C/S请求模型，“实时通信”时客户端不需要主观地发送请求去获取自己关心的内容，而是由服务器端进行“推送”。 注意：上面的“推送”二字打了引号，实际上现有的几种技术实现方式中，并不是服务器端真正主动地推送，而是通过一定的手段营造了一种“实时通信”的假象。 常用方式 客户端轮询：传统意义上的短轮询（Short Polling） 服务器端轮询：长轮询（Long Polling） 单向服务器推送：Server-Sent Events（SSE） 全双工通信：WebSocket 短轮询（Short Polling） 客户端向服务器端发送一个请求，服务器返回数据，然后客户端根据服务器端返回的数据进行处理； 客户端继续向服务器端发送请求，继续重复以上的步骤，如果不想给服务器端太大的压力，一般情况下会设置一个请求的时间间隔。 使用场景：客户端通过定时器在规定时间内获取服务端的数据。如扫码。 优点：不需要额外的开发成本，请求数据，解析数据，作出响应，仅此而已，然后不断重复。 缺点：轮询的时间间隔不好控制。如果要求的实时性比较高，显然使用短轮询会有明显的短板，如果设置interval的间隔过长，会导致消息延迟，而如果太短，会对服务器产生压力。 长轮询（Long Polling） 客户端发送一个请求，服务器会hold住这个请求； 直到监听的内容有改变，才会返回数据，断开连接（或者在一定的时间内，请求还得不到返回，就会因为超时自动断开连接）; 客户端继续发送请求，重复以上步骤。 【实时通讯】轮询与长轮询_哔哩哔哩_bilibili 使用场景：弹幕、心跳包等 优点：新数据来了，连接断开后会释放客户端与服务器端的连接数，并产生新的连接。 缺点：阻塞服务器请求，依旧占用资源；如果客户端有新数据发送，但服务端没有再规定时间内返回，会导致响应失败。 Server-Sent Events（SSE） EventSource - Web API 接口参考 | MDN (mozilla.org) Server-Sent是HTML5提出一个标准。由客户端发起与服务器之间创建TCP连接，然后并维持这个连接，直到客户端或服务器中的任何一方断开，ServerSent使用的是\"问\"+\"答\"的机制，连接创建后浏览器会周期性地发送消息至服务器询问，是否有自己的消息。 SSE的本质其实就是一个HTTP的长连接，只不过它给客户端发送的不是一次性的数据包，而是一个stream流，格式为text/event-stream。所以客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。 兼容性：不兼容IE，其他现代浏览器基本都兼容 \"Server-Sent-Events\" | Can I use... Support tables for HTML5, CSS3, etc 使用场景：处理社交媒体状态更新，新闻提要或将数据传递到客户端存储机制（如 IndexedDB 或 Web 存储） 特点：客户端只需连接一次，Server就定时推送，除非其中一端断开连接。并且SSE会在连接意外断开时自动重连。 缺点：并没有达到最新消息服务器端的实时推送。 WebSocket 概念：WebSocket是一种网络通信协议，是HTML5新增的特性，实现了基于浏览器的远程socket，使浏览器和服务器可以进行全双工通信，大部分浏览器都对此做了支持。 与HTTP对比 不同点： HTTP的协议标识符是http，WebSocket的是ws； HTTP请求只能由客户端发起，服务器无法主动向客户端推送消息，而WebSocket可以； HTTP请求有同源限制，不同源之间通信需要跨域，而WebSocket没有同源限制。 相同点： 都是应用层的通信协议； 默认端口一样，都是80或443； 都可以用于浏览器和服务器间的通信； 都基于TCP协议。 兼容性：IE10以下不支持，现代浏览器基本都支持 WebSocket API | Can I use... Support tables for HTML5, CSS3, etc 使用场景：社交聊天、弹幕、多玩家游戏、协同编辑、股票基金实时报价、体育实况更新、视频会议/聊天、基于位置的应用、在线教育、智能家居等 特点： 可双向通信，设计的目的主要是为了减少传统轮询时http连接数量的开销； 建立在TCP协议之上，握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器； 与HTTP兼容性良好，同样可以使用80和443端口； 没有同源限制，客户端可以与任意服务器通信； 可以发送文本，也可以发送二进制数据； 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL. SSE与Websocket对比 1）SSE 使用 HTTP 协议，现有的服务器软件都支持。WebSocket 是一个独立协议。 2）SSE 属于轻量级，使用简单；WebSocket 协议相对复杂。 3）SSE 默认支持断线重连，WebSocket 需要自己实现。 4）SSE 一般只用来传送文本，二进制数据需要编码后传送，WebSocket 默认支持传送二进制数据。 5）SSE 支持自定义发送的消息类型。 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 16:25:42 "},"shared/ng-alain.html":{"url":"shared/ng-alain.html","title":"ng-alain","keywords":"","body":"NG-ALAIN 官网地址：https://ng-alain.com/zh 介绍 环境搭建、安装、运行 体系架构 核心模块描述 项目结构 常用命令 基本使用 介绍 NG-ALAIN 是一个企业级中后台前端/设计解决方案脚手架，秉承 Ant Design 的设计价值观，目标是希望在Angular上面开发企业后台更简单、更快速。随着『设计者』的不断反馈，将持续迭代，逐步沉淀和总结出更多设计模式和相应的代码实现，阐述中后台产品模板/组件/业务场景的最佳实践。 环境搭建、安装、运行 安装并使用 node LTS 版 全局安装 ng 脚手架 npm install -g @angular/cli 创建 ng 项目 并 安装 ng-alain 脚手架 ng new my-project --style less --routing ng add ng-alain 运行 ng serve 或 npm run start 版本升级 https://ng-alain.com/docs/upgrade-v11/zh 体系架构 类库 描述 @delon/theme 主题系统除了包含 NG-ALAIN 基础框架及所需样式（包含CSS工具集，一套类似Bootstrap）以外，还包含一些通用的数据渲染（Pipe）、服务工具类（页面标题、滚动条等）的集合，这些是日常必不可少的一些组成 @delon/abc 脚手架内提供了一套默认业务组件，这些组件抽象了控制台业务中的一些常见区块。我们将持续维护和迭代这些组件，为中后台业务提供比 Ant Design 基础组件更高级别的抽象 @delon/chart 基于 G2 的基础上二次封装，提供了业务中常用的图表套件，可以单独使用，也可以组合起来实现复杂的展示效果 @delon/form 基于 JSON Schema 标准的动态构建表单 @delon/auth 用户认证模块，用于解决如何获取、存取、使用这三个步骤的用户认证环节 @delon/acl 访问控制列表，是一种非常简单的基于角色权限控制，甚至达到控制某个按钮显隐的粒度 @delon/cache 将字典、城市数据等缓存至内存或持久化当中，有效减少 Http 请求 @delon/mock Mock 会拦截 Angular Http 请求并返回测试数据，当后端未完成接口时 Mock 技术是一项不会影响前端开发进度的工具 @delon/util 包含数组、延迟、字符串、日期、校验等常见工具集 @delon/testing 常用测试套件 CLI Schematics 快速生成统一的模板、可插拔的插件等 项目结构 ├── _mock # Mock 数据规则目录 ├── angular.json # Angular 项目配置文件 ├── src │ ├── app │ │ ├── core # 核心模块 │ │ │ ├── i18n │ │ │ ├── net │ │ │ │ └── default.interceptor.ts # 默认HTTP拦截器 │ │ │ ├── services │ │ │ │ └── startup.service.ts # 初始化项目配置 │ │ │ └── core.module.ts # 核心模块文件 │ │ ├── layout # 通用布局 │ │ ├── routes │ │ │ ├── ** # 业务目录 │ │ │ ├── routes.module.ts # 业务路由模块 │ │ │ └── routes-routing.module.ts # 业务路由注册口 │ │ ├── shared # 共享模块 │ │ │ ├── shared-delon.module.ts # @Delon/* 次级共享模块导入 │ │ │ ├── shared-zorro.module.ts # NG-ZORRO 次级共享模块导入 │ │ │ └── shared.module.ts # 共享模块文件 │ │ ├── app.component.ts # 根组件 │ │ └── app.module.ts # 根模块 │ │ └── global-config.module.ts # @delon & ng-zorro 全局配置项 │ ├── assets # 本地静态资源 │ ├── environments # 环境变量配置 │ ├── styles # 样式目录 └── └── style.less # 样式引导入口 补充 图表：Antv(G2 G6 F2 L7等) 项目脚手架跟随 Angular 及 NG-ZORRO 同步更新 常用指令 ng g ng-alain:module 模块名 ng g ng-alain:list 列表名 -m 模块名 ng g ng-alain:view 详情名 -m 模块名 -t 文件夹名称 补充 https://ng-alain.com/cli/plugin/zh 相关配置可到 angular.json 中配置 基本使用 @delon main.ts -> appModule -> 加载所有模块、组件、服务、指令等 appModule：通过 StartupService 服务，启动项目，Promise.resolve() 异步渲染视图，设置/存储处理项目基本信息 MenuService： 菜单服务，处理菜单列表 titleService：项目标题服务 ACLService：权限服务 ITokenService：token服务，token处理（设置） SettingsService：系统设置服务，含项目登录信息、项目密钥信息等 _HttpClient：alain 封装的网络请求服务，含 token 校验等 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 16:25:22 "},"shared/pdf预览、文本获取及处理.html":{"url":"shared/pdf预览、文本获取及处理.html","title":"pdf预览、文本获取及处理","keywords":"","body":"PDF预览、文本获取及处理 github：GitHub - mozilla/pdf.js: PDF Reader in JavaScript cdn地址：https://cdnjs.com/libraries/pdf.js 参考：https://qa.1r1g.com/sf/ask/2844518561/ 注：pdf文件必须存放在服务器上，不能获取file://协议文件，会提示跨域。预览文件须以https开头的安全域名。 预览 pdf文件：Git Tutorial (gjtool.cn) github的pdf-viewer：https://mozilla.github.io/pdf.js/web/viewer.html) 使用： pdf路径使用 encodeURIComponent 进行编码。encodeURIComponent('https://www.gjtool.cn/pdfh5/git.pdf') 最终效果：https://mozilla.github.io/pdf.js/web/viewer.html?file=https%3A%2F%2Fwww.gjtool.cn%2Fpdfh5%2Fgit.pdf) 文本获取 const pdfUrl = 'https://www.gjtool.cn/pdfh5/git.pdf'; function getText(pdfUrl) { var loadingTask = pdfjsLib.getDocument(pdfUrl); return loadingTask.promise.then((pdf) => { // 获取页数 const pageNum = pdf._pdfInfo.numPages; const countPromises = []; for (let index = 1; index { // 获取文本 const data = res.getTextContent(); return data.then((text) => { return text.items.map((item, i) => { return item.str; }).join(``); }); })); } console.log(countPromises); return Promise.all(countPromises).then((res) => { return res.join(''); }); }); } getText(pdfUrl).then((res) => { console.log(res); }, (err) => { console.log(err); }); 数据提取及处理 需处理的文件： 处理方法： import { HttpClient } from '@angular/common/http'; import { Injectable, Injector } from '@angular/core'; import { NzModalService } from 'ng-zorro-antd/modal'; import { GlobalWorkerOptions, getDocument } from 'pdfjs-dist'; import { PdfTmplListModalComponent } from '../components/pdf/pdf-tmpl-list-modal/pdf-tmpl-list-modal.component'; import { CommonService } from './common.service'; export interface PdfOption { title?: string, privige?: { }, type: 'PDF'; pdfTmplList?: { desction: string; fileCount: number; fileList: string[]; function: string, id: number; name: string; isUsed: boolean; [key: string]: any; }[], reflesh?: boolean } // pdf服务 @Injectable({ providedIn: 'root' }) export class PdfService { sectionSplitTag = ''; // 区域分割标识 contentSectionsplitTag = ''; // 内容分块分隔表示 contentSplitTag = '|'; // 内容分割标识 pageSplitTag = ''; // 页面分割标识 constructor( private nzModalService: NzModalService, private http: HttpClient, private injector: Injector ) { } /** 获取模板数据 */ getPdf() { return new Promise((resolve, reject) => { this.http.get(`assets/pdf/pdf.json?t=${Date.now()}`).subscribe((res: object) => { resolve(res); }); }); } /** 导入列表 */ getPdfImportList(params: object) { return this.injector.get(CommonService).httpGet({ url: '/PdfImport/getPdfImportList', params }); } /** 添加PDF数据 */ addPdfImport(fd: FormData) { return this.injector.get(CommonService).httpPost({ url: '/PdfImport/addPdfImport', fd }); } /** 编辑PDF导入数据 */ editPdfImportList(fd: FormData) { return this.injector.get(CommonService).httpPost({ url: '/PdfImport/editPdfImportList', fd }); } /** 上传文件 */ uploadFiles(fd: FormData) { return this.injector.get(CommonService).httpPost({ url: '/base/uploadFiles', fd }); } /** pdf模态框 */ pdfModal(obj?: PdfOption) { const modal = this.nzModalService.create({ nzContent: PdfTmplListModalComponent, nzComponentParams: { obj, type: obj ? obj.type : 'PDF' }, nzWidth: '1600px', nzFooter: null, nzCentered: true, nzMaskClosable: false, nzClosable: false }); return modal; } /** 获取pdf文本信息 */ getText(obj: { pdfUrl: string, sectionList?: string[], // 区域标识文字 }) { // 必须设定work工作区，否则会报错 GlobalWorkerOptions.workerSrc = 'https://cdn.bootcdn.net/ajax/libs/pdf.js/2.14.305/pdf.worker.min.js'; var loadingTask = getDocument(obj.pdfUrl); return loadingTask.promise.then((pdf) => { const pageNum = pdf._pdfInfo.numPages; const countPromises = []; for (let index = 1; index { const data = res.getTextContent(); return data.then((text) => { // console.log(text); const reg = /(^\\s+)|(\\s+$)|\\s+/g; return text.items .filter((item: any) => item.str !== '') .map((item: any) => { const str = item.str; if ((obj.sectionList || []).some((i) => i.startsWith(str))) { // 区域标识 return `${this.sectionSplitTag}${str}[${item.transform[4]},${item.transform[5]},${item.width}]${this.contentSectionsplitTag}`; } else { // 内容标识 if (str.trim() !== '') { // 内容不为空添加标识 return `${str}[${item.transform[4]},${item.transform[5]},${item.width}]${this.contentSplitTag}`; } else { return str; } } }).join(''); }); })); } return Promise.all(countPromises).then((res) => { return res.join(this.pageSplitTag); // 页面分割标识 }); }).catch((error) => { // 解析失败 throw new Error(error); }); } /** 删除前后分隔符 */ delLRSplit(obj: { str: string }) { if (obj.str.startsWith(this.contentSplitTag)) { obj.str = obj.str.substring(1, obj.str.length); } if (obj.str.endsWith(this.contentSplitTag)) { obj.str = obj.str.substring(0, obj.str.length - 1); } return obj.str; } /** 删除所有分隔符 */ delAllSplit(obj: { str: string }) { if (this.sectionSplitTag) { obj.str = obj.str.replaceAll(this.sectionSplitTag, this.contentSplitTag); } if (this.contentSectionsplitTag) { obj.str = obj.str.replaceAll(this.contentSectionsplitTag, this.contentSplitTag); } if (this.pageSplitTag) { obj.str = obj.str.replaceAll(this.pageSplitTag, this.contentSplitTag); } return obj.str; } /** 清除坐标 */ clearPosition(obj: { str: string }) { return obj.str.replaceAll(/\\[.*?\\]/g, ''); } /** 格式化回数组坐标 */ positionReset(obj: { str: string }) { obj.str = this.delAllSplit({ str: obj.str }); let list = this.delLRSplit({ str: obj.str }) .split(this.contentSplitTag) .filter((item) => item !== '') .map((item, i) => { let width = 0; let p = item.match(/\\[.*?\\]/g); let position = [-1, -1]; if (p) { position = JSON.parse(p[0]); width = JSON.parse(p[0]) && JSON.parse(p[0]).length > 2 ? JSON.parse(p[0])[2] : 0; } const index = item.indexOf('['); if (index > -1) { obj.str = item.substring(0, index); } return { str: obj.str, position, width } }); return list; } /** 清除页头 */ clearPageHeader(obj: { str: string, reg: RegExp | string, replaceText?: string }) { obj.str = obj.str.replaceAll(obj.reg, obj.replaceText || ''); return obj.str; } /** 清除页脚 */ clearPageFooter(obj: { str: string, reg: RegExp | string, replaceText?: string }) { obj.str = obj.str.replaceAll(obj.reg, obj.replaceText || ''); return obj.str; } /** 坐标重排(降序) */ // positionSort(obj: { str: string }) { // // 清除所有标记 // obj.str = obj.str.replaceAll(this.sectionSplitTag, this.contentSplitTag); // obj.str = obj.str.replaceAll(this.contentSectionsplitTag, this.contentSplitTag); // let list = this.positionReset({ str: obj.str }); // // console.log(JSON.parse(JSON.stringify(list // // .sort((a, b) => { // // return b.position[1] - a.position[1]; // // })))); // list = list.sort((a, b) => { // return b.position[1] - a.position[1]; // }) // .sort((a, b) => { // return a.position[0] - b.position[0]; // }) // return obj.str; // } /** 根据坐标范围查找具体数据 */ findInPosition(obj: { str: string, xStartPosition: number, xEndPosition: number, yStartPosition: number, yEndPosition: number }) { let list = this.positionReset({ str: obj.str }); list = list.filter((item) => item.position[0] >= obj.xStartPosition && item.position[0] = obj.yStartPosition && item.position[1] { if (index === 0) { result.push(item); } else { // 相邻数组长度大于2才需要分开，否则会被拼接在一起 if (list.length > 2 && Math.abs(list[index].position[0] - result[result.length - 1].position[0]) 0 ? obj.xSiblingDiff : 5)) { result[result.length - 1].str = result[result.length - 1].str + list[index].str; } else { result.push(item); } } }); return result.map((item) => { return { ...item, str: item.str.trim() } }); } /** 有序表格数据处理（属性在表头）ySiblingDiff：垂直差值，默认为5 */ olTableHandle(obj: { str: string, col: number, xSiblingDiff?: number, ySiblingDiff?: number }) { const result = this.xSiblingHandle({ str: obj.str, xSiblingDiff: obj.xSiblingDiff }); const list = []; // 初始化表格数据 let row = 0; let position = 0; result.forEach((item, index) => { if (index >= obj.col) { if (index === obj.col) { position = item.position[1]; row = 1; } if (item.position[1] !== -1 && Math.abs(item.position[1] - position) > (obj.ySiblingDiff && obj.ySiblingDiff > 0 ? obj.ySiblingDiff : 5)) { position = item.position[1]; row += 1; } } else { list[row] = list[row] ? list[row] : []; list[row].push(item); } }); // 组装表格数据 for (let index = 1; index { list[index] = list[index] ? list[index] : []; list[index].push({ str: '', position: [-1, -1], width: 0 }); }) } row = 0; result.forEach((item, index) => { if (index >= obj.col) { if (index === obj.col) { position = item.position[1]; row = 1; } if (item.position[1] !== -1 && Math.abs(item.position[1] - position) > (obj.ySiblingDiff && obj.ySiblingDiff > 0 ? obj.ySiblingDiff : 5)) { position = item.position[1]; row += 1; } // 初始算法 // const i = list[0].findIndex((item2) => Math.abs(item2.position[0] - item.position[0]) 0 ? obj.ySiblingDiff : 5)); // if (i > -1) { // list[row][i] = item; // } // 算法升级，取区间内的数据进行拼接，不适用于表头属性文字居中或表头分组，因为区间范围无法计算 const spaceList = list[0].map((item2) => item2.position[0]); spaceList.forEach((item2, index2) => { if (index2 !== (spaceList.length - 1) && spaceList[index2] item.position[0] || index2 === (spaceList.length - 1) && spaceList[index2] [item2.position[0], item2.position[0] + item2.position[2]]); // console.log(spaceList1, spaceList2); // spaceList2.forEach((item2, index2) => { // let start = [Math.min(...spaceList1), Math.min(...item2)]; //区间的两个最小值 // let end = [Math.max(...spaceList1), Math.max(...item2)]; //区间的两个最大值 // if (Math.max(...start) { return item.map((item2) => { return item2.str; }) }); } /** 无序表格数据处理（属性在左侧） */ ulTableHandle(obj: { str: string }) { const list = []; let row = -1; obj.str.split(this.contentSplitTag).forEach((item, index) => { if (index % 2 === 0 && item.trim()) { row += 1; list[row] = list[row] ? list[row] : []; } if (index % 2 === 0 && item.trim() || index % 2 === 1 && list[row].length > 0) { list[row].push(this.clearPosition({ str: item }).trim()); } }) return list; } /** 有序列表数据处理 */ olListHandle(obj: { str: string, keyList: string[] }) { const list = []; let row = -1; obj.str.split(this.contentSplitTag).forEach((item, index) => { if (index % obj.keyList.length === 0) { row += 1; } list[row] = list[row] ? list[row] : []; list[row].push(this.clearPosition({ str: item }).trim()); }) return list; } /** oncekeyList 只寻找首次出现的section作为标题 */ sectionHandle(obj: { list: string[], oncekeyList: string[] }) { obj.oncekeyList.forEach((item) => { const arr = obj.list.filter((item2) => item2.startsWith(item)); if (arr.length > 1) { arr.shift(); arr.forEach((item2) => { const index3 = obj.list.findIndex((item3) => item3 === item2); if (index3 > -1) { obj.list[index3] = obj.list[index3].replace(this.contentSectionsplitTag, this.contentSplitTag); // 处理非section后面第一个分割符 obj.list[index3 - 1] = obj.list[index3 - 1] + obj.list[index3]; obj.list.splice(index3, 1); } }); } }); return obj.list; } } 最终数据处理 import { Injectable, Injector } from '@angular/core'; import moment from 'moment'; import { PdfService } from 'src/app/shared/services/pdf.service'; @Injectable({ providedIn: 'root' }) export class HmService { orderNoCollectList = []; productNoCollectList = []; productName = ''; // 产品名称 seasonCollectList = []; // 采购单季节 optionCollectList = []; // 信息表的option分组 noOfPieces = ''; // 每卡支数 miscellaneousStr = ''; // 包材信息 compositionCollectList = []; // 信息表的成分 colorNameCollectList = []; // 颜色名称信息 invoiceAveragePriceCollectList = []; // 平均单价、走货方式 termsDeliveryCollectList = []; // 走货方式详情 colorCollectList = []; // 三维表对应的颜色组 colorTableCollectList = []; // 三维表（颜色、走货方式、数量） timeDeliveryCollectList = []; sizePerColourBreakdownResultList = []; // SizePerColourBreakdown的结果集（Article No、H&M Colour Code、Option No、Quantity） constructor( private injector: Injector ) { } get pdfService() { return this.injector.get(PdfService); } /** Supplementary Product Information.PDF */ handle1(res: string) { res = this.pdfService.clearPageHeader({ str: res, reg: /HLW\\s\\S+-\\S+\\s\\S+\\s\\S+\\s-\\s\\d+-\\d+.*?\\]\\|{0,1}/g }); res = this.pdfService.clearPageFooter({ str: res, reg: /(Created).*?(?=Page)/g }); res = this.pdfService.clearPageFooter({ str: res, reg: /(Page).*?\\]\\|{0,1}/g }); res = res.split(this.pdfService.pageSplitTag).join(this.pdfService.contentSplitTag); // Order NO const orderNoResultList = this.pdfService.findInPosition({ str: res, xStartPosition: 220, xEndPosition: 230, yStartPosition: 530, yEndPosition: 540, }); const orderNoValue = orderNoResultList.length > 0 ? orderNoResultList[0].str.trim() : ''; this.orderNoCollectList.push(orderNoValue); console.log(orderNoValue); // Product No const productNoResultList = this.pdfService.findInPosition({ str: res, xStartPosition: 625, xEndPosition: 635, yStartPosition: 535, yEndPosition: 545, }); const productNoValue = productNoResultList.length > 0 ? productNoResultList[0].str.trim() : ''; this.productNoCollectList.push(productNoValue); console.log(productNoValue); // Product Name const productNameResultList = this.pdfService.findInPosition({ str: res, xStartPosition: 625, xEndPosition: 635, yStartPosition: 520, yEndPosition: 530, }); const productNameValue = productNameResultList.length > 0 ? productNameResultList[0].str.trim() : ''; console.log(productNameValue); this.productName = productNameValue; // Option const optionResultList = (res.match(new RegExp('(? { return this.pdfService.clearPosition({ str: item.replaceAll(this.pdfService.contentSplitTag, '') }).trim(); }); console.log(optionResultList); this.optionCollectList = optionResultList; // Composition const compositionList = (res.match(new RegExp('(? { const tableList = this.pdfService.olTableHandle({ str: item, col: 13 }); if (tableList.length > 0) { const i = tableList[0].findIndex((item2) => item2.indexOf('Composition') > -1); tableList.shift(); return i > -1 ? tableList.map((item2) => item2[i]) : []; } else { return []; } }); console.log(compositionList); this.compositionCollectList = compositionList; // Colour Name const colorNameTableRegList = (res.match(new RegExp(`((? { let list = item.split(this.pdfService.contentSplitTag); list.splice(0, 1); return this.pdfService.delLRSplit({ str: list.join(this.pdfService.contentSplitTag) }); }); let colorNameList = []; colorNameTableRegList.forEach((item) => { let list = this.pdfService.olTableHandle({ str: item, col: 11 }); list.splice(0, 1); colorNameList = colorNameList.concat(list); }); console.log(colorNameList); this.colorNameCollectList = colorNameList; // Miscellaneous const miscellaneousRegList = (res.match(new RegExp('(? 0 ? this.pdfService.olTableHandle({ str: miscellaneousRegList[0], col: 6 }) : []; miscellaneousList.length > 0 && miscellaneousList.shift(); const miscellaneous = miscellaneousList.map((item) => { return item[0]; }).join(','); console.log(miscellaneous); this.miscellaneousStr = miscellaneous; } /** PurchaseOrder.PDF */ handle2(res: string) { // Order NO let orderNoValue = ''; const orderNoResultList = this.pdfService.findInPosition({ str: res, xStartPosition: 95, xEndPosition: 105, yStartPosition: 755, yEndPosition: 765, }); if ([...new Set(orderNoResultList.map((item) => item.str))].length !== 1) { throw new Error('Order NO不一致'); return; } else { orderNoValue = orderNoResultList.length > 0 ? orderNoResultList[0].str : ''; } this.orderNoCollectList.push(orderNoValue); console.log(orderNoValue); // Product No let productNoValue = ''; const productNoResultList = this.pdfService.findInPosition({ str: res, xStartPosition: 335, xEndPosition: 345, yStartPosition: 755, yEndPosition: 765, }); if ([...new Set(productNoResultList.map((item) => item.str))].length !== 1) { throw new Error('Product No不一致'); return; } else { productNoValue = productNoResultList.length > 0 ? productNoResultList[0].str : ''; } this.productNoCollectList.push(productNoValue); console.log(productNoValue); // Season const seasonResultList = this.pdfService.findInPosition({ str: res, xStartPosition: 335, xEndPosition: 345, yStartPosition: 715, yEndPosition: 725, }).map((item) => (item.str)); console.log(seasonResultList); this.seasonCollectList = seasonResultList; // No of Pieces const noOfPiecesResultList = this.pdfService.findInPosition({ str: res, xStartPosition: 335, xEndPosition: 345, yStartPosition: 640, yEndPosition: 650, }).map((item) => (item.str.trim())); console.log(noOfPiecesResultList); this.noOfPieces = noOfPiecesResultList.length > 0 ? noOfPiecesResultList[0] : ''; // Terms of Delivery const termsDeliveryResultList = (res.match(new RegExp('(? { return this.pdfService.delLRSplit({ str: this.pdfService.clearPosition({ str: item }) }).split(this.pdfService.contentSplitTag); }); console.log(termsDeliveryResultList); this.termsDeliveryCollectList = termsDeliveryResultList.length > 0 ? termsDeliveryResultList[0] : []; // Time of Delivery let timeDeliveryResultList = []; const timeDeliveryRegList = (res.match(new RegExp('Time of Delivery((?!Terms of Delivery).)*', 'g')) || []); if (timeDeliveryRegList.length > 0) { timeDeliveryResultList = this.pdfService.olTableHandle({ str: timeDeliveryRegList[0], col: 4 }); timeDeliveryResultList.pop(); } this.timeDeliveryCollectList = timeDeliveryResultList; console.log(timeDeliveryResultList); // Invoice Average Price const invoiceAveragePriceResultList = (res.match(new RegExp('Invoice Average Price((?!By accepting and performing under this Order).)*', 'g')) || []) .map((item) => { return this.pdfService.olTableHandle({ str: item, col: 2 }); }); console.log(invoiceAveragePriceResultList); this.invoiceAveragePriceCollectList = invoiceAveragePriceResultList; } /** SizePerColourBreakdown.PDF */ handle3(res: string) { res = this.pdfService.clearPageHeader({ str: res, reg: /(Page).*?(?=Created)/g, replaceText: this.pdfService.sectionSplitTag }); res = this.pdfService.clearPageFooter({ str: res, reg: /(Created).*?(?=Telephone)/g, replaceText: this.pdfService.sectionSplitTag }); // Order NO let orderNoValue = ''; const orderNoResultList = this.pdfService.findInPosition({ str: res, xStartPosition: 95, xEndPosition: 105, yStartPosition: 760, yEndPosition: 770, }); if ([...new Set(orderNoResultList.map((item) => item.str))].length !== 1) { throw new Error('Order NO不一致'); return; } else { orderNoValue = orderNoResultList.length > 0 ? orderNoResultList[0].str : ''; } this.orderNoCollectList.push(orderNoValue); console.log(orderNoValue); // Product No let productNoValue = ''; const productNoResultList = this.pdfService.findInPosition({ str: res, xStartPosition: 320, xEndPosition: 330, yStartPosition: 760, yEndPosition: 770, }); if ([...new Set(productNoResultList.map((item) => item.str))].length !== 1) { throw new Error('Product No不一致'); return; } else { productNoValue = productNoResultList.length > 0 ? productNoResultList[0].str : ''; } this.productNoCollectList.push(productNoValue); console.log(productNoValue); // Colour / Country Breakdown const colorCountryBreakdownRegList = res.match(/^((?!Colour \\/ Country Breakdown).)*/g) || []; const colorCountryBreakRegStr = colorCountryBreakdownRegList.length > 0 ? colorCountryBreakdownRegList[0] : ''; const colorTableRegList = colorCountryBreakRegStr.match(/(?=Article:).*(?=Total)/g) || []; const colorTableRegStr = colorTableRegList.length > 0 ? colorTableRegList[0] : ''; const colorRegList = colorTableRegStr.match(/(? { return this.pdfService.clearPosition({ str: item }) .split(this.pdfService.contentSplitTag) .map((item2) => item2.trim()); }); console.log(colorList) this.colorCollectList = colorList; // 表格内容数据 const colorRegList2 = colorTableRegStr.match(/Article:(.*?\\|)(.*?\\|)/g) || []; let tableStr = colorTableRegStr; colorRegList2.forEach((item) => { tableStr = tableStr.replace(item, ''); }); const tableList = this.pdfService.olTableHandle({ str: this.pdfService.delLRSplit({ str: tableStr }), col: 3 + colorList.length }); console.log(tableList); this.colorTableCollectList = tableList; } /** TotalCountryBreakdown.PDF */ handle4(res: string) { res = this.pdfService.clearPageHeader({ str: res, reg: /(Page).*?(?=Created)/g, replaceText: this.pdfService.sectionSplitTag }); res = this.pdfService.clearPageFooter({ str: res, reg: /(Created).*?(?=Telephone)/g, replaceText: this.pdfService.sectionSplitTag }); const pageList = res.split(this.pdfService.pageSplitTag); // Order NO let orderNoValue = ''; const orderNoResultList = this.pdfService.findInPosition({ str: res, xStartPosition: 95, xEndPosition: 105, yStartPosition: 760, yEndPosition: 770, }); if ([...new Set(orderNoResultList.map((item) => item.str))].length !== 1) { throw new Error('Order NO不一致'); return; } else { orderNoValue = orderNoResultList.length > 0 ? orderNoResultList[0].str : ''; } this.orderNoCollectList.push(orderNoValue); console.log(orderNoValue); // Product No let productNoValue = ''; const productNoResultList = this.pdfService.findInPosition({ str: res, xStartPosition: 320, xEndPosition: 330, yStartPosition: 760, yEndPosition: 770, }); if ([...new Set(productNoResultList.map((item) => item.str))].length !== 1) { throw new Error('Product No不一致'); return; } else { productNoValue = productNoResultList.length > 0 ? productNoResultList[0].str : ''; } this.productNoCollectList.push(productNoValue); console.log(productNoValue); const countryReg = `(? { const country = item.match(new RegExp(countryReg)) && item.match(new RegExp(countryReg))[0] || ''; const articleNo = item.match(new RegExp(articleNoReg)) && item.match(new RegExp(articleNoReg))[0] || ''; const HMColourCode = item.match(new RegExp(HMColourCodeReg)) && item.match(new RegExp(HMColourCodeReg))[0] || ''; const optionNo = item.match(new RegExp(optionNoReg)) && item.match(new RegExp(optionNoReg))[0] || ''; const quantity = item.match(new RegExp(quantityReg)) && item.match(new RegExp(quantityReg))[0] || ''; const list = []; if (country) { list.push(this.pdfService.clearPosition({ str: country })); } if (articleNo) { list.push( this.pdfService.clearPosition({ str: articleNo }) .split(this.pdfService.contentSplitTag) .map((item2) => (item2.trim())) ); } else { list.push([]) } if (HMColourCode) { list.push( this.pdfService.clearPosition({ str: HMColourCode }) .split(this.pdfService.contentSplitTag) .map((item2) => (item2.trim())) ); } else { list.push([]) } if (optionNo) { list.push( this.pdfService.clearPosition({ str: optionNo }) .split(this.pdfService.contentSplitTag) .map((item2) => (item2.trim())) ); } else { list.push([]) } if (quantity) { list.push( this.pdfService.clearPosition({ str: quantity }) .split(this.pdfService.contentSplitTag) .map((item2) => (item2.trim())) ); } else { list.push([]) } resultList.push(list); }); this.sizePerColourBreakdownResultList = resultList; console.log(resultList); } mergeHandle(obj: { pdfUrl1: string, sectionList1?: string[], pdfUrl2: string, sectionList2?: string[], pdfUrl3: string, sectionList3?: string[], pdfUrl4: string, sectionList4?: string[] }) { return Promise.all([ // this.pdfService.getText({ pdfUrl: 'http://localhost:4200/assets/pdf/hm/Supplementary Product Information.pdf', sectionList: obj.sectionList1 }), // this.pdfService.getText({ pdfUrl: 'http://localhost:4200/assets/pdf/hm/PurchaseOrder.PDF', sectionList: obj.sectionList2 }), // this.pdfService.getText({ pdfUrl: 'http://localhost:4200/assets/pdf/hm/TotalCountryBreakdown.PDF', sectionList: obj.sectionList3 }), // this.pdfService.getText({ pdfUrl: 'http://localhost:4200/assets/pdf/hm/SizePerColourBreakdown.PDF', sectionList: obj.sectionList4 }) this.pdfService.getText({ pdfUrl: obj.pdfUrl1, sectionList: obj.sectionList1 }), this.pdfService.getText({ pdfUrl: obj.pdfUrl2, sectionList: obj.sectionList2 }), this.pdfService.getText({ pdfUrl: obj.pdfUrl3, sectionList: obj.sectionList3 }), this.pdfService.getText({ pdfUrl: obj.pdfUrl4, sectionList: obj.sectionList4 }) ]).then((res) => { // 数据处理及校验 res.forEach((item, index) => { switch (index + 1) { case 1: this.handle1(item); break; case 2: this.handle2(item); break; case 3: this.handle3(item); break; case 4: this.handle4(item); break; } console.log('----------------------------'); }) let orderNo = ''; let productNo = ''; let orderNoList = [...new Set(this.orderNoCollectList)]; let productNoList = [...new Set(this.productNoCollectList)]; if (orderNoList.length !== 1) { throw new Error('Order No不一致'); } orderNo = orderNoList[0]; if (productNoList.length !== 1) { throw new Error('Product No不一致'); } productNo = productNoList[0]; console.log('数据组装------------------'); const colorList = this.colorCollectList.map((item) => { return { colorNo: item.length > 1 ? item[1] : '' } }) let resultList = []; this.sizePerColourBreakdownResultList.forEach((item1, index1) => { if (item1[0]) { item1[1].forEach((item2, index2) => { const planningMarkets = item1[0].match(/(? item3.length > 3 && item3[1] === item1[2][index2]); // 数量匹配 const country = planningMarkets.match(/(? (item3[1])).findIndex((item3) => item3.indexOf(country) > -1); const colorIndex = colorList.findIndex((item3) => item3.colorNo === item1[2][index2]); // 走货方式详情 const countryShort = planningMarkets.match(/.+(?=\\s\\()/g) ? planningMarkets.match(/.+(?=\\s\\()/g)[0] : ''; const trimsOfDelivery = this.termsDeliveryCollectList.filter((item3, index3) => index3 % 2 === 0).join(','); resultList.push({ SoId: '', MatId: '', orderNo, // 客户订单号 productNo, // 客户产品编号 productName: this.productName, // 产品名称 season: '', // 季节 colorNo: item1[2][index2], // 颜色编号 colorName: colorNameIndex > -1 ? this.colorNameCollectList[colorNameIndex][2] : '', // 颜色名称 optionNo: item1[3][index2], // 分组号 composition: '', // 成分 price: '', // 单价 costType: '', // 币种 invoiceAveragePrice: '', // 平均单价 timeDelivery: '', // 交期 planningMarkets: planningMarkets ? planningMarkets.replace(/\\s+\\(.*?\\)/g, '') : '', // 走货国家 noOfPieces: this.noOfPieces, // 每卡支数 termsOfDelivery: trimsOfDelivery.indexOf(countryShort) > -1 ? this.termsDeliveryCollectList.join(' ') : '', // 走货方式 qty: countryIndex > -1 && colorIndex > -1 ? this.colorTableCollectList[countryIndex][3 + colorIndex] : '', // 走货数量 quantity: item1[4][index2], // 入袋数 labelCode: this.miscellaneousStr // 包材信息 }); }); } }) this.timeDeliveryCollectList.shift(); resultList = resultList.map((item) => { // 获取分组索引 const i = this.optionCollectList.findIndex((item2) => item2.startsWith(item.optionNo)); let season = ''; let composition = ''; let price = ''; let costType = ''; let invoiceAveragePrice = this.invoiceAveragePriceCollectList.length > 0 && this.invoiceAveragePriceCollectList[0].length > 0 && this.invoiceAveragePriceCollectList[0][1].length > 0 ? this.invoiceAveragePriceCollectList[0][1][0] : ''; let timeDelivery = ''; if (i > -1 && this.seasonCollectList.length >= i) { season = this.seasonCollectList[i] || ''; } if (i > -1 && this.compositionCollectList.length >= i) { composition = this.compositionCollectList[i].length > 0 ? this.compositionCollectList[i][0] : '' } if (invoiceAveragePrice) { price = invoiceAveragePrice.match(/.+(?=\\s)/g) ? invoiceAveragePrice.match(/.+(?=\\s)/g)[0] : ''; costType = invoiceAveragePrice.match(/(? { const i = this.timeDeliveryCollectList.map((item2) => (item2[1])).findIndex((item2) => item.planningMarkets.match(/(? -1 : false); item.timeDelivery = i > -1 ? this.timeDeliveryCollectList[i][0] : ''; return { ...item, timeDelivery: moment(new Date(item.timeDelivery)).subtract('3', 'days').format('YYYY/MM/DD') }; }); console.log(resultList); return Promise.resolve(resultList); }).catch((error) => { // 上传失败 // throw new Error(error); console.log(error); }); } } Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 16:25:08 "},"shared/PicGo与github图床.html":{"url":"shared/PicGo与github图床.html","title":"PicGo与github图床","keywords":"","body":"PicGo与github图床 参考： http://michael007js.cn/news/shownews.php?id=346 所谓图床，就是存储图片的服务器 我们写在线文档的时候，如果我们把图片仅仅存放在本地，那么别人来去访问这个文档的时候，图片就看不到了。 那么，为了避免这样一种情况，使得别人在访问我的文档的时候，图片不会丢失，那么我就需要将我的图片存放到别人也可以访问的服务器上。通常，我们就称这样的服务器为图床。 PicGO图床工具 PicGo是一个用于快速上传图片并获取图片 URL 链接的工具 下载页面：https://github.com/Molunerfinn/picgo/releases 下载地址：https://github.com/Molunerfinn/ github创建新仓库并设置为public 生成令牌 选择永久性期限 安装github-plus插件 配置插件 cdn地址格式：https://cdn.jsdelivr.net/gh/ +你的账户名+你的仓库名@你的分支名 根据个人偏好进行设置 这里只设置为：https://cdn.jsdelivr.net/gh/MrCodeFront/assets typora配置PicGo Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 15:48:48 "},"shared/PicGo与SMMS图床.html":{"url":"shared/PicGo与SMMS图床.html","title":"PicGo与SMMS图床","keywords":"","body":"PicGo与SMMS图床 常见图床及图床工具： 图床：Postimage、ImgURL、SM.MS、路过图床、upload.cc等 图床工具：PicGo、Mpic、ShareX、fu、quicker PicGO图床工具 PicGo是一个用于快速上传图片并获取图片 URL 链接的工具 下载页面：https://github.com/Molunerfinn/picgo/releases 下载地址：https://github.com/Molunerfinn/ smms图床 官网：https://smms.app/ API文档：https://doc.sm.ms/ typora配置PicGo Gitee图床 https://zhuanlan.zhihu.com/p/567668223 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 16:09:06 "},"shared/PM2.html":{"url":"shared/PM2.html","title":"PM2","keywords":"","body":"PM2 流程管理器 官网地址：https://pm2.keymetrics.io/ github地址：https://github.com/Unitech/pm2 概述 PM2是Node.js应用程序的生产流程管理器，具有内置的负载均衡器。它允许您永远保持应用程序的活力，在不停机的情况下重新加载应用程序，并促进常见的系统管理任务。 安装 npm install pm2@latest -g yarn global add pm2 启动 pm2 start app.js 管理 pm2 restart pm2 reload pm2 stop pm2 delete 查看状态 pm2 [list|ls|status] 查看日志 pm2 logs pm2 logs --lines 200 监视日志、自定义指标和应用程序信息 pm2 monit Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-23 12:19:10 "},"shared/webcomponent及angular的变化检测机制.html":{"url":"shared/webcomponent及angular的变化检测机制.html","title":"webcomponent及angular的变化检测机制","keywords":"","body":"webcomponent 、angular的变化检测机制 webcomponent（网页组件） 参考文档： https://developer.mozilla.org/en-US/docs/Web/Web_Components Web Components 入门实例教程 - 阮一峰的网络日志 (ruanyifeng.com) 1.概念 Web Components 是一套不同的技术，允许您创建可重用的自定义元素——它们的功能被封装在你的代码的其余部分之外——并在你的 Web 应用程序中使用它们。 Web Components旨在解决这些问题 — 它由三项主要技术组成，它们可以一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。 Custom elements（自定义元素）：一组JavaScript API，允许您定义custom elements及其行为，然后可以在您的用户界面中按照需要使用它们。 Shadow DOM（影子DOM）：一组JavaScript API，用于将封装的“影子”DOM树附加到元素（与主文档DOM分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。 HTML templates（HTML模板）： 和 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用 实现web component的基本方法通常如下所示： 创建一个类或函数来指定web组件的功能，如果使用类，请使用 ECMAScript 2015 的类语法(参阅类获取更多信息)。 使用 CustomElementRegistry.define() 方法注册您的新自定义元素 ，并向其传递要定义的元素名称、指定元素功能的类、以及可选的其所继承自的元素。 如果需要的话，使用Element.attachShadow() 方法将一个shadow DOM附加到自定义元素上。使用通常的DOM方法向shadow DOM中添加子元素、事件监听器等等。 如果需要的话，使用 定义一个HTML模板。再次使用常规DOM方法克隆模板并将其附加到您的shadow DOM中。 在页面任何您喜欢的位置使用自定义元素，就像使用常规HTML元素那样。 2.元素注册器 CustomElementRegistry：CustomElementRegistry接口提供注册自定义元素和查询已注册元素的方法。要获取它的实例，请使用 window.customElements属性。 3.语法 customElements.define(name, constructor, options); 4.生命周期回调 定义在自定义元素的类定义中的特殊回调函数，影响其行为： connectedCallback: 当自定义元素第一次被连接到文档DOM时被调用。 disconnectedCallback: 当自定义元素与文档DOM断开连接时被调用。 adoptedCallback: 当自定义元素被移动到新文档时被调用。 attributeChangedCallback: 当自定义元素的一个属性被增加、移除或更改时被调用。 5.Shadow DOM Web components 的一个重要属性是封装——可以将标记结构、样式和行为隐藏起来，并与页面上的其他代码相隔离，保证不同的部分不会混在一起，可使代码更加干净、整洁。其中，Shadow DOM 接口是关键所在，它可以将一个隐藏的、独立的 DOM 附加到一个元素上。 ShadowRoot 表示shadow DOM子树的根节点。 Element extensions 与shadow DOM有关的Element 接口的扩展: Element.attachShadow() 方法将shadow DOM树附加给特定元素。 Element.shadowRoot 属性返回附加给特定元素的shadow root，或者 null 如果没有shadow root被附加。 Node 相关拓展 与 shadow DOM 相关的 Node 接口的拓展: Node.getRootNode() 方法返回上下文对象的根，可以选择包含shadow root，如果可用的话。 Node.isConnected 属性返回一个布尔值表示节点是否连接（直接或间接）到上下文对象。例如，在普通DOM的情况下为Document 对象，或者在shadow DOM的情况下为 ShadowRoot Event 拓展 与shadow DOM相关的Event 接口的扩展： Event.composed: 返回 Boolean 它表明事件是否会通过shadow DOM边界传播到标准DOM。 返回事件的路径（侦听器将被调用的对象）。如果shadow root是使用ShadowRoot.mode为closed创建的，则不包括shadow树中的节点。 6.HTML templates 包含一个HTML片段，不会在文档初始化时渲染。但是可以在运行时使用JavaScript显示。主要用作自定义元素结构的基础。关联的DOM接口是HTMLTemplateElement。 HTML 内容模板（）元素是一种用于保存客户端内容机制，该内容在加载页面时不会呈现，但随后可以 (原文为 may be) 在运行时使用 JavaScript 实例化。 web component中的一个占位符，你可以填充自己的标记，这样你就可以创建单独的DOM树并将它们呈现在一起。关联的DOM接口是HTMLSlotElement。 HTML 元素 ，作为 Web Components 技术套件的一部分，是Web 组件内的一个占位符。该占位符可以在后期使用自己的标记语言填充，这样您就可以创建单独的 DOM 树，并将它与其它的组件组合在一起。 7.示例 class ElementA extends HTMLElement { constructor() { // 必须首先调用 super 方法 super(); // 元素的功能代码写在这里 // ... } /** 生命周期 */ connectedCallback() { // 自定义元素首次插入文档dom时调用 // 相较于constructor只会执行一次，这个生命周期每次将节点连接到dom时都会调用 // 可能会执行多次(比如同一个自定义元素remove, append多次) } disconnectedCallback() { // 自定义元素从文档中删除时，调用 } adoptedCallback() { // 自定义元素移动到新的文档 // 比如使用 adoptNode 方法在多iframe下移动元素 } attributeChangedCallback(name, oldVal, newVal) { // 属性变更时调用：三个参数对应属性名，旧值，新值 } } customElements.define(name, ElementA); 8.实战 class CodeFront extends HTMLElement { constructor() { super(); const shadow = this.attachShadow({ mode: 'open' }); const span = document.createElement('span'); span.setAttribute('class', 'code-front-text'); setTimeout(() => { span.textContent = this.getAttribute('text') || '默认内容'; }, 10); const style = document.createElement('style'); style.textContent = ` .code-front-text { font-family: 微软雅黑; font-weight: 400; font-size: 80px; margin: 0 auto; color: rgba(255, 255, 255, 0.1); background: #ed8080; background: linear-gradient(to right, #ed8080 0%, #2a77d6 16%, #5eb524 32%, #eacd25 48%, #ed8080 64%, #2a77d6 80%, #5eb524 100%); filter: progid: DXImageTransform.Microsoft.gradient(startColorstr='#ed8080', endColorstr='#5eb524', GradientType=1); background-size: 300% 300%; -webkit-background-clip: text; background-clip: text; animation: shimmer infinite 3s linear; -webkit-animation: shimmer infinite 3s linear; background-repeat: no-repeat; background-position: top left; background-color: #222; } @keyframes shimmer { 0% { background-position: top left; } 100% { background-position: top right; } } `; shadow.appendChild(style); shadow.appendChild(span); } } // Define the new element customElements.define('code-front', CodeFront); // class CodeFront extends HTMLElement { // constructor() { // // Always call super first in constructor // super(); // // Create a shadow root // // open：shadow root元素可以从js外部访问根节点 // // closed：拒绝从js外部访问关闭的shadow root节点 // const shadow = this.attachShadow({ // mode: 'open' // }); // // Create div // const wrapper = document.createElement('div'); // wrapper.setAttribute('class', 'wrapper'); // // Create input // const input = document.createElement('input'); // // Define Attribute // const placeholder = this.getAttribute('placeholder'); // input.placeholder = placeholder || '暂无提示'; // // Create some CSS to apply to the shadow dom // const style = document.createElement('style'); // style.textContent = ` // .wrapper{ // display: inline-block; // } // `; // wrapper.appendChild(input); // shadow.appendChild(style); // shadow.appendChild(wrapper); // } // } // // Define the new element // customElements.define('code-front', CodeFront); angular的变化检测机制 参考： https://blog.csdn.net/zyxzp2012/article/details/90208489 什么是变更检测 变更检测的基本任务是获得程序的内部状态并使之在用户界面可见。这个状态可以是任意的数据类型。 引起变更原因 异步（Event、xhr、定时器）操作改变了程序的状态，导致视图的更新。 Angular 内的处理 Angular 有着自己的zone，称为NgZone。Angular源码的某个地方，有一个东西叫做ApplicationRef，它监听NgZones的onTurnDone事件。只要这个事件发生了，它就执行tick()函数，这个函数执行变更检测 // 真实源码的非常简化版本。 class ApplicationRef { changeDetectorRefs:ChangeDetectorRef[] = []; constructor(private zone: NgZone) { this.zone.onTurnDone.subscribe(() => this.zone.run(() => this.tick()); } tick() { this.changeDetectorRefs .forEach((ref) => ref.detectChanges()); } } 变更检测 在 Angular 中，每个组件都有它自己的 change detector (变更检测器) ChangeDetectorRef Angular 各种视图的基础类，提供变更检测功能。 变更检测树会收集要检查的所有视图。 使用这些方法从树中添加或移除视图、初始化变更检测并显式地把这些视图标记为脏的，意思是它们变了、需要重新渲染。 OnPush 的两种状态：https://angular.cn/api/core/ChangeDetectionStrategy 主要方法： abstract markForCheck(): void abstract detach(): void abstract detectChanges(): void abstract checkNoChanges(): void abstract reattach(): void 变更监听值变化及自定义变更： ngOnChanges：检测监听值的变更 ngDoCheck：检测和处理 Angular 自己没有捕捉到的变化，可自定义变更检测逻辑 组件注入 ChangeDetectorRef，并调用 markForCheck 方法，会告诉Angular，标记整条路径，从这个组件到根组件都需要被checked，一旦变更检测结束，它就会恢复为整棵树恢复OnPush状态 示例 app.conponent.ts import { ChangeDetectionStrategy, Component } from '@angular/core'; @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'], changeDetection: ChangeDetectionStrategy.OnPush }) export class AppComponent { text = ''; constructor() { } ngOnInit(): void { } } app.conponent.html app-child.ts import { ChangeDetectionStrategy, Component, EventEmitter, Input, OnInit, Output, SimpleChanges } from '@angular/core'; @Component({ selector: 'app-child', templateUrl: './child.component.html', styleUrls: ['./child.component.scss'], changeDetection: ChangeDetectionStrategy.OnPush }) export class ChildComponent implements OnInit { @Input() text = ''; @Output() textChange = new EventEmitter(); obj = { currentValue: '', previousValue: '' } constructor() { } ngOnInit(): void { } ngOnChanges(changes: SimpleChanges): void { console.log(changes); this.obj.currentValue = changes['text'].currentValue; this.obj.previousValue = changes['text'].previousValue; } change() { this.textChange.emit(this.text); } } app-child.html currentValue： previousValue： Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 16:09:20 "},"shared/内嵌视图与宿主视图.html":{"url":"shared/内嵌视图与宿主视图.html","title":"内嵌视图与宿主视图","keywords":"","body":"内嵌视图与宿主视图 内嵌视图 - 连接到模板的嵌入视图，在组件模板元素中添加模板(DOM元素、DOM元素组) 宿主视图 - 连接到组件的嵌入视图，在组件元素中添加别的组件 ElementRef - 单个HTML元素；用于获取DOM元素； TemplateRef - 一组HTML元素；可以用来创建ViewRef类型的视图(TemplateRef元素实例.createEmbeddedView(null)，也可以作为TemplateRef对象插入到ViewContainerRef实例中； ViewContainerRef - 视图容器，任何DOM元素都可以作为视图容器使用; 它可以用来创建和管理内嵌视图； 内嵌视图： 我是容器 我是模板 好无聊~ 卷起来！！！ export class MainComponent implements AfterViewInit { constructor() { } @ViewChild('container', { read: ViewContainerRef }) container: ViewContainerRef; @ViewChild('tmpl', { static: false }) temp: TemplateRef; ngAfterViewInit() { // 创建内嵌视图 - 以下任意一种方法都可以,insert方法需要一个ViewRef类型的视图 this.container.insert(this.temp.createEmbeddedView(null)); // 添加内嵌视图 // this.container.createEmbeddedView(this.temp); // 创建内嵌视图 } } 宿主视图： // 组件切换链接 home list detail // 动态组件容器 import { Component, ComponentFactoryResolver, OnInit, Type, ViewChild, ViewContainerRef } from '@angular/core'; import { DetailComponent } from 'src/app/detail/detail.component'; import { HomeComponent } from 'src/app/home/home.component'; import { ListComponent } from 'src/app/list/list.component'; @Component({ selector: 'app-main', templateUrl: './main.component.html', styleUrls: ['./main.component.scss'] }) export class MainComponent implements OnInit { @ViewChild('container', { read: ViewContainerRef }) container: ViewContainerRef; data = { 'home': HomeComponent, 'list': ListComponent, 'detail': DetailComponent }; constructor( private componentFactoryResolver: ComponentFactoryResolver ) { } ngOnInit(): void { } ngAfterViewInit(): void { this.loadComponent(this.data.home); } loadComponent(compoennt: Type) { const com = this.componentFactoryResolver.resolveComponentFactory(compoennt); this.container.clear(); this.container.createComponent(com); } load(name: string) { this.loadComponent(this.data[name]); } } ng13开始，废弃 ComponentFactoryResolver https://angular.cn/api/core/ComponentFactoryResolver https://angular.cn/api/core/ViewContainerRef @Directive({ … }) export class MyDirective { constructor( private viewContainerRef: ViewContainerRef, private componentFactoryResolver: ComponentFactoryResolver ) {} createMyComponent() { const componentFactory = this.componentFactoryResolver.resolveComponentFactory(MyComponent); this.viewContainerRef.createComponent(componentFactory); } } @Directive({ … }) export class MyDirective { constructor(private viewContainerRef: ViewContainerRef) {} createMyComponent() { this.viewContainerRef.createComponent(MyComponent); } } Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 16:10:00 "},"shared/技术选型及代码规范.html":{"url":"shared/技术选型及代码规范.html","title":"技术选型及代码规范","keywords":"","body":"概述 本期演讲内容包含: 技术选型 项目架构及框架对比 模块化分析 Less 与 Scss 相关技术演示 技术选型 前端三剑客：Angular、Vue、React UI库(或框架)：ng-zorro-antd、ng-zorro-mobile、IONIC、Boopstrap 5.0.0-alpha1等 UI(或代码)规范：antd规范、网易代码规范 中后台解决方案：ng-alain、antd-vue-pro 项目管理：git、svn 接口规范：RESTful API规范、swagger 附：ng-zorro-antd 官方群：320404326 ng-alain 官方群：316911865 前端在线调试工具：https://stackblitz.com/ git 简易视频教程：https://www.bilibili.com/video/BV1BE411g7SV 什么是Swagger？ Swagger 是一个规范且完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。 Swagger 的目标是对 REST API 定义一个标准且和语言无关的接口，可以让人和计算机拥有无须访问源码、文档或网络流量监测就可以发现和理解服务的能力。当通过 Swagger 进行正确定义，用户可以理解远程服务并使用最少实现逻辑与远程服务进行交互。与为底层编程所实现的接口类似，Swagger 消除了调用服务时可能会有的猜测。 Swagger 有什么优势？ 支持 API 自动生成同步的在线文档：使用 Swagger 后可以直接通过代码生成文档，不再需要自己手动编写接口文档了，对程序员来说非常方便，可以节约写文档的时间去学习新技术。 提供 Web 页面在线测试 API：光有文档还不够，Swagger 生成的文档还支持在线测试。参数和格式都定好了，直接在界面上输入参数对应的值即可在线测试接口。 项目架构及框架对比 目前：PC端 使用：angular+ng-zorro-antd 移动端 使用：angular+IONIC 静态单页面可使用：bootstrap 针对不同的业务需求，选择相应的技术栈。 附：静态项目可使用CDN加速链接：https://www.bootcdn.cn/ 模块化分析 模块化分为 CMD、AMD、CommonJs AMD 是RequireJS在推广过程中对模块定义的规范化产出，通过define()函数定义，第一个参数是一个数组，里面定义一些需要依赖的包，第二个参数是一个回调函数，代表：RequireJS CMD 是SeaJS在推广过程中对模块定义的规范化产出，是一个同步模块定义，是SeaJS的一个标准，SeaJS是CMD概念的一个实现，SeaJS是淘宝团队提供的一个模块开发的js框架，代表：SeaJS CommonJS 是通过module.exports定义的，在前端浏览器里面并不支持module.exports，通过node.js后端使用的。Nodejs端是使用CommonJS规范的，前端浏览器一般使用AMD、CMD、ES6等定义模块化开发，写法有：module export 和 exports.xx(参数)两种， 代表：CommonJS 模块化及组件化 模块化（按功能） -> 汽车组装 = 车架+车门+车轮+发动机等 组件化（按最小元部件）-> 车轮 = 橡胶轮胎+轮轴+轮架子等 Less 与 Scss Less中文官网：http://lesscss.cn/ 简述： Sass和Less都属于Css预处理器，Css预处理器定义了一种新的语言，其基本思想是用一种专门的编程语言，为Css增加一些编程的特性，将Css作为目标生成文件，然后开发者使用这种语言进行Css编码工作(用一种专门的编程语言，进行Web网页样式设计，再通过编译器转化为正常的Css文件，以供项目使用)。写法大体相同。 其中Scss分2种：1.Sass：格式严谨，写法类同python。2.Scss：可与普通写法嵌套 共同点： 混合(Mixins):将一个定义好的classA引入到另一个classB中，从而简单实现classB继承了classA的所有属性； 参数混合(Parametric):可以像函数一样传递参数的class 嵌套规则：class中嵌套class,从而减少重复的代码 运算：css中的数学计算 颜色功能：可以编辑你的颜色 命名空间：样式分组，从而方便被调用 作用域：局部修改样式 JavaScript表达式：在css样式中使用javaScript表达式赋值 附：css、less、scss相互转换工具：http://koala-app.com/ Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 16:10:11 "},"shared/模块化 AMD、CommonJS、ES6.html":{"url":"shared/模块化 AMD、CommonJS、ES6.html","title":"模块化 AMD、CommonJS、ES6","keywords":"","body":"前端模块化发展历史 (CommonJS、AMD、CMD、UMD、ES6) 参考： https://zhuanlan.zhihu.com/p/337946057 https://blog.51cto.com/lengyuexin/4960989** https://juejin.cn/post/6844903927104667662** https://zhuanlan.zhihu.com/p/55407719 https://www.cnblogs.com/dolphinX/p/4381855.html https://juejin.cn/post/6844903848511799303 视频： https://www.bilibili.com/video/BV18s411E7Tj/?spm_id_from=333.337.search-card.all.click&vd_source=1390a41caddc0c842b1b8449237f0024 模块化起源 JavaScript发展之初，只是为了解决基础的表单验证问题，以及基础的页面交互，代码非常简单，不存在模块化的概念和问题。但是随着ajax的发展，web进入2.0时代，JavaScript成为一门应用非常广泛的语言。 这个时候js作为一门嵌入型语言，劣势就展示出来了，没有一个权威的规范，问题总是要解决，在前端发展的这几十年，也就顺势而为的产生了很多的js规范。 模块化规范是什么 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起，完成指定工作。 能做什么 能帮助我们更好的管理各个js文件，处理不同模块间的依赖关系。 早期模块化三种方式： 1.函数 在最早的js中，想要实现分模块开发，最简单的就是函数，因为函数能形成一个相对封闭的空间，通过函数来实现简单的模块化也是最早的解决方案 function model1 = { } function model2 = { } 缺点 1、污染全局作用域 2、维护成本高（命名容易冲突） 3、依赖关系不明显 2.对象 对象里面可以包含属性和方法，就相当于一个容器了，我们可以把每个模块的代码写到一个对象里面，从而实现模块化的目的 var model1 = { age: 11, say() { console.log(age) } } var model2 = { age: 15, say() { console.log(age) } } 缺点 外部可以修改模块内部状态，可以随意修改每个模块的某个属性，有相当的安全隐患 3.自执行函数 IIFE(immediately invoked function expression)，也就是我们说的自执行函数，通过定义一个匿名函数，创建了一个“私有”的命名空间，该命名空间的变量和方法，不会破坏全局的命名空间 var module = (function(){ 　　var age = 11 var say = function(){ console.log(age) } return {say}; })(); module.say(); //11 console.log(module.age) //undefined 缺点 外部无法访问内部私有变量 三种模块化规范： 1.CommonJS（代表：node.js） 前端真正提出模块化的概念，就是从commonJs的诞生开始的， 因为js作为一门嵌入型语言，处理页面逻辑和交互，即使没有模块化也能运行，并不会出什么问题，但是服务端却必须要有模块的概念。所以commonJs的发扬光大和nodejs相关，尤其是近几年nodejs的应用越来越广泛，npm统治整个前端以后，commonJs规范因此被大家熟知。 定义模块 根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性 模块输出 模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象 加载模块 加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象 // model1.js var age = 11 function say(){ console.log(age); } module.exports = { say } // index.html var wu = require('./index.js'); console.log(wu.say) 优点 解决了依赖、全局变量污染的问题 缺点 1.同步加载 CommonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，CommonJS不适合浏览器端模块加载，合理的方案是使用异步加载。 2.浏览器不能用 2.AMD（代表：RequireJS） AMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。 AMD规范使用依赖注入的模式，所有当前模块依赖的模块，都要通过异步来调用，执行语句放在回调函数里面。不依赖其他模块的语句，就不要放在回调函数里面，不干扰其他模块的运行。 CommonJS 规范主要是为服务器端的 NodeJS 服务，服务器端加载模块文件无延时，但是在浏览器上就大不相同了。AMD 即是为了在浏览器宿主环境中实现模块化方案的规范之一。 由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。 下载地址：https://requirejs.org/docs/release/2.3.6/comments/require.js AngularJS+RequireJS是符合AMD规范的。 引入依赖 模块定义 由 define 方法来定义，在 define API 中： id：模块名称，或者模块加载器请求的指定脚本的名字； dependencies：是个定义中模块所依赖模块的数组，默认为 [“require”, “exports”, “module”] factory：为模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值； // hello.js define('hello', function (x, y){ var add = function (x,y){ console.log(x, y) // 1, 2 　 return x+y; 　}; return { 　 add: add 　}; }); 模块引入 require()函数接受两个参数 第一个参数是一个数组，表示所依赖的模块 第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块 // main.js require.config({ 'baseUrl': './js', 'paths': { 'hello': './hello' } }) define('main', function() { require(['hello'], function(hello) { console.log(hello.add(1, 2)) // 3 }) }) require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。 3.CMD（代表：Sea.js） CMD 全称为 Common Module Definition，是 Sea.js 所推广的一个模块化方案的输出。 在 CMD define 的入参中，虽然也支持包含 id, deps 以及 factory 三个参数的形式，但推荐的是接受 factory 一个入参，然后在入参执行时，填入三个参数 require、exports 和 module： 模块定义 require是可以把其他模块导入进来的一个参数; 而exports是可以把模块内的一些属性和方法导出的; module 是一个对象，上面存储了与当前模块相关联的一些属性和方法。 define(function(require, exports, module) { // 每个函数单独导出 exports.add = function(x, y) { return x + y; } }); 引用模块 define(function(require, exports, module) { var hello = require('hello'); console.log(hello.add(2,3)); // 单独导出 exports.init = function init() { console.log('init'); } }); html调用 seajs.config({ base: './js', // 后续引用基于此路径 alias: { // 别名，可以用一个名称 替代路径（基于base路径） hello: './js/hello.js' }, }); // 加载入口模块 seajs.use(\"./main.js\", function(main) { main.init(); // init }); AMD和CMD的区别 关于这两种的区别网上有很多版本，大体意思差不多： AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 CMD推崇就近依赖，只有在用到某个模块的时候再去require 所以从这一点上来看，两者在性能上并没有太多差异。因为最影响页面渲染速度的当然是资源的加载速度，既然都是预加载，那么加载模块资源的耗时是一样的（网络情况相同时）。 UMD UMD，全称 Universal Module Definition，即通用模块规范。 既然 CommonJs 和 AMD 风格一样流行，那么需要一个可以统一浏览器端以及非浏览器端的模块化方案的规范。 现在主流框架的源码都是用的UMD规范，因为它既可以兼容浏览器端又可以兼容node。 UMD的实现： 先判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块； 再判断是否支持 Node.js 模块格式（exports 是否存在），存在则使用 Node.js 模块格式； 前两个都不存在，则将模块公开到全局（window 或 global）； 全局对象挂载属性 (function(root, factory) { console.log('没有模块环境，直接挂载在全局对象上') console.log(factory()) root.umdModule = factory(); }(this, function() { return { name: '我是一个umd模块' } })) 我们把factory写成一个匿名函数，利用IIFE（立即执行函数）去执行工厂函数，返回的对象赋值给root.umdModule，这里的root就是指向全局对象this，其值可能是window或者global，视运行环境而定。 兼容AMD环境 (function(root, factory) { if (typeof define === 'function' && define.amd) { // 如果环境中有define函数，并且define函数具备amd属性，则可以判断当前环境满足AMD规范 console.log('是AMD模块规范，如require.js') define(factory) } else { console.log('没有模块环境，直接挂载在全局对象上') root.umdModule = factory(); } }(this, function() { return { name: '我是一个umd模块' } })) 兼容commonJs和CMD (function(root, factory) { if (typeof module === 'object' && typeof module.exports === 'object') { console.log('是commonjs模块规范，nodejs环境') module.exports = factory(); } else if (typeof define === 'function' && define.amd) { console.log('是AMD模块规范，如require.js') define(factory) } else if (typeof define === 'function' && define.cmd) { console.log('是CMD模块规范，如sea.js') define(function(require, exports, module) { module.exports = factory() }) } else { console.log('没有模块环境，直接挂载在全局对象上') root.umdModule = factory(); } }(this, function() { return { name: '我是一个umd模块' } })) Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 16:10:06 "},"shared/生产排期性能分析.html":{"url":"shared/生产排期性能分析.html","title":"生产排期性能分析","keywords":"","body":"生产排期性能分析 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 14:55:05 "},"shared/项目建议及优化.html":{"url":"shared/项目建议及优化.html","title":"项目建议及优化","keywords":"","body":"项目建议及优化 参考：https://zhuanlan.zhihu.com/p/37553497 涉及模块、组件、服务、静态资源、第三方包等 性能优化 1.对应开发模块通过路由访问的，一律使用路由懒加载，提高站点访问速度。目前存在多个子模块一起加载的情况。 2.对应开发文件过大的，一律拆解成多个文件，减少非当前页面因某个文件报错而导致的无法访问，或者页面过重导致数据渲染过慢等问题。目前项目的文件检测已放大至4倍，打包依旧存在过大的文件警告，具体可根据打包环境提示的警告文件进行优化。 3.涉及接口及模块（组件）公用功能的服务，尽可能写在同一个服务中。后续可能会因服务过大对服务文件再次拆解成多个服务文件。 4.静态资源，除包内自带的图标/图片、相关联的文件，以及项目需及时加载的文件外，可通过静态资源服务器托管。可对静态资源进行单独管理，减少前端项目打包体积，提高项目加载速度。 5.凡是涉及异步的操作，请及时抛出并处理异常。比如loading加载项，请求/响应失败后未关闭，导致按钮或者表格等无法继续进行，需手动刷新或关闭页签才行。 6.第三方包需精简。考虑客户环境网络因素，不使用外部网络请求cdn方式，采取本地文件导入方式，降低开发包大小，提高代码编译执行效率。 需求及建议 1.组件、业务、服务尽可能分离，提高组件、服务复用率，为后续微前端打基础。 2.项目中，涉及带\"+\"查询的自定义组件，以及条件查询中的普通表单组件（日期、下拉框除外），需添加回车查询事件。可能部分自定义组件（控件）的回车已对接了其他功能，根据需求进行相应调整。目前考虑到的方案是查询页添加页面的回车监听事件。 3.全局数据、通用字段（价格、数量等）获取及处理，尽可能通过公共服务（公共、设置、权限、系统参数等）的指定方法获取及处理，尽可能减少网络请求二次获取（如权限等）。样式尽可能使用全局样式，尽可能做到样式与页面分离。 4.对表格进行二次封装或替换其他表格插件，目前表格的功能（勾选、虚拟滚动、拖拽等）、模板渲染，代码冗余度高，开发效率低，将通过配置项对表格渲染及操作进行视图驱动。 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-02-29 17:58:30 "},"shared/项目翻译处理.html":{"url":"shared/项目翻译处理.html","title":"项目翻译处理","keywords":"","body":"项目翻译处理 团队协作地址： 【金山文档】 翻译配置（梁坤锋） https://kdocs.cn/l/cr4v8LGHITDr 注：区域配置组件自动配有翻译字段translateKey，无需写入excel中！ 翻译文件 所处位置：05-webscm/src/assets/i18n 通过handle处理后生成的文件，请覆盖至所处位置中。 翻译格式 分类翻译 可按功能、模块等自行划分，最终会按语言整合成在一起。 自动生成翻译文件 通过handle脚本选择excel并生成翻译文件 数据结构 标准json文件的key为字符串，使用使用中文作为key更为直观。 代码使用方法 管道方式： [placeholder]=\"'请输入手机号'|translate\" 自定义模板解析方式： 注：支持运算符处理后得出的字符串 {{ control.errors.info }} {{ time + \" s\" }} 发送验证码 翻译前后代码对比 翻以前： 翻译后： Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 14:55:05 "},"study-document/rbac.html":{"url":"study-document/rbac.html","title":"rbac","keywords":"","body":"RBAC RBAC（Role-Based Access Control）是一种访问控制的权限管理模型。它基于角色对用户进行授权，而不是直接将权限分配给个别用户。RBAC 模型将用户划分为不同的角色，每个角色都具有特定的权限。这种模型的核心思想是将权限与角色关联，然后将角色分配给用户。 RBAC 模型通常由以下几个核心概念组成： 用户（User）：系统中的实际用户。 角色（Role）：代表一组具有相似权限需求的用户。 权限（Permission）：表示可执行的操作或访问资源的能力。 资源（Resource）：受到访问控制的对象，如数据、文件等。 授权（Authorization）：将角色与权限相关联并分配给用户的过程。 RBAC 模型的优点包括： 简化权限管理：通过使用角色作为中间层，RBAC 可以简化权限管理，减少了直接将权限赋予每个用户所带来的复杂性。 避免权限混乱：通过角色的分配和撤销，可以确保用户只有所需的最低权限，避免了权限的滥用和混乱。 提高安全性：RBAC 模型可以根据不同的角色划分敏感资源的访问权限，从而提高系统的安全性。 灵活性：通过调整角色和权限的关系，可以很容易地进行权限管理的调整和变更。 在实际应用中，RBAC 模型可以应用于各种场景，包括操作系统、数据库系统、Web 应用程序等，以实现对系统资源的访问控制和权限管理。 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-08-17 16:54:21 "},"tools/css文件转行内样式.html":{"url":"tools/css文件转行内样式.html","title":"css文件转行内样式","keywords":"","body":"css文件转行内样式（打印机使用） https://github.com/jonkemp/inline-css var inlineCss = require('inline-css'); var html = ``; inlineCss(html,{url:'/'}).then(function(html) { console.log(html); }); Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-03-07 15:24:44 "},"tools/typora.html":{"url":"tools/typora.html","title":"typora","keywords":"","body":"最新下载地址 https://mydown.yesky.com/pcsoft/107253300/versions/ 破解文件下载地址 参考：https://blog.csdn.net/zhaohaobingniu/article/details/128770959 文件提取链接：https://pan.baidu.com/s/1qQGHFOVAgnDaCbuafshQbA 提取码：cwm9 将 winmm.dll 文件放置在 typora 安装目录的根目录下 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-24 15:06:46 "},"tools/vscode.html":{"url":"tools/vscode.html","title":"vscode","keywords":"","body":"VSCode添加至右键菜单 https://blog.csdn.net/assassinator_567/article/details/106719647 插件 Import Cost 查看你引入的依赖模块大小 Auto Close Tag 自动补全 html 标签 Auto Rename Tag 自动重命名 html 标签 VSCode格式化配置 vscode-settings.json { \"editor.minimap.maxColumn\": 9999, \"editor.wordWrapColumn\": 9999, \"editor.codeActionsOnSave\": null, \"[html]\": { \"editor.defaultFormatter\": \"HookyQR.beautify\" }, \"html.format.wrapLineLength\": 9999, \"terminal.integrated.shell.windows\": \"C:\\\\Windows\\\\System32\\\\cmd.exe\", \"typescript.updateImportsOnFileMove.enabled\": \"always\", \"explorer.confirmDragAndDrop\": false, \"explorer.confirmDelete\": false, \"[json]\": { \"editor.defaultFormatter\": \"HookyQR.beautify\" }, \"javascript.updateImportsOnFileMove.enabled\": \"always\", \"editor.tabSize\": 2, \"git.autofetch\": true, \"[jsonc]\": { \"editor.defaultFormatter\": \"vscode.json-language-features\" }, \"window.zoomLevel\": 0, \"[javascript]\": { \"editor.defaultFormatter\": \"vscode.typescript-language-features\" }, \"vscode_custom_css.imports\": [ \"file:///C:/users/MyUsersName/synthwave84.css\" ], \"vscode_custom_css.policy\": true, \"update.enableWindowsBackgroundUpdates\": true, \"background.customImages\": [ \"D:/pictures/pic3.jpg\" ], \"background.style\": { \"content\": \"''\", \"pointer-events\": \"none\", \"position\": \"absolute\", //图片位置 \"width\": \"100%\", \"height\": \"100%\", \"z-index\": \"99999\", \"background.repeat\": \"repeat-Y\", \"background-size\": \"cover\", \"opacity\": \".2\" //透明度 }, \"background.useFront\": true, \"background.useDefault\": false, \"glassit.alpha\": 220, \"editor.fontSize\": 13, \"angular.enable-experimental-ivy-prompt\": false, \"[typescript]\": { \"editor.defaultFormatter\": \"vscode.typescript-language-features\" }, \"[scss]\": { \"editor.defaultFormatter\": \"HookyQR.beautify\" }, \"[vue]\": { \"editor.defaultFormatter\": \"octref.vetur\" }, \"[less]\": { \"editor.defaultFormatter\": \"HookyQR.beautify\" }, \"workbench.editorAssociations\": { \"*.db\": \"default\" }, \"security.workspace.trust.untrustedFiles\": \"open\", \"todo-tree.general.tags\": [ \"BUG\", \"HACK\", \"FIXME\", \"TODO\", \"XXX\", \"[ ]\", \"[x]\" ], \"todo-tree.regex.regex\": \"(//|#| Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-03-08 11:14:15 "},"tools/xftp与xshell.html":{"url":"tools/xftp与xshell.html","title":"xftp与xshell","keywords":"","body":"xftp 下载地址：https://www.xshell.com/zh/downloading/?token=WmdzMXd5ZVdNVmNLM3RvaTRkbldtd0BsbXMtV3RZZ0U2YUxVUUVGdWs4VzhR xshell 下载地址：https://www.xshell.com/zh/downloading/?token=Tlg0SVJGTVdxa0hYZDBpVEdnS3RMd0BsbXMtV3RZZ0U2YUxVUUVGdWs4VzhR ssh ssh ross@192.168.1.27 pw:ross1234 # 文件移动 mv ./111.txt ./web sftp sftp ross@192.168.1.27 pw:ross1234 # 上传（put 本地文件路径 远程路径） put ./111.txt ./ # 下载（get 远程文件路径 本地路径） get ./111.txt ./ Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 12:18:50 "},"tools/代码编辑器插件.html":{"url":"tools/代码编辑器插件.html","title":"代码编辑器插件","keywords":"","body":"ngstack/code-editor https://github.com/ngstack/code-editor CodeMirror(代码编辑器) https://codemirror.net/ Monaco Editor(代码编辑器) https://github.com/microsoft/monaco-editor 打包后assets文件过大处理方法： https://blog.csdn.net/qq_35485875/article/details/126344474 angular.json 中build的assets 配置如下： {\"glob\": \"**/*\",\"input\": \"node_modules/monaco-editor/esm/vs/editor/editor.api\",\"output\": \"assets/monaco-editor/\"} 注：配置后格式化未生效，需添加定时器延迟触发更新 setTimeout(() => { const code = this.editorRef.editor?.getValue(); this.editorRef.editor?.getAction('editor.action.formatDocument').run(); this.editorRef.editor?.setValue(code); }, 1200); // 配置信息 const option = { value: '', // 编辑器初始显示文字 language: 'sql', // 语言支持自行查阅demo automaticLayout: true, // 自动布局 foldingStrategy: 'indentation', // 代码可分小段折叠 autoClosingBrackets: 'always', // 是否自动添加结束括号(包括中括号) \"always\" | \"languageDefined\" | \"beforeWhitespace\" | \"never\" autoClosingDelete: 'always', // 是否自动删除结束括号(包括中括号) \"always\" | \"never\" | \"auto\" autoClosingQuotes: 'always', // 是否自动添加结束的单引号 双引号 \"always\" | \"languageDefined\" | \"beforeWhitespace\" | \"never\" autoIndent: 'None', // 控制编辑器在用户键入、粘贴、移动或缩进行时是否应自动调整缩进 comments: { ignoreEmptyLines: true, // 插入行注释时忽略空行。默认为真。 insertSpace: true // 在行注释标记之后和块注释标记内插入一个空格。默认为真。 }, // 注释配置 cursorBlinking: 'Solid', // 光标动画样式 cursorSmoothCaretAnimation: true, // 是否启用光标平滑插入动画 当你在快速输入文字的时候 光标是直接平滑的移动还是直接\"闪现\"到当前文字所处位置 cursorSurroundingLines: 0, // 光标环绕行数 当文字输入超过屏幕时 可以看见右侧滚动条中光标所处位置是在滚动条中间还是顶部还是底部 即光标环绕行数 环绕行数越大 光标在滚动条中位置越居中 cursorSurroundingLinesStyle: 'all', // \"default\" | \"all\" 光标环绕样式 cursorWidth: 2, // Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-03-07 15:21:44 "},"tools/图床与图床工具.html":{"url":"tools/图床与图床工具.html","title":"图床与图床工具","keywords":"","body":"smms图床 官网：https://smms.app/ API文档：https://doc.sm.ms/ markdown配置： https://blog.csdn.net/spongebob0018/article/details/122748701 上传失败处理： 修改picgo的smms插件请求地址 https://www.bilibili.com/video/BV17D4y167ue/?vd_source=1390a41caddc0c842b1b8449237f0024 具体操作： 1.打开C:\\Users\\CodeFront\\AppData\\Roaming\\picgo\\node_modules\\picgo-plugin-smms-user\\src\\index.js https://sm.ms修改为https://smms.app 2.在C:\\Users\\CodeFront\\AppData\\Roaming\\picgo目录下克隆 picgo-plugin-smms-user （git clone https://github.com/xlzy520/picgo-plugin-smms-user.git）插件，执行 npm install ./picgo-plugin-smms-user，并重启 PicGO 图床工具 PicGO图床工具 下载页面：https://github.com/Molunerfinn/picgo/releases 下载地址：https://github.com/Molunerfinn/ 使用github搭建图床 http://michael007js.cn/news/shownews.php?id=346 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 10:02:25 "},"tools/图片及性能优化.html":{"url":"tools/图片及性能优化.html","title":"图片及性能优化","keywords":"","body":"参考： https://blog.csdn.net/qq_42033567/article/details/107870246 https://heapdump.cn/article/3540287 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-12 17:05:36 "},"tools/实用工具.html":{"url":"tools/实用工具.html","title":"实用工具","keywords":"","body":"表格 https://handsontable.com https://visactor.io/vtable cdnjs 仓库 https://cdnjs.com/ 编程电子书 itdevbooks Exif.js获取图像元数据 http://code.ciaoca.com/javascript/exif-js/ GitLab 使用 GitLab - 芒果文档 (imangodoc.com) pdf转其他格式文件 https://www.hipdf.cn/ notepadd++添加至右键菜单 reg add \"hkey_classes_root\\*\\shell\\notepad++\" /t reg_sz /v \"\" /d \"notepad++ 编辑\" /f Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-11-28 13:57:50 "},"tools/拖拽.html":{"url":"tools/拖拽.html","title":"拖拽","keywords":"","body":"dragula 拖拽 https://github.com/bevacqua/dragula 示例：https://valor-software.com/ng2-dragula/index.html 表单解析器：https://github.com/JakHuang/form-generator/issues/32 ng2-dragula 拖拽 https://github.com/valor-software/ng2-dragula#readmebai 自定义拖拽插件原理解析：https://juejin.cn/post/6908502083075325959 angular项目地址：https://gitee.com/codefront/from-design-angular // 解决ng2-dragula插件不拖拽阴影导致的节点报错 // https://github.com/valor-software/ng2-dragula/issues/487 .gu-transit { pointer-events: none; } Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-03-07 15:23:12 "},"typescript/装饰器.html":{"url":"typescript/装饰器.html","title":"装饰器","keywords":"","body":"装饰器 参考：https://blog.csdn.net/woyebuzhidao321/article/details/123146102 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-03-28 20:45:25 "},"typescript/进阶及高级用法.html":{"url":"typescript/进阶及高级用法.html","title":"进阶及高级用法","keywords":"","body":"参考：https://zhuanlan.zhihu.com/p/503812618 TS 是一种静态类型检测，并不会执行你的代码 泛型（type） 把明确类型的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型，简单点来讲我们可以将泛型理解成为把类型当作参数一样去传递 接口泛型位置不同，效果也会不同。 泛型约束 所谓泛型约束，通俗点来讲就是约束泛型需要满足的格式。 解决泛型约束方法，使用extends 关键字 。 extends extends 关键字在声明泛型时约束泛型需要满足的条件 keyof 运算符 运算符采用keyof对象类型并生成其键的字符串或数字文字联合 is（关键字） is 关键字其实更多用在函数的返回值上，用来表示对于函数返回值的类型保护 | （条件类型或分发） type isString = T extends string ? true : false; // a 的类型为 true let a: isString // b 的类型为 false let b: isString; 循环 interface IProps { name: string; age: number; highSchool: string; university: string; } // IPropsKey类型为 // type IPropsKey = { // name: boolean; // age: boolean; // highSchool: boolean; // university: boolean; // } type IPropsKey = { [K in keyof IProps]: boolean }; Exclude（类型排除） type TypeA = string | number | boolean | symbol; // ExcludeSymbolType 类型为 string | number | boolean，排除了symbol类型 type ExcludeSymbolType = Exclude; 类型兼容性（多的可以赋给少的） 分发的参数类型多的可赋给少的，但方法只能是参数类型少的赋值给多的 infer（待推断类型） infer 代表待推断类型，它的必须和 extends 条件约束类型一起使用 type Flatten = Type extends Array ? Item : Type; 逆变（少的可以赋给多的，与类型兼容性相反） 函数的参数的方式被称为逆变。 let fn1!: (a: string, b: number) => void; let fn2!: (a: string, b: number, c: boolean) => void; fn1 = fn2; // TS Error: 不能将fn2的类型赋值给fn1 let fn1!: (a: string, b: number) => void; let fn2!: (a: string, b: number, c: boolean) => void; fn2 = fn1; // 正确，被允许 unknown & any（任意类型） 对于以后并不确定类型的变量尽量使用更多的 unknown 来代替 any 让你的代码更加强壮 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-04-28 15:46:00 "},"vite/angular集成vite测试.html":{"url":"vite/angular集成vite测试.html","title":"angular集成vite测试","keywords":"","body":"angular集成vite测试（vite暂不支持angular） https://github.com/xiaoxiangmoe/vite-ng-app-demo/issues 安装 view 和 concurrently Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-02-27 11:32:56 "},"vue/devtools.html":{"url":"vue/devtools.html","title":"devtools","keywords":"","body":"Devtools 安装及使用 克隆官方项目 git clone https://github.com/vuejs/devtools.git 安装依赖 # 官方使用的是 yarn，所以使用 yarn 进行安装，否则会报错 yarn install 打包 yarn run build 使用 chrome 更多工具 -> 扩展程序 -> 启用开发者模式 -> 加载已解压的扩展程序，把项目的 packages/shell-chrome 文件夹导入即可。 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-05-04 14:07:15 "},"vue/vue3.0.html":{"url":"vue/vue3.0.html","title":"vue3","keywords":"","body":"Vue 3.0 官网：https://v3.cn.vuejs.org/guide/migration/introduction.html 冷启动/热启动 冷启动 当启动应用时，后台没有该应用的进程，这时系统会重新创建一个新的进程分配给该应用，这个启动方式就是冷启动。 热启动 当启动应用时，后台已有该应用的进程（例：按home键回到桌面，但是该应用的进程是依然会保留在后台，可进入任务列表查看），所以在已有进程的情况下，这种启动会从已有的进程中来启动应用，这个方式叫热启动。 vite 介绍 参考地址：https://baijiahao.baidu.com/s?id=1684779666333900793&wfr=spider&for=pc Vite是Vue的作者尤雨溪开发的Web开发构建工具，它是一个基于浏览器原生ES模块导入的开发服务器，在开发环境下，利用浏览器去解析import，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随启随用。同时不仅对Vue文件提供了支持，还支持热更新，而且热更新的速度不会随着模块增多而变慢。在生产环境下使用Rollup打包。 vite 特点 1.快速的冷启动 2.即时热模块更新（HMR，Hot Module Replacement） 3.真正按需编译 Vite是在推出Vue 3的时候开发的，目前仅支持Vue 3.x，这意味着与Vue 3不兼容的库也不能与Vite一起使用。 安装/起步 通过脚手架 Vite npm init @vitejs/app hello-vue3 # OR yarn create @vitejs/app hello-vue3 通过脚手架 vue-cli npm install -g @vue/cli # 或 yarn global add @vue/cli vue create hello-vue3 新特性 组合式 API Teleport 片段 触发组件选项 来自 @vue/runtime-core 的 createRenderer API 创建自定义渲染器 单文件组件组合式 API 语法糖 () 单文件组件状态驱动的 CSS 变量 () 单文件组件 `` 现在可以包含全局规则或只针对插槽内容的规则 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2021-11-18 15:05:29 "},"vue/vue3.0开发事项.html":{"url":"vue/vue3.0开发事项.html","title":"vue3","keywords":"","body":"找不到模块“@/xxx”或其相应的类型声明 https://www.cnblogs.com/JasmineHan/p/13673560.html Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2021-11-18 15:06:00 "},"vue/vue细节处理.html":{"url":"vue/vue细节处理.html","title":"vue细节处理","keywords":"","body":"Vue细节处理 语法糖 v-bind: : // 绑定属性，如果属性有大写，需使用kebab-case方式绑定 v-on: @ // 绑定事件 v-slot: # // 指定插槽名称，默认为#default，必须带参 组件名大小写（2种） kebab-case(短横线隔开式) PascalCase(驼峰式) v-model基本原理 等价于： 将原生事件绑定到组件 .native可直接监听原生事件 eg: 注意：在app、小程序端和h5端表现不一致，h5端获取到的是浏览器原生事件 子组件数据同步更新到父组件 当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定。 .sync 它会被扩展为一个自动更新父组件属性的 v-on 监听器 eg： 插槽（匿名插槽、具名插槽、作用于插槽） 子组件 template 中没有包含一个 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃（即：子组件内容会被丢弃） 一个不带 name 的 出口会带有隐含的名字 “default” Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2022-04-28 16:56:31 "},"workflow/drone.html":{"url":"workflow/drone.html","title":"drone","keywords":"","body":"http://markdown.rossai.cn/r/vzzw2eycq77vt4kv0zkg Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-02-27 09:20:21 "},"运维/Linux基础服务sshd.html":{"url":"运维/Linux基础服务sshd.html","title":"Linux基础服务sshd","keywords":"","body":"Linux sshd服务 参考： Linux服务篇-sshd服务：https://blog.csdn.net/qianshuiliyu/article/details/108664983 介绍 SSH 协议：安全外壳协议，为 Secure Shell 的缩写。SSH 为建立在应用层和传输层基础上的安全协议。 作用 sshd服务使用SSH协议可以用来进行远程控制， 或在计算机之间传送文件，相比较之前用telnet方式来传输文件要安全很多，因为telnet使用明文传输，ssh是加密传输。 检查是否安装 ssh 服务，部分系统可能会原装 rpm -qa | grep ssh Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-22 14:55:05 "},"运维/localtunnel.html":{"url":"运维/localtunnel.html","title":"localtunnel","keywords":"","body":"localtunnel github地址：https://github.com/localtunnel/localtunnel localtunnel将您的本地主机公开给世界，以方便测试和共享！无需为了让其他人测试您的更改而破坏DNS或进行部署。 相当于创建临时公网隧道 安装 npm install -g localtunnel yarn add localtunnel 使用 npx localtunnel --port 8000 全局安装可用 lt --port 8000 Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2024-03-12 19:17:52 "},"运维/ssh-frp.html":{"url":"运维/ssh-frp.html","title":"ssh-frp","keywords":"","body":"ssh-frp 参考： https://www.zhihu.com/question/22568892?utm_id=0 https://zhuanlan.zhihu.com/p/615718858 http://lihuaxi.xjx100.cn/news/104579.html?action=onClick Copyright © 951450262@qq.com 2021 all right reserved，powered by Gitbook文件修订时间： 2023-12-11 12:34:08 "}}